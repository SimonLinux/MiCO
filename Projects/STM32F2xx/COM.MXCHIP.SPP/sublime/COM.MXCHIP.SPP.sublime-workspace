{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"mico_c",
				"mico_Context_t	typedef"
			],
			[
				"mico_system_co",
				"mico_system_context_get_user_data(mico_Context_t *const in_context)	void *"
			],
			[
				"mico_sys",
				"mico_system_context_get()	mico_Context_t *"
			],
			[
				"F",
				"FIRMWARE_REVISION	macro"
			],
			[
				"uint",
				"uint8_t	typedef"
			],
			[
				"CONFIG_BY",
				"CONFIG_BY_AIRKISS	mico_config_source_t"
			],
			[
				"CONFIG_BY_EAS",
				"CONFIG_BY_EASYLINK_V2	mico_config_source_t"
			],
			[
				"kNot",
				"kNotPreparedErr	macro"
			],
			[
				"mico_system_",
				"mico_system_get_context()	mico_Context_t *"
			],
			[
				"user_config_data",
				"user_config_data_size	uint32_t"
			],
			[
				"mico",
				"mico_context	mico_Context_t*"
			],
			[
				"uin",
				"uint32_t	typedef"
			],
			[
				"mico_rtos_th",
				"mico_rtos_delete_thread(mico_thread_t *thread)	OSStatus"
			],
			[
				"t",
				"ttl	uint32_t"
			],
			[
				"mico_th",
				"mico_thread_t	typedef"
			],
			[
				"p",
				"peripheral_clock_reg	uint32_t"
			],
			[
				"re",
				"require_noerr(ERR, LABEL)	macro"
			],
			[
				"require_ac",
				"require_action_quiet(X, LABEL, ACTION)	macro"
			],
			[
				"SPIX",
				"SPIX_AF	macro"
			],
			[
				"platform_po",
				"platform_mcu_powersave_enable()	OSStatus"
			],
			[
				"platform_g",
				"platform_gpio_enable(const platform_gpio_t *gpio)	OSStatus"
			],
			[
				"platform_w",
				"platform_watchdog_kick()	OSStatus"
			],
			[
				"req",
				"require_noerr(ERR, LABEL)	macro"
			],
			[
				"ch",
				"chunkedDataBufferLen	unsigned int"
			],
			[
				"c",
				"onClearCallback	OSStatus (*)(struct _HTTPHeader_t *, void *)"
			],
			[
				"kUn",
				"kUnknownErr	macro"
			],
			[
				"o",
				"onReceivedDataCallback	bool (*)(struct _HTTPHeader_t *)"
			],
			[
				"wla",
				"wLanUnConfigured	Config_State_t"
			],
			[
				"WL_",
				"WL_GPIO1_PIN	macro"
			],
			[
				"platform",
				"platform_log(M, ...)	macro"
			],
			[
				"pi",
				"pin_rx	const platform_pin_mapping_t *"
			],
			[
				"MicoGpio",
				"MicoGpioEnableIRQ(mico_gpio_t gpio, mico_gpio_irq_trigger_t trigger, mico_gpio_irq_handler_t handler, void *arg)	OSStatus"
			],
			[
				"MicoGP",
				"MicoGpioEnableIRQ(mico_gpio_t gpio, mico_gpio_irq_trigger_t trigger, mico_gpio_irq_handler_t handler, void *arg)	OSStatus"
			],
			[
				"OUTPUT_OD",
				"OUTPUT_OPEN_DRAIN_NO_PULL	mico_gpio_config_t"
			],
			[
				"MICOSYS",
				"MicoSystemStandBy()	void"
			],
			[
				"MicoWd",
				"MicoWdgInitialize(uint32_t timeout)	OSStatus"
			],
			[
				"MicoR",
				"MicoRtcSetTime(mico_rtc_time_t *time)	OSStatus"
			],
			[
				"m",
				"month	uint8_t"
			],
			[
				"MICO_I",
				"MICO_I2C_CP	macro"
			],
			[
				"ke",
				"keyLength	int"
			],
			[
				"s",
				"security	SECURITY_TYPE_E"
			],
			[
				"MicoGpioO",
				"MicoGpioOutputLow(mico_gpio_t gpio)	OSStatus"
			],
			[
				"k",
				"kBackoffErr	macro"
			],
			[
				"mico_rtos_in",
				"mico_rtos_init_semaphore(mico_semaphore_t *semaphore, int count)	OSStatus"
			],
			[
				"tm",
				"tm_wday	int"
			],
			[
				"tm_m",
				"tm_mon	int"
			],
			[
				"tm_",
				"tm_mday	int"
			],
			[
				"mico_rtos_d",
				"mico_rtos_delete_thread(mico_thread_t *thread)	OSStatus"
			],
			[
				"MICORe",
				"MICORemoveNotification(mico_notify_types_t notify_type, void *functionAddress)	OSStatus"
			],
			[
				"I",
				"INADDR_ANY	macro"
			],
			[
				"MICOWlan",
				"MICOWlanEnablePowerSave	macro"
			],
			[
				"MICOWlanS",
				"MICOWlanStopEasyLink	macro"
			],
			[
				"MICOW",
				"MICOWlanGetIPStatus	macro"
			],
			[
				"MICOWl",
				"MICOWlanGetIPStatus	macro"
			],
			[
				"MICOWlanGe",
				"MICOWlanGetIPStatus	macro"
			],
			[
				"MICOWlanStart",
				"MICOWlanStartAdv	macro"
			],
			[
				"MICO",
				"MICO_NO_WAIT	macro"
			],
			[
				"micoGet",
				"micoGetMemoryInfo	macro"
			],
			[
				"DEF",
				"DEFAULT_REMOTE_UDP_PORT	macro"
			],
			[
				"send",
				"sendto(int sockfd, const void *buf, unsigned int len, int flags, const struct sockaddr_t *dest_addr, socklen_t addrlen)	int"
			],
			[
				"DHCP",
				"DHCP_Disable	DHCPOperationMode"
			],
			[
				"DHC",
				"DHCP_Client	DHCPOperationMode"
			],
			[
				"b",
				"BundleSeedID	char [32]"
			],
			[
				"ma",
				"manufacturer	char [32]"
			],
			[
				"n",
				"name	char [32]"
			],
			[
				"Platform",
				"PlatformWDGReload()	void"
			],
			[
				"RE",
				"REMOTE_CONNECT	enum <anonymous>"
			],
			[
				"_us",
				"_uart_send_mutex	mico_mutex_t"
			],
			[
				"requi",
				"require(X, LABEL)	macro"
			],
			[
				"_uart",
				"_uart_send_mutex	mico_mutex_t"
			],
			[
				"mico_rtos_init_s",
				"mico_rtos_init_semaphore(mico_semaphore_t *semaphore, int count)	MxchipStatus"
			],
			[
				"mico_rtosge",
				"mico_rtos_get_semaphore(mico_semaphore_t *semaphore, unsigned int timeout_ms)	MxchipStatus"
			],
			[
				"MICO_",
				"MICO_NEVER_TIMEOUT	macro"
			],
			[
				"eState_",
				"eState_Wlan_Powerdown	SYS_State_t"
			],
			[
				"plat",
				"PlatformUartIn"
			],
			[
				"memc",
				"memcmp(const void *, const void *, size_t)	int"
			],
			[
				"mico_rtos",
				"mico_rtos_init_mutex(mico_mutex_t *mutex)	MxchipStatus"
			],
			[
				"mico_t",
				"mico_mutex_t	typedef"
			],
			[
				"mico_rt",
				"mico_rtos_set_semaphore(mico_semaphore_t *semaphore)	MxchipStatus"
			],
			[
				"DE",
				"DEAFULT_REMOTE_SERVER	macro"
			],
			[
				"fl",
				"flashContentInRam	flash_content_t"
			],
			[
				"kNo",
				"kNoErr	macro"
			],
			[
				"lo",
				"localTcpClient_fd	int *"
			],
			[
				"PlatformFlash",
				"PlatformFlashWrite(volatile uint32_t *FlashAddress, uint32_t *Data, uint32_t DataLength)	OSStatus"
			],
			[
				"Platformf",
				"PlatformFlashInitialize()	OSStatus"
			],
			[
				"kc",
				"kChecksumErr	macro"
			],
			[
				"kun",
				"kUnknownErr	macro"
			],
			[
				"kC",
				"kChecksumErr	macro"
			],
			[
				"f",
				"flashContentInRam	flash_content_t"
			],
			[
				"fla",
				"flashContentInRam	flash_content_t"
			],
			[
				"mico_l",
				"mico_log(M, ...)	macro"
			],
			[
				"Button_STANDBY_",
				"Button_STANDBY_PIN	macro"
			],
			[
				"GPIO_Read",
				"GPIO_ReadInputDataBit(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)	uint8_t"
			],
			[
				"easylink",
				"easylinkClient_fd	int"
			],
			[
				"mico_rtos_set",
				"mico_rtos_set_semaphore(mico_semaphore_t *semaphore)	MxchipStatus"
			],
			[
				"es",
				"eState_Software_Reset	SYS_State_t"
			],
			[
				"mico_rtos_init_",
				"mico_rtos_init_semaphore(mico_semaphore_t *semaphore, int count)	MxchipStatus"
			],
			[
				"mico_s",
				"mico_semaphore_t	typedef"
			],
			[
				"e",
				"easyLinkSkip	bool"
			],
			[
				"require_noerr",
				"require_noerr_action(ERR, LABEL, ACTION)	macro"
			],
			[
				"DH",
				"DHCP_Client	DHCPOperationMode"
			],
			[
				"kn",
				"kNoErr	macro"
			],
			[
				"requ",
				"require(X, LABEL)	macro"
			],
			[
				"l",
				"localIp	char [16]"
			],
			[
				"ip",
				"local_ip_addr	char [16]"
			],
			[
				"int",
				"int32_t	typedef"
			],
			[
				"d",
				"dhcpEnable	bool"
			],
			[
				"inet",
				"inet_ntoa(char *s, unsigned int x)	char *"
			],
			[
				"a",
				"allConfigured	config_type"
			],
			[
				"Clos",
				"CloseEasylink2()	int"
			],
			[
				"mico_notify_WIFI_S",
				"mico_notify_WIFI_STATUS_CHANGED	mico_notify_types_t"
			],
			[
				"us",
				"user_key	char [64]"
			],
			[
				"u",
				"user_key	char [64]"
			],
			[
				"key",
				"key_len	int"
			],
			[
				"MX",
				"MXCHIP_SUCCESS	MxchipStatus"
			],
			[
				"require_",
				"require_action(X, LABEL, ACTION)	macro"
			],
			[
				"strn",
				"strncpy(char *restrict, const char *restrict, size_t)	char *"
			],
			[
				"__str",
				"__strdup_trans_dot(char *src)	char *"
			],
			[
				"temp",
				"temp2	WiFi_Status_Notify *"
			],
			[
				"kOper",
				"kNotPreparedErr	macro"
			],
			[
				"mico_rtos_i",
				"mico_rtos_init_mutex(mico_mutex_t *mutex)	MxchipStatus"
			],
			[
				"kU",
				"kUnknownErr	macro"
			],
			[
				"in",
				"inContext"
			],
			[
				"mico_rtos_ge",
				"mico_rtos_get_semaphore(mico_semaphore_t *semaphore, unsigned int timeout_ms)	MxchipStatus"
			],
			[
				"MF",
				"MFi_SERVICE_MFi	macro"
			],
			[
				"mico_rtos_de",
				"mico_rtos_delete_thread(mico_thread_t *thread)	MxchipStatus"
			],
			[
				"mico_re",
				"mico_rtos_init_mutex(mico_mutex_t *mutex)	MxchipStatus"
			],
			[
				"E",
				"ENABLE	FunctionalState"
			]
		]
	},
	"buffers":
	[
		{
			"file": "/Users/William/Develop/MiCO/include/Common.h",
			"settings":
			{
				"buffer_size": 29050,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "Searching 1914 files for \"NULL\"\n\n/Users/William/Develop/MiCO/include/Debug.h:\n   46      #define debug_print_assert(A,B,C,D,E,F) do {if (mico_debug_enabled==0)break;\\\n   47                                                       mico_rtos_lock_mutex( &stdio_tx_mutex );\\\n   48:                                                      printf(\"[%d][MICO:%s:%s:%4d] **ASSERT** %s\"\"\\r\\n\", mico_get_time(), (D!=NULL) ? D : \"\", F, E, (C!=NULL) ? C : \"\" );\\\n   49                                                       mico_rtos_unlock_mutex( &stdio_tx_mutex );}while(0==1)\n   50      #if TRACE\n   ..\n   59      #define custom_log(N, M, ...) do {printf(\"[%s: %s:%4d] \" M \"\\r\\n\",  N, SHORT_FILE, __LINE__, ##__VA_ARGS__);}while(0==1)\n   60                                          \n   61:     #define debug_print_assert(A,B,C,D,E,F) do {printf(\"[MICO:%s:%s:%4d] **ASSERT** %s\"\"\\r\\n\", (D!=NULL) ? D : \"\", F, E, (C!=NULL) ? C : \"\" );}while(0==1)\n   62      #if TRACE\n   63          #define custom_log_trace(N) do {printf(\"[%s: [TRACE] %s] %s()\\r\\n\", N, SHORT_FILE, __PRETTY_FUNCTION__);}while(0==1)\n   ..\n  135              if( unlikely( !(X) ) )                                                                      \\\n  136              {                                                                                           \\\n  137:                 debug_print_assert( 0, #X, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__ );             \\\n  138              }                                                                                           \\\n  139                                                                                                          \\\n  ...\n  180              if( unlikely( !(X) ) )                                                                          \\\n  181              {                                                                                               \\\n  182:                 debug_print_assert( 0, #X, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__ );                 \\\n  183                  goto LABEL;                                                                                 \\\n  184              }                                                                                               \\\n  ...\n  247              if( unlikely( localErr != 0 ) )                                                                 \\\n  248              {                                                                                               \\\n  249:                 debug_print_assert( localErr, NULL, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__ );        \\\n  250                  goto LABEL;                                                                                 \\\n  251              }                                                                                               \\\n  ...\n  273              if( unlikely( localErr != 0 ) )                                                                 \\\n  274              {                                                                                               \\\n  275:                 debug_print_assert( localErr, NULL, STR, __FILE__, __LINE__, __PRETTY_FUNCTION__ );         \\\n  276                  goto LABEL;                                                                                 \\\n  277              }                                                                                               \\\n  ...\n  299              if( unlikely( localErr != 0 ) )                                                                 \\\n  300              {                                                                                               \\\n  301:                 debug_print_assert( localErr, NULL, STR, __FILE__, __LINE__, __PRETTY_FUNCTION__ );         \\\n  302                  { ACTION; }                                                                                 \\\n  303                  goto LABEL;                                                                                 \\\n  ...\n  345              if( unlikely( localErr != 0 ) )                                                                 \\\n  346              {                                                                                               \\\n  347:                 debug_print_assert( localErr, NULL, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__ );        \\\n  348                  { ACTION; }                                                                                 \\\n  349                  goto LABEL;                                                                                 \\\n  ...\n  389              if( unlikely( !(X) ) )                                                                          \\\n  390              {                                                                                               \\\n  391:                 debug_print_assert( 0, #X, NULL, __FILE__, __LINE__, __PRETTY_FUNCTION__ );                 \\\n  392                  { ACTION; }                                                                                 \\\n  393                  goto LABEL;                                                                                 \\\n\n/Users/William/Develop/MiCO/include/mico_rtos.h:\n  103  /** @brief Creates and starts a new thread\n  104    *\n  105:   * @param thread     : Pointer to variable that will receive the thread handle (can be null)\n  106    * @param priority   : A priority number.\n  107:   * @param name       : a text name for the thread (can be null)\n  108    * @param function   : the main thread function\n  109    * @param stack_size : stack size for this thread\n  ...\n  118  /** @brief   Deletes a terminated thread\n  119    *\n  120:   * @param   thread     : the handle of the thread to delete, , NULL is the current thread\n  121    *\n  122    * @return  kNoErr        : on success.\n  ...\n  128  /** @brief    Suspend a thread\n  129    *\n  130:   * @param    thread     : the handle of the thread to suspend, NULL is the current thread\n  131    *\n  132    * @return   kNoErr        : on success.\n  ...\n  336    *\n  337    * @param    queue : a pointer to the queue handle to be initialised\n  338:   * @param    name  : a text string name for the queue (NULL is allowed)\n  339    * @param    message_size : size in bytes of objects that will be held in the queue\n  340    * @param    number_of_messages : depth of the queue - i.e. max number of objects in the queue\n\n/Users/William/Develop/MiCO/include/mico_socket.h:\n  402    * @param      timeout: The timeout argument specifies the interval that select() \n  403    *             should block waiting for a file descriptor to become ready. \n  404:   *             If timeout is NULL (no timeout), select() can block indefinitely.   \n  405    * @retval     On success, return the number of file descriptors contained in the \n  406    *             three returned descriptor sets (that is, the total number of bits \n  ...\n  493    * @brief      Receive a message from a socket and get the source address.\n  494    * @attention  Never doing operations on one socket in different MICO threads\n  495:   * @details    If src_addr is not NULL, and the underlying protocol provides \n  496    *             the source address of the message, that source address is placed \n  497    *             in the buffer pointed to by src_addr.  In this case, addrlen is \n  ...\n  503    *             a value greater than was supplied to the call.\n  504    *             If the caller is not interested in the source address, src_addr\n  505:   *             should be specified as NULL and addrlen should be specified as 0.\n  506    * @param      sockfd: Refer recv() for details.\n  507    * @param      buf: Refer recv() for details.\n  ...\n  636   *  @param      calen: the string length of ca. 0=do not verify server's certificate.\n  637   *  @param      ca: pointer to the CA certificate string, used to verify server's certificate.\n  638:  *  @param      errno: return the errno if ssl_connect return NULL.\n  639   *\n  640:  *  @retval     return the SSL context pointer on success or NULL for fail.\n  641   */\n  642  void* ssl_connect(int fd, int calen, char*ca, int *errno); \n  ...\n  646   *  @param      fd: The fd number for a connected TCP socket.\n  647   *\n  648:  *  @retval     return the SSL context pointer on success or NULL for fail.\n  649   */\n  650  void* ssl_accept(int fd); \n\n/Users/William/Develop/MiCO/include/mico_wlan.h:\n  396   *          with function:\n  397   *          void (*function)(network_InitTypeDef_st *nwkpara, mico_Context_t * const inContext);\n  398:  *          that provide SSID and password, nwkpara is NULL if timeout or get an error\n  399   *          More\n  400   *          MICO sends a callback: mico_notify_EASYLINK_GET_EXTRA_DATA\n  ...\n  404   *\n  405   *  @param  inTimeout: If easylink is excuted longer than this parameter in backgound.\n  406:  *          MICO stops EasyLink and sends a callback where nwkpara is NULL\n  407   *\n  408   *  @retval kNoErr.\n  ...\n  421   *\n  422   *  @param  inTimeout: If easylink is excuted longer than this parameter in backgound.\n  423:  *          MICO stops EasyLink and sends a callback where nwkpara is NULL\n  424   *\n  425   *  @retval kNoErr.\n  ...\n  437   *\n  438   *  @param  inTimeout: If WPS is excuted longer than this parameter in backgound.\n  439:  *          MICO stops WPS and sends a callback where nwkpara is NULL\n  440   *\n  441   *  @retval kNoErr.\n  ...\n  457   *          with function:\n  458   *          void (*function)(network_InitTypeDef_st *nwkpara, mico_Context_t * const inContext);\n  459:  *          that provide SSID and password, nwkpara is NULL if timeout or get an error\n  460   *\n  461   *  @param  inTimeout: If airkiss is excuted longer than this parameter in backgound.\n  462:  *          MICO stops airkiss and sends a callback where nwkpara is NULL\n  463   *\n  464   *  @retval kNoErr.\n\n/Users/William/Develop/MiCO/include/MicoSRPServer.h:\n  117  /* Out: bytes_B, len_B.\n  118   * \n  119:  * On failure, bytes_B will be set to NULL and len_B will be set to 0\n  120   * \n  121   * The n_hex and g_hex parameters should be 0 unless SRP_NG_CUSTOM is used for ng_type\n  ...\n  138  const char *          srp_verifier_get_username( struct SRPVerifier * ver );\n  139  \n  140: /* key_length may be null */\n  141  const unsigned char * srp_verifier_get_session_key( struct SRPVerifier * ver, int * key_length );\n  142  \n\n/Users/William/Develop/MiCO/include/MicoDrivers/MicoDriverI2c.h:\n   84  // typedef struct\n   85  // {\n   86: //     const void*  tx_buffer;  /**< A pointer to the data to be transmitted. If NULL, the message is an RX message when 'combined' is FALSE */\n   87: //     void*        rx_buffer;  /**< A pointer to the data to be transmitted. If NULL, the message is an TX message when 'combined' is FALSE */\n   88  //     uint16_t     tx_length;  /**< Number of bytes to transmit */\n   89  //     uint16_t     rx_length;  /**< Number of bytes to receive */\n\n/Users/William/Develop/MiCO/mico/security/Curve25519/curve25519-donna-c64.c:\n  440    int i;\n  441  \n  442:   if (basepoint == NULL) basepoint = kCurve25519BasePoint;\n  443  \n  444    for (i = 0;i < 32;++i) e[i] = secret[i];\n\n/Users/William/Develop/MiCO/mico/security/Curve25519/curve25519-donna-test.c:\n  170  		const curve25519_test_vector * const 	tv = &kCurve25519TestVectors[ i ];\n  171  		\n  172: 		err = HexToData( tv->e, kSizeCString, kHexToData_NoFlags, e, sizeof( e ), &len, NULL, NULL );\n  173  		require_noerr( err, exit );\n  174  		require_action( len == 32, exit, err = kSizeErr );\n  175  		\n  176: 		err = HexToData( tv->k, kSizeCString, kHexToData_NoFlags, k, sizeof( k ), &len, NULL, NULL );\n  177  		require_noerr( err, exit );\n  178  		require_action( len == 32, exit, err = kSizeErr );\n  179  		\n  180: 		err = HexToData( tv->ek, kSizeCString, kHexToData_NoFlags, ek, sizeof( ek ), &len, NULL, NULL );\n  181  		require_noerr( err, exit );\n  182  		require_action( len == 32, exit, err = kSizeErr );\n\n/Users/William/Develop/MiCO/mico/security/Curve25519/curve25519-donna.c:\n  813    int i;\n  814  \n  815:   if (basepoint == NULL) basepoint = kCurve25519BasePoint;\n  816  \n  817    for (i = 0; i < 32; ++i) e[i] = secret[i];\n\n/Users/William/Develop/MiCO/mico/security/SHAUtils/hkdf.c:\n   27   *      salt[ ]: [in]\n   28   *          The optional salt value (a non-secret random value);\n   29:  *          if not provided (salt == NULL), it is set internally\n   30   *          to a string of HashLen(whichSha) zeros.\n   31   *      salt_len: [in]\n   32:  *          The length of the salt value.  (Ignored if salt == NULL.)\n   33   *      ikm[ ]: [in]\n   34   *          Input keying material.\n   ..\n   37   *      info[ ]: [in]\n   38   *          The optional context and application specific information.\n   39:  *          If info == NULL or a zero-length string, it is ignored.\n   40   *      info_len: [in]\n   41   *          The length of the optional context and application specific\n   42:  *          information.  (Ignored if info == NULL.)\n   43   *      okm[ ]: [out]\n   44   *          Where the HKDF is to be stored.\n   ..\n   80   *      salt[ ]: [in]\n   81   *          The optional salt value (a non-secret random value);\n   82:  *          if not provided (salt == NULL), it is set internally\n   83   *          to a string of HashLen(whichSha) zeros.\n   84   *      salt_len: [in]\n   85:  *          The length of the salt value.  (Ignored if salt == NULL.)\n   86   *      ikm[ ]: [in]\n   87   *          Input keying material.\n   ..\n  102  {\n  103    int result;\n  104:   unsigned char *nullSalt = malloc(USHAMaxHashSize);\n  105:   if(nullSalt == 0) return shaNull; \n  106    if (salt == 0) {\n  107:     salt = nullSalt;\n  108      salt_len = USHAHashSize(whichSha);\n  109:     memset(nullSalt, '\\0', salt_len);\n  110    } else if (salt_len < 0) {\n  111:     free(nullSalt);\n  112      return shaBadParam;\n  113    }\n  114    result = hmac(whichSha, ikm, ikm_len, salt, salt_len, prk);\n  115:   free(nullSalt);\n  116    return result;\n  117  }\n  ...\n  136   *      info[ ]: [in]\n  137   *          The optional context and application specific information.\n  138:  *          If info == NULL or a zero-length string, it is ignored.\n  139   *      info_len: [in]\n  140   *          The length of the optional context and application specific\n  141:  *          information.  (Ignored if info == NULL.)\n  142   *      okm[ ]: [out]\n  143   *          Where the HKDF is to be stored.\n  ...\n  207   *      salt[ ]: [in]\n  208   *          The optional salt value (a non-secret random value);\n  209:  *          if not provided (salt == NULL), it is set internally\n  210   *          to a string of HashLen(whichSha) zeros.\n  211   *      salt_len: [in]\n  212:  *          The length of the salt value.  (Ignored if salt == NULL.)\n  213   *\n  214   *  Returns:\n  ...\n  219                const unsigned char *salt, int salt_len)\n  220  {\n  221:   unsigned char nullSalt[USHAMaxHashSize];\n  222:   if (!context) return shaNull;\n  223  \n  224    context->whichSha = whichSha;\n  225    context->hashSize = USHAHashSize(whichSha);\n  226    if (salt == 0) {\n  227:     salt = nullSalt;\n  228      salt_len = context->hashSize;\n  229:     memset(nullSalt, '\\0', salt_len);\n  230    }\n  231  \n  ...\n  256                int ikm_len)\n  257  {\n  258:   if (!context) return shaNull;\n  259    if (context->Corrupted) return context->Corrupted;\n  260    if (context->Computed) return context->Corrupted = shaStateError;\n  ...\n  285                    unsigned int ikm_bit_count)\n  286  {\n  287:   if (!context) return shaNull;\n  288    if (context->Corrupted) return context->Corrupted;\n  289    if (context->Computed) return context->Corrupted = shaStateError;\n  ...\n  303   *   prk[ ]: [out]\n  304   *     An optional location to store the HKDF extraction.\n  305:  *     Either NULL, or pointer to a buffer that must be\n  306   *     larger than USHAHashSize(whichSha);\n  307   *   info[ ]: [in]\n  308   *     The optional context and application specific information.\n  309:  *     If info == NULL or a zero-length string, it is ignored.\n  310   *   info_len: [in]\n  311   *     The length of the optional context and application specific\n  312:  *     information.  (Ignored if info == NULL.)\n  313   *   okm[ ]: [out]\n  314   *     Where the HKDF is to be stored.\n  ...\n  329    int ret;\n  330  \n  331:   if (!context) return shaNull;\n  332    if (context->Corrupted) return context->Corrupted;\n  333    if (context->Computed) return context->Corrupted = shaStateError;\n\n/Users/William/Develop/MiCO/mico/security/SHAUtils/hmac.c:\n   86    unsigned char tempkey[USHAMaxHashSize];\n   87  \n   88:   if (!context) return shaNull;\n   89    context->Computed = 0;\n   90    context->Corrupted = shaSuccess;\n   ..\n  162      int text_len)\n  163  {\n  164:   if (!context) return shaNull;\n  165    if (context->Corrupted) return context->Corrupted;\n  166    if (context->Computed) return context->Corrupted = shaStateError;\n  ...\n  192      uint8_t bits, unsigned int bit_count)\n  193  {\n  194:   if (!context) return shaNull;\n  195    if (context->Corrupted) return context->Corrupted;\n  196    if (context->Computed) return context->Corrupted = shaStateError;\n  ...\n  222  {\n  223    int ret;\n  224:   if (!context) return shaNull;\n  225    if (context->Corrupted) return context->Corrupted;\n  226    if (context->Computed) return context->Corrupted = shaStateError;\n\n/Users/William/Develop/MiCO/mico/security/SHAUtils/sha.h:\n   91  enum {\n   92      shaSuccess = 0,\n   93:     shaNull,            /* Null pointer parameter */\n   94      shaInputTooLong,    /* input data too long */\n   95      shaStateError,      /* called Input after FinalBits or Result */\n\n/Users/William/Develop/MiCO/mico/security/SHAUtils/sha1.c:\n   80  int SHA1Reset(SHA1Context *context)\n   81  {\n   82:   if (!context) return shaNull;\n   83  \n   84    context->Length_High = context->Length_Low = 0;\n   ..\n  121      const uint8_t *message_array, unsigned length)\n  122  {\n  123:   if (!context) return shaNull;\n  124    if (!length) return shaSuccess;\n  125:   if (!message_array) return shaNull;\n  126    if (context->Computed) return context->Corrupted = shaStateError;\n  127    if (context->Corrupted) return context->Corrupted;\n  ...\n  177    };\n  178  \n  179:   if (!context) return shaNull;\n  180    if (!length) return shaSuccess;\n  181    if (context->Corrupted) return context->Corrupted;\n  ...\n  215    int i;\n  216  \n  217:   if (!context) return shaNull;\n  218:   if (!Message_Digest) return shaNull;\n  219    if (context->Corrupted) return context->Corrupted;\n  220  \n\n/Users/William/Develop/MiCO/mico/security/SHAUtils/sha224-256.c:\n  230      unsigned int length)\n  231  {\n  232:   if (!context) return shaNull;\n  233    if (!length) return shaSuccess;\n  234:   if (!message_array) return shaNull;\n  235    if (context->Computed) return context->Corrupted = shaStateError;\n  236    if (context->Corrupted) return context->Corrupted;\n  ...\n  286    };\n  287  \n  288:   if (!context) return shaNull;\n  289    if (!length) return shaSuccess;\n  290    if (context->Corrupted) return context->Corrupted;\n  ...\n  342  static int SHA224_256Reset(SHA256Context *context, uint32_t *H0)\n  343  {\n  344:   if (!context) return shaNull;\n  345  \n  346    context->Length_High = context->Length_Low = 0;\n  ...\n  566    int i;\n  567  \n  568:   if (!context) return shaNull;\n  569:   if (!Message_Digest) return shaNull;\n  570    if (context->Corrupted) return context->Corrupted;\n  571  \n\n/Users/William/Develop/MiCO/mico/security/SHAUtils/sha384-512.c:\n  473          unsigned int length)\n  474  {\n  475:   if (!context) return shaNull;\n  476    if (!length) return shaSuccess;\n  477:   if (!message_array) return shaNull;\n  478    if (context->Computed) return context->Corrupted = shaStateError;\n  479    if (context->Corrupted) return context->Corrupted;\n  ...\n  529    };\n  530  \n  531:   if (!context) return shaNull;\n  532    if (!length) return shaSuccess;\n  533    if (context->Corrupted) return context->Corrupted;\n  ...\n  606  {\n  607    int i;\n  608:   if (!context) return shaNull;\n  609    context->Message_Block_Index = 0;\n  610  \n  ...\n 1015  #endif /* USE_32BIT_ONLY */\n 1016  \n 1017:   if (!context) return shaNull;\n 1018:   if (!Message_Digest) return shaNull;\n 1019    if (context->Corrupted) return context->Corrupted;\n 1020  \n\n/Users/William/Develop/MiCO/mico/security/SHAUtils/usha.c:\n   31  int USHAReset(USHAContext *context, enum SHAversion whichSha)\n   32  {\n   33:   if (!context) return shaNull;\n   34    context->whichSha = whichSha;\n   35    switch (whichSha) {\n   ..\n   66                const uint8_t *bytes, unsigned int bytecount)\n   67  {\n   68:   if (!context) return shaNull;\n   69    switch (context->whichSha) {\n   70      case SHA1:\n   ..\n  109                    uint8_t bits, unsigned int bit_count)\n  110  {\n  111:   if (!context) return shaNull;\n  112    switch (context->whichSha) {\n  113      case SHA1:\n  ...\n  152                 uint8_t Message_Digest[USHAMaxHashSize])\n  153  {\n  154:   if (!context) return shaNull;\n  155    switch (context->whichSha) {\n  156      case SHA1:\n\n/Users/William/Develop/MiCO/mico/system/mico_system_init.c:\n   35  #include \"mico.h\"\n   36  \n   37: static  mico_Context_t* context = NULL;\n   38  \n   39  mico_Context_t* mico_system_context_init( uint32_t user_config_data_size )\n   40  {\n   41:   void *user_config_data = NULL;\n   42  \n   43:   if( context !=  NULL) {\n   44:     if( context->user_config_data != NULL )\n   45        free( context->user_config_data );\n   46      free( context );\n   47:     context = NULL;\n   48    }\n   49  \n\n/Users/William/Develop/MiCO/mico/system/mico_system_monitor.c:\n   51    memset(system_monitors, 0, sizeof(system_monitors));\n   52  \n   53:   err = mico_rtos_create_thread(NULL, 0, \"SYS MONITOR\", mico_system_monitor_thread_main, STACK_SIZE_mico_system_MONITOR_THREAD, NULL );\n   54    require_noerr(err, exit);\n   55  exit:\n   ..\n   68      for (a = 0; a < MAXIMUM_NUMBER_OF_SYSTEM_MONITORS; ++a)\n   69      {\n   70:       if (system_monitors[a] != NULL)\n   71        {\n   72          if ((current_time - system_monitors[a]->last_update) > system_monitors[a]->longest_permitted_delay)\n   ..\n   90    for ( a = 0; a < MAXIMUM_NUMBER_OF_SYSTEM_MONITORS; ++a )\n   91    {\n   92:     if (system_monitors[a] == NULL)\n   93      {\n   94        system_monitor->last_update = mico_get_time();\n   ..\n  136    err = mico_system_monitor_register(&mico_monitor, APPLICATION_WATCHDOG_TIMEOUT_SECONDS*1000);\n  137    require_noerr( err, exit );\n  138:   mico_init_timer(&_watchdog_reload_timer,APPLICATION_WATCHDOG_TIMEOUT_SECONDS*1000/2, _watchdog_reload_timer_handler, NULL);\n  139    mico_start_timer(&_watchdog_reload_timer);  \n  140  exit:\n\n/Users/William/Develop/MiCO/mico/system/mico_system_notification.c:\n   43  } _Notify_list_t;\n   44  \n   45: _Notify_list_t* Notify_list[20] = {NULL};\n   46  \n   47  /* MICO system defined notifications */\n   ..\n   66  {\n   67    _Notify_list_t *temp =  Notify_list[mico_notify_WIFI_SCAN_COMPLETED];\n   68:   if(temp == NULL)\n   69      return;\n   70    else{\n   ..\n   72        ((mico_notify_WIFI_SCAN_COMPLETE_function)(temp->function))(pApList, temp->arg);\n   73        temp = temp->next;\n   74:     }while(temp!=NULL);\n   75    }\n   76  }\n   ..\n   79  {\n   80    _Notify_list_t *temp =  Notify_list[mico_notify_WIFI_SCAN_ADV_COMPLETED];\n   81:   if(temp == NULL)\n   82      return;\n   83    else{\n   ..\n   85        ((mico_notify_WIFI_SCAN_ADV_COMPLETE_function)(temp->function))(pApAdvList, temp->arg);\n   86        temp = temp->next;\n   87:     }while(temp!=NULL);\n   88    }\n   89  }\n   ..\n   92  {\n   93    _Notify_list_t *temp =  Notify_list[mico_notify_WIFI_STATUS_CHANGED];\n   94:   if(temp == NULL)\n   95      return;\n   96    else{\n   ..\n   98        ((mico_notify_WIFI_STATUS_CHANGED_function)(temp->function))(status, temp->arg);\n   99        temp = temp->next;\n  100:     }while(temp!=NULL);\n  101    }\n  102  }\n  ...\n  105  {\n  106    _Notify_list_t *temp =  Notify_list[mico_notify_WiFI_PARA_CHANGED];\n  107:   if(temp == NULL)\n  108      return;\n  109    else{\n  ...\n  111        ((mico_notify_WiFI_PARA_CHANGED_function)(temp->function))(ap_info, key, key_len, temp->arg);\n  112        temp = temp->next;\n  113:     }while(temp!=NULL);\n  114    }\n  115  }\n  ...\n  118  {\n  119    _Notify_list_t *temp =  Notify_list[mico_notify_DHCP_COMPLETED];\n  120:   if(temp == NULL)\n  121      return;\n  122    else{\n  ...\n  124        ((mico_notify_DHCP_COMPLETE_function)(temp->function))(pnet, temp->arg);\n  125        temp = temp->next;\n  126:     }while(temp!=NULL);\n  127    }\n  128  }\n  ...\n  131  {\n  132    _Notify_list_t *temp =  Notify_list[mico_notify_EASYLINK_WPS_COMPLETED];\n  133:   if(temp == NULL)\n  134      return;\n  135    else{\n  ...\n  137        ((mico_notify_EASYLINK_COMPLETE_function)(temp->function))(nwkpara, temp->arg);\n  138        temp = temp->next;\n  139:     }while(temp!=NULL);\n  140    }\n  141  }\n  ...\n  144  {\n  145    _Notify_list_t *temp =  Notify_list[mico_notify_EASYLINK_GET_EXTRA_DATA];\n  146:   if(temp == NULL)\n  147      return;\n  148    else{\n  ...\n  150        ((mico_notify_EASYLINK_GET_EXTRA_DATA_function)(temp->function))(datalen, data, temp->arg);\n  151        temp = temp->next;\n  152:     }while(temp!=NULL);\n  153    }  \n  154  }\n  ...\n  157  {\n  158    _Notify_list_t *temp =  Notify_list[mico_notify_TCP_CLIENT_CONNECTED];\n  159:   if(temp == NULL)\n  160      return;\n  161    else{\n  ...\n  163        ((mico_notify_TCP_CLIENT_CONNECTED_function)(temp->function))(fd, temp->arg);\n  164        temp = temp->next;\n  165:     }while(temp!=NULL);\n  166    }    \n  167  }\n  ...\n  170  {\n  171    _Notify_list_t *temp =  Notify_list[mico_notify_DNS_RESOLVE_COMPLETED];\n  172:   if(temp == NULL)\n  173      return;\n  174    else{\n  ...\n  176        ((mico_notify_DNS_RESOLVE_COMPLETED_function)(temp->function))(hostname, ip, temp->arg);\n  177        temp = temp->next;\n  178:     }while(temp!=NULL);\n  179    }    \n  180  }\n  ...\n  183  {\n  184    _Notify_list_t *temp =  Notify_list[mico_notify_SYS_WILL_POWER_OFF];\n  185:   if(temp == NULL)\n  186      return;\n  187    else{\n  ...\n  189        ((mico_notify_SYS_WILL_POWER_OFF_function)(temp->function))(temp->arg);\n  190        temp = temp->next;\n  191:     }while(temp!=NULL);\n  192    }    \n  193  }\n  ...\n  196  {\n  197    _Notify_list_t *temp =  Notify_list[mico_notify_WIFI_CONNECT_FAILED];\n  198:   if(temp == NULL)\n  199      return;\n  200    else{\n  ...\n  202        ((mico_notify_WIFI_CONNECT_FAILED_function)(temp->function))(err, temp->arg);\n  203        temp = temp->next;\n  204:     }while(temp!=NULL);\n  205    }    \n  206  }\n  ...\n  209  {\n  210    _Notify_list_t *temp =  Notify_list[mico_notify_WIFI_Fatal_ERROR];\n  211:   if(temp == NULL)\n  212      return;\n  213    else{\n  ...\n  215        ((mico_notify_WIFI_FATAL_ERROR_function)(temp->function))(temp->arg);\n  216        temp = temp->next;\n  217:     }while(temp!=NULL);\n  218    }    \n  219  }\n  ...\n  222  {\n  223    _Notify_list_t *temp =  Notify_list[mico_notify_Stack_Overflow_ERROR];\n  224:   if(temp == NULL)\n  225      return;\n  226    else{\n  ...\n  228        ((mico_notify_STACK_OVERFLOW_ERROR_function)(temp->function))(taskname, temp->arg);\n  229        temp = temp->next;\n  230:     }while(temp!=NULL);\n  231    }    \n  232  }\n  ...\n  240    notify->function = functionAddress;\n  241    notify->arg = arg;\n  242:   notify->next = NULL;\n  243:   if(Notify_list[notify_type] == NULL){\n  244      Notify_list[notify_type] = notify;\n  245:     notify->next = NULL;\n  246    }else{\n  247      if(temp->function == functionAddress)\n  248          return kNoErr;   //Nodify already exist\n  249:     while(temp->next!=NULL){\n  250        temp = temp->next;\n  251        if(temp->function == functionAddress)\n  ...\n  275         break;\n  276      }\n  277:     require_action(temp->next!=NULL, exit, err = kNotFoundErr);\n  278      temp2 = temp;\n  279      temp = temp->next;\n  280:   }while(temp != NULL);\n  281  \n  282  exit:\n\n/Users/William/Develop/MiCO/mico/system/mico_system_para_storage.c:\n  185    uint16_t crc_backup_result, crc_backup_target;\n  186    mico_logic_partition_t *partition; \n  187:   uint8_t *sys_backup_data = NULL;\n  188:   uint8_t *user_backup_data = NULL;\n  189  \n  190    OSStatus err = kNoErr;\n  ...\n  311  \n  312  exit: \n  313:   if( sys_backup_data!= NULL) free( sys_backup_data );\n  314:   if( user_backup_data!= NULL) free( user_backup_data );\n  315    return err;\n  316  }\n\n/Users/William/Develop/MiCO/mico/system/mico_system_power_daemon.c:\n   42  {\n   43    system_log_trace();\n   44:   mico_Context_t* context = NULL;\n   45    \n   46    context = mico_system_context_get( );\n   ..\n   66  {\n   67    system_log_trace();\n   68:   mico_Context_t* context = NULL;\n   69    \n   70    context = mico_system_context_get( );\n   ..\n   82  {\n   83    system_log_trace();\n   84:   mico_Context_t* context = NULL;\n   85    \n   86    context = mico_system_context_get( );\n   ..\n  128      }\n  129    }\n  130:   mico_rtos_delete_thread( NULL );\n  131  }\n  132  \n  ...\n  140    in_context->micoStatus.current_sys_state = eState_Normal;\n  141  \n  142:   mico_rtos_create_thread( NULL, MICO_APPLICATION_PRIORITY, \"Power Daemon\", _sys_state_thread, 800, (void *)in_context ); \n  143    require_noerr(err, exit);\n  144    \n  ...\n  151  {\n  152    OSStatus err = kNoErr;\n  153:   mico_Context_t* context = NULL;\n  154    \n  155    context = mico_system_context_get( );\n\n/Users/William/Develop/MiCO/mico/system/system_factory_test.c:\n  185    network_InitTypeDef_adv_st wNetConfig;\n  186    int testCommandFd, scanFd;\n  187:   uint8_t *buf = NULL;\n  188    int recvLength = -1;\n  189    fd_set readfds;\n  ...\n  223    ring_buffer_init  ( (ring_buffer_t *)&rx_buffer, (uint8_t *)rx_data, 2048 );\n  224    MicoUartInitialize( UART_FOR_APP, &uart_config, (ring_buffer_t *)&rx_buffer );\n  225:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"MFG UART Recv\", uartRecvMfg_thread, 0x300, (void*)inContext );\n  226    \n  227    /* Initialize UDP interface */\n  ...\n  250      FD_SET( testCommandFd, &readfds );\n  251      FD_SET( scanFd, &readfds );\n  252:     select( 1, &readfds, NULL, NULL, &t );\n  253      \n  254      /* Scan and return MAC address */ \n\n/Users/William/Develop/MiCO/mico/system/command_console/mico_cli.c:\n   36  } ;\n   37  \n   38: static struct cli_st *pCli = NULL;\n   39  static uint8_t *cli_rx_data;\n   40  static ring_buffer_t cli_rx_buffer;\n   ..\n   51  /* Find the command 'name' in the cli commands table.\n   52  * If len is 0 then full match will be performed else upto len bytes.\n   53: * Returns: a pointer to the corresponding cli_command struct or NULL.\n   54  */\n   55  static const struct cli_command *lookup_command(char *name, int len)\n   ..\n   59    \n   60    while (i < MAX_COMMANDS && n < pCli->num_commands) {\n   61:     if (pCli->commands[i]->name == NULL) {\n   62        i++;\n   63        continue;\n   ..\n   76    }\n   77    \n   78:   return NULL;\n   79  }\n   80  \n   ..\n   99    int argc = 0;\n  100    int i = 0;\n  101:   const struct cli_command *command = NULL;\n  102    const char *p;\n  103    \n  ...\n  174    * compare commands before first dot.\n  175    */\n  176:   i = ((p = strchr(argv[0], '.')) == NULL) ? 0 :\n  177      (p - argv[0]);\n  178      command = lookup_command(argv[0], i);\n  179:     if (command == NULL)\n  180        return 1;\n  181      \n  ...\n  189  /* Perform basic tab-completion on the input buffer by string-matching the\n  190  * current input line against the cli functions table.  The current input line\n  191: * is assumed to be NULL-terminated. */\n  192  static void tab_complete(char *inbuf, unsigned int *bp)\n  193  {\n  194    int i, n, m;\n  195:   const char *fm = NULL;\n  196    \n  197    cli_printf(\"\\r\\n\");\n  ...\n  200    for (i = 0, n = 0, m = 0; i < MAX_COMMANDS && n < pCli->num_commands;\n  201    i++) {\n  202:     if (pCli->commands[i]->name != NULL) {\n  203        if (!strncmp(inbuf, pCli->commands[i]->name, *bp)) {\n  204          m++;\n  ...\n  237  {\n  238    \n  239:   if (inbuf == NULL) {\n  240      return 0;\n  241    }\n  ...\n  287  static void print_bad_command(char *cmd_string)\n  288  {\n  289:   if (cmd_string != NULL) {\n  290      char *c = cmd_string;\n  291      cli_printf(\"command '\");\n  ...\n  320      msg = pCli->inbuf;\n  321      \n  322:     if (msg != NULL) {\n  323        if (strcmp(msg, EXIT_MSG) == 0)\n  324          break;\n  ...\n  334    cli_printf(\"CLI exited\\r\\n\");\n  335    free(pCli);\n  336:   pCli = NULL;\n  337:   mico_rtos_delete_thread(NULL);\n  338  }\n  339  \n  ...\n  367      }\n  368  \n  369:     cmdinfo.flashaddr = strtoul(argv[5], NULL, 0);\n  370      strncpy(cmdinfo.filename, argv[3], 32);\n  371  \n  372:     cmdinfo.filelen= strtoul(argv[6], NULL, 0);\n  373      if (tftpcmd == 0) { // put\n  374          cmd_printf(\"tftp put to %s, filenmae %s. from %s flash, address 0x%x, len %d\\r\\n\", argv[1], cmdinfo.filename,\n  ...\n  484  \n  485  static const struct cli_command built_ins[] = {\n  486:   {\"help\", NULL, help_command},\n  487:   {\"version\", NULL, get_version},\n  488:   {\"echo\", NULL, echo_cmd_handler},\n  489    {\"exit\", \"CLI exit\", cli_exit_handler}, \n  490    \n  ...\n  552                   sizeof(struct cli_command *)));\n  553        }\n  554:       pCli->commands[pCli->num_commands] = NULL;\n  555        return 0;\n  556      }\n  ...\n  608    \n  609    pCli = (struct cli_st*)malloc(sizeof(struct cli_st));\n  610:   if (pCli == NULL)\n  611      return kNoMemoryErr;\n  612    \n  613    cli_rx_data = (uint8_t*)malloc(INBUF_SIZE);\n  614:   if (cli_rx_data == NULL) {\n  615      free(pCli);\n  616:     pCli = NULL;\n  617      return kNoMemoryErr;\n  618    }\n  ...\n  627                                sizeof(struct cli_command))) {\n  628                                  free(pCli);\n  629:                                 pCli = NULL;\n  630                                  return kGeneralErr;\n  631                                }\n  ...\n  635  #endif\n  636    \n  637:   ret = mico_rtos_create_thread(NULL, MICO_DEFAULT_WORKER_PRIORITY, \"cli\", cli_main, 4096, 0);\n  638    if (ret != kNoErr) {\n  639      cli_printf(\"Error: Failed to create cli thread: %d\\r\\n\",\n  640                 ret);\n  641      free(pCli);\n  642:     pCli = NULL;\n  643      return kGeneralErr;\n  644    }\n\n/Users/William/Develop/MiCO/mico/system/config_server/config_server.c:\n   70  extern OSStatus     ConfigIncommingJsonMessageUAP( const char *input, mico_Context_t * const inContext );\n   71  \n   72: static mico_semaphore_t close_listener_sem = NULL, close_client_sem[ MAX_TCP_CLIENT_PER_SERVER ] = { NULL };\n   73  \n   74  WEAK void config_server_delegate_report( json_object *app_menu, mico_Context_t *in_context )\n   ..\n  100    config_log(\"Start config server\");\n  101  \n  102:   close_listener_sem = NULL;\n  103    for (; i < MAX_TCP_CLIENT_PER_SERVER; i++)\n  104:     close_client_sem[ i ] = NULL;\n  105:   err = mico_rtos_create_thread( NULL, MICO_APPLICATION_PRIORITY, \"Config Server\", localConfiglistener_thread, STACK_SIZE_LOCAL_CONFIG_SERVER_THREAD, (void*)in_context );\n  106    require_noerr(err, exit);\n  107    is_config_server_established = true;\n  ...\n  121  \n  122    for (; i < MAX_TCP_CLIENT_PER_SERVER; i++){\n  123:     if( close_client_sem[ i ] != NULL )\n  124        mico_rtos_set_semaphore( &close_client_sem[ i ] );\n  125    }\n  126    mico_thread_msleep(50);\n  127  \n  128:   if( close_listener_sem != NULL )\n  129      mico_rtos_set_semaphore( &close_listener_sem );\n  130  \n  ...\n  170      FD_SET(localConfiglistener_fd, &readfds);\n  171      FD_SET(close_listener_fd, &readfds);\n  172:     select(1, &readfds, NULL, NULL, NULL);\n  173  \n  174      /* Check close requests */\n  ...\n  185          inet_ntoa(ip_address, addr.s_ip );\n  186          config_log(\"Config Client %s:%d connected, fd: %d\", ip_address, addr.s_port, j);\n  187:         if(kNoErr !=  mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"Config Clients\", localConfig_thread, STACK_SIZE_LOCAL_CONFIG_CLIENT_THREAD, &j) )\n  188            SocketClose(&j);\n  189        }\n  ...\n  192  \n  193  exit:\n  194:     if( close_listener_sem != NULL ){\n  195        mico_delete_event_fd( close_listener_fd );\n  196        mico_rtos_deinit_semaphore( &close_listener_sem );\n  197:       close_listener_sem = NULL;\n  198      };\n  199      config_log(\"Exit: Config listener exit with err = %d\", err);\n  200      SocketClose( &localConfiglistener_fd );\n  201:     mico_rtos_delete_thread(NULL);\n  202      return;\n  203  }\n  ...\n  211    fd_set readfds;\n  212    struct timeval_t t;\n  213:   HTTPHeader_t *httpHeader = NULL;\n  214    int close_client_fd = -1;\n  215    configContext_t httpContext = {0, false, 0};\n  216  \n  217    for( close_sem_index = 0; close_sem_index < MAX_TCP_CLIENT_PER_SERVER; close_sem_index++ ){\n  218:     if( close_client_sem[close_sem_index] == NULL )\n  219        break;\n  220    }\n  221  \n  222    if( close_sem_index == MAX_TCP_CLIENT_PER_SERVER){\n  223:     mico_rtos_delete_thread(NULL);\n  224      return;\n  225    }\n  ...\n  244  \n  245      if(httpHeader->len == 0){\n  246:       require(select(1, &readfds, NULL, NULL, &t) >= 0, exit);\n  247        clientFdIsSet = FD_ISSET(clientFd, &readfds);\n  248      }\n  ...\n  303    SocketClose(&clientFd);\n  304  \n  305:   if( close_client_sem[close_sem_index] != NULL )\n  306    {\n  307      mico_delete_event_fd( close_client_fd );\n  308      mico_rtos_deinit_semaphore( &close_client_sem[close_sem_index] );\n  309:     close_client_sem[close_sem_index] = NULL;\n  310    };\n  311  \n  ...\n  314      free(httpHeader);\n  315    }\n  316:   mico_rtos_delete_thread(NULL);\n  317    return;\n  318  }\n  ...\n  326    mico_logic_partition_t* ota_partition = MicoFlashGetInfo( MICO_PARTITION_OTA_TEMP );\n  327  \n  328:   err = HTTPGetHeaderField( inHeader->buf, inHeader->len, \"Content-Type\", NULL, NULL, &value, &valueSize, NULL );\n  329    if(err == kNoErr && strnicmpx( value, valueSize, kMIMEType_MXCHIP_OTA ) == 0){\n  330      printf(\"%d/\", inPos);\n  ...\n  378    OSStatus err = kUnknownErr;\n  379    const char *  json_str;\n  380:   uint8_t *httpResponse = NULL;\n  381    size_t httpResponseLen = 0;\n  382:   json_object* report = NULL, *config = NULL;\n  383    bool need_reboot = false;\n  384    uint16_t crc;\n  ...\n  387    char name[50];\n  388  \n  389:   json_object *sectors, *sector = NULL;\n  390  \n  391    config_log_trace();\n  ...\n  421  \n  422        /*name cell*/\n  423:       err = config_server_create_string_cell(sector, \"Device Name\",    inContext->flashContentInRam.micoSystemConfig.name,               \"RW\", NULL);\n  424        require_noerr(err, exit);\n  425  \n  ...\n  433  \n  434        /*SSID cell*/\n  435:       err = config_server_create_string_cell(sector, \"Wi-Fi\",        inContext->flashContentInRam.micoSystemConfig.ssid,     \"RW\", NULL);\n  436        require_noerr(err, exit);\n  437        /*PASSWORD cell*/\n  438:       err = config_server_create_string_cell(sector, \"Password\",     inContext->flashContentInRam.micoSystemConfig.user_key, \"RW\", NULL);\n  439        require_noerr(err, exit);\n  440        /*DHCP cell*/\n  ...\n  442        require_noerr(err, exit);\n  443        /*Local cell*/\n  444:       err = config_server_create_string_cell(sector, \"IP address\",  inContext->micoStatus.localIp,   \"RW\", NULL);\n  445        require_noerr(err, exit);\n  446        /*Netmask cell*/\n  447:       err = config_server_create_string_cell(sector, \"Net Mask\",    inContext->micoStatus.netMask,   \"RW\", NULL);\n  448        require_noerr(err, exit);\n  449        /*Gateway cell*/\n  450:       err = config_server_create_string_cell(sector, \"Gateway\",     inContext->micoStatus.gateWay,   \"RW\", NULL);\n  451        require_noerr(err, exit);\n  452        /*DNS server cell*/\n  453:       err = config_server_create_string_cell(sector, \"DNS Server\",  inContext->micoStatus.dnsServer, \"RW\", NULL);\n  454        require_noerr(err, exit);\n  455  \n\n/Users/William/Develop/MiCO/mico/system/easylink/system_easylink.c:\n  261      mico_system_delegate_config_success( source );\n  262      if( source == CONFIG_BY_AIRKISS){\n  263:       err = mico_rtos_create_thread( NULL, MICO_APPLICATION_PRIORITY, \"AIRKISS\", airkiss_broadcast_thread, 0x800, NULL );\n  264        require_noerr_string( err, exit, \"ERROR: Unable to start the EasyLink thread.\" );\n  265      }\n  ...\n  321  \n  322    mico_rtos_deinit_semaphore( &easylink_sem );\n  323:   easylink_sem = NULL;\n  324  \n  325:   mico_rtos_delete_thread( NULL );\n  326    return;\n  327  }\n  ...\n  351    if(err != kNoErr)\n  352      system_log( \"thread exit with err: %d\", err);\n  353:   mico_rtos_delete_thread(NULL);\n  354  }\n  355  \n  ...\n  405  static OSStatus mico_easylink_bonjour_start( WiFi_Interface interface, mico_Context_t * const inContext )\n  406  {\n  407:   char *temp_txt= NULL;\n  408    char *temp_txt2;\n  409    OSStatus err = kNoErr;\n  ...\n  498  static OSStatus mico_easylink_bonjour_update( WiFi_Interface interface, mico_Context_t * const inContext )\n  499  {\n  500:   char *temp_txt= NULL;\n  501    char *temp_txt2;\n  502    OSStatus err = kNoErr;\n\n/Users/William/Develop/MiCO/mico/system/easylink/system_easylink_delegate.c:\n   42    mico_stop_timer(&_Led_EL_timer);\n   43    mico_deinit_timer( &_Led_EL_timer );\n   44:   mico_init_timer(&_Led_EL_timer, SYS_LED_TRIGGER_INTERVAL, _led_EL_Timeout_handler, NULL);\n   45    mico_start_timer(&_Led_EL_timer);\n   46    return;\n   ..\n   63    mico_stop_timer(&_Led_EL_timer);\n   64    mico_deinit_timer( &_Led_EL_timer );\n   65:   mico_init_timer(&_Led_EL_timer, SYS_LED_TRIGGER_INTERVAL_AFTER_EASYLINK, _led_EL_Timeout_handler, NULL);\n   66    mico_start_timer(&_Led_EL_timer);\n   67    return;\n\n/Users/William/Develop/MiCO/mico/system/easylink/system_easylink_wac.c:\n   78      IPStatusTypedef para;\n   79  \n   80:     WACPlatformParameters_t* WAC_Params = NULL;\n   81      WAC_Params = calloc(1, sizeof(WACPlatformParameters_t));\n   82      require(WAC_Params, exit);\n\n/Users/William/Develop/MiCO/mico/system/mdns/mico_mdns.c:\n   87  static OSStatus start_bonjour_service(void);\n   88  \n   89: static mico_mutex_t bonjour_mutex = NULL;\n   90: static mico_semaphore_t update_state_sem = NULL;\n   91  static int update_state_fd = 0;\n   92  static mico_thread_t mfi_bonjour_thread_handler;\n   ..\n  114      switch ( question.question_type ){\n  115      case RR_TYPE_PTR:\n  116:       if ( available_services != NULL ){\n  117          // Check if its a query for all available services  \n  118          if ( dns_compare_name_to_string( &name, SERVICE_QUERY_NAME ) ){\n  ...\n  268  {\n  269    message->header = (dns_message_header_t*) malloc( size );\n  270:   if ( message->header == NULL )\n  271    {\n  272      return 0;\n  ...\n  280  {\n  281    free(message->header);\n  282:   message->header = NULL;\n  283  }\n  284  \n  ...\n  319      *iter->iter++ = *src++;\n  320    } else {\n  321:     /* Add the ending null */\n  322      *iter->iter++ = 0;\n  323    }\n  ...\n  446        break;\n  447    }\n  448:   // Skip the null u8\n  449    ++iter->iter;\n  450  }\n  ...\n  460      return false;\n  461  \n  462:   if( ( service_name == NULL || strcmp( record->service_name, service_name ) == 0 ) && record->interface == interface )\n  463      return true;\n  464  \n  ...\n  494  }\n  495  \n  496: static mico_thread_t _bonjour_announce_handler = NULL;\n  497  \n  498  void _bonjour_send_anounce_thread(void *arg)\n  ...\n  519    \n  520  exit:\n  521:   _bonjour_announce_handler = NULL;\n  522:   mico_rtos_delete_thread( NULL );\n  523    return;\n  524  }\n  ...\n  528    if(record->service_name)  {\n  529      free(record->service_name);\n  530:     record->service_name = NULL;\n  531    }\n  532    if(record->hostname){\n  533      free(record->hostname);\n  534:     record->hostname = NULL;\n  535      }\n  536    if(record->instance_name){\n  537        free(record->instance_name);\n  538:       record->instance_name = NULL;\n  539      }\n  540    if(record->txt_att){\n  541      free(record->txt_att);\n  542:     record->txt_att = NULL;\n  543    }\n  544  \n  ...\n  585    available_services[insert_index].ttl = time_to_live;\n  586    \n  587:   if( _bonjour_announce_handler == NULL)\n  588:     mico_rtos_create_thread( &_bonjour_announce_handler, MICO_APPLICATION_PRIORITY, \"Bonjour Announce\", _bonjour_send_anounce_thread, 0x200, NULL );\n  589  \n  590    mico_rtos_unlock_mutex( &bonjour_mutex );\n  ...\n  611    available_services[insert_index].count_down = 5;\n  612  \n  613:   if( _bonjour_announce_handler == NULL)\n  614:     mico_rtos_create_thread( &_bonjour_announce_handler, MICO_APPLICATION_PRIORITY, \"Bonjour Announce\", _bonjour_send_anounce_thread, 0x200, NULL );\n  615  \n  616    mico_rtos_unlock_mutex( &bonjour_mutex );\n  ...\n  648      goto exit;\n  649  \n  650:   if( _bonjour_announce_handler == NULL)\n  651:     mico_rtos_create_thread( &_bonjour_announce_handler, MICO_APPLICATION_PRIORITY, \"Bonjour Announce\", _bonjour_send_anounce_thread, 0x200, NULL );\n  652  \n  653  exit:\n  ...\n  674      goto exit;\n  675  \n  676:   if( _bonjour_announce_handler == NULL)\n  677:     mico_rtos_create_thread( &_bonjour_announce_handler, MICO_APPLICATION_PRIORITY, \"Bonjour Announce\", _bonjour_send_anounce_thread, 0x200, NULL );\n  678  \n  679  exit:\n  ...\n  741    switch (event) {\n  742    case NOTIFY_STATION_UP:\n  743:     mdns_resume_record( NULL, Station );\n  744      break;\n  745    case NOTIFY_STATION_DOWN:\n  746:     mdns_suspend_record( NULL, Station, false );\n  747      break;\n  748    case NOTIFY_AP_UP:\n  749:     mdns_resume_record( NULL, Soft_AP );\n  750      break;\n  751    case NOTIFY_AP_DOWN:\n  752:     mdns_suspend_record( NULL, Soft_AP, false );\n  753      break;\n  754    default:\n  ...\n  761  {\n  762      UNUSED_PARAMETER(arg);  \n  763:     mdns_suspend_record( NULL, Station, true );\n  764:     mdns_suspend_record( NULL, Soft_AP, true );\n  765  }\n  766  \n  767: uint8_t *buf = NULL;\n  768  \n  769  static OSStatus start_bonjour_service(void)\n  ...\n  773    uint32_t opt;\n  774  \n  775:   if(bonjour_mutex == NULL)\n  776      mico_rtos_init_mutex( &bonjour_mutex );\n  777  \n  778:   if(update_state_sem == NULL)\n  779      mico_rtos_init_semaphore( &update_state_sem, 1 );\n  780  \n  ...\n  796    require_noerr(err, exit);\n  797  \n  798:   err = mico_system_notify_register( mico_notify_WIFI_STATUS_CHANGED, (void *)BonjourNotify_WifiStatusHandler, NULL );\n  799    require_noerr( err, exit );\n  800:   err = mico_system_notify_register( mico_notify_SYS_WILL_POWER_OFF, (void *)BonjourNotify_SYSWillPoerOffHandler, NULL );\n  801    require_noerr( err, exit );\n  802  \n  803:   err = mico_rtos_create_thread(&mfi_bonjour_thread_handler, MICO_APPLICATION_PRIORITY, \"Bonjour\", _bonjour_thread, 0x500, NULL );\n  804    require_noerr(err, exit);\n  805  \n  ...\n  828      FD_SET(mDNS_fd, &readfds);\n  829      FD_SET(update_state_fd, &readfds);\n  830:     select(mDNS_fd + 1, &readfds, NULL, NULL, &t);\n  831  \n  832      if ( FD_ISSET( update_state_fd, &readfds ) ){ \n  ...\n  879    //SocketClose( &mDNS_fd );\n  880    //if(buf) free(buf);\n  881:   //mico_rtos_delete_thread(NULL);\n  882  }\n  883  \n\n/Users/William/Develop/MiCO/mico/system/mdns/mico_mdns.h:\n   63      RR_TYPE_MG     = 8,\n   64      RR_TYPE_MR     = 9,\n   65:     RR_TYPE_NULL   = 10,\n   66      RR_TYPE_WKS    = 11,\n   67      RR_TYPE_PTR    = 12,    // PTR - Domain Name pointer\n\n/Users/William/Develop/MiCO/mico/system/tftp_ota/tftp_ota.c:\n   87      uint16_t crc = 0;\n   88      CRC16_Context contex;\n   89:     mico_Context_t* context = NULL;\n   90      \n   91  #define TMP_BUF_LEN 1024\n   ..\n   97      mico_system_notify_remove_all(mico_notify_WIFI_CONNECT_FAILED);\n   98  	  mico_system_notify_remove_all(mico_notify_EASYLINK_WPS_COMPLETED);\n   99:     mico_system_notify_register( mico_notify_WIFI_STATUS_CHANGED, (void *)FOTA_WifiStatusHandler, NULL );\n  100      micoWlanStopEasyLink();\n  101  	  micoWlanStopEasyLinkPlus();\n  ...\n  104  		\n  105      tmpbuf = (uint8_t*)malloc(TMP_BUF_LEN);\n  106:     if (tmpbuf == NULL) {\n  107          fota_log(\"ERROR!! Can't get enough memory\");\n  108:         mico_ota_finished(OTA_NO_MEM, NULL);\n  109          return;\n  110      }\n  ...\n  135          if (i > 100) {\n  136              fota_log(\"ERROR!! Can't find the OTA AP\");\n  137:             mico_ota_finished(OTA_NO_AP, NULL);\n  138              return;\n  139          }\n  ...\n  152              fota_log(\"ERROR!! Can't get OTA image.\");\n  153              free(tmpbuf);\n  154:             mico_ota_finished(OTA_NO_FILE, NULL);\n  155              return;\n  156          }\n  ...\n  191                   md5_calc[8],md5_calc[9],md5_calc[10],md5_calc[11],\n  192                   md5_calc[12],md5_calc[13],md5_calc[14],md5_calc[15]);\n  193:         mico_ota_finished(OTA_MD5_FAIL, NULL);\n  194          return;\n  195      }\n  ...\n  206      mico_system_context_update( mico_system_context_get( ) );\n  207      \n  208:     mico_ota_finished(OTA_SUCCESS, NULL);\n  209      while(1)\n  210          sleep(100);\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/platform.c:\n  120    //  Initialise EasyLink buttons\n  121    MicoGpioInitialize( (mico_gpio_t)EasyLink_BUTTON, INPUT_PULL_UP );\n  122:   mico_init_timer(&_button_EL_timer, RestoreDefault_TimeOut, _button_EL_Timeout_handler, NULL);\n  123:   MicoGpioEnableIRQ( (mico_gpio_t)EasyLink_BUTTON, IRQ_TRIGGER_BOTH_EDGES, _button_EL_irq_handler, NULL );\n  124    return kNoErr;\n  125  }\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/edma.c:\n   82                       loopSetup->watermark, loopSetup->length, loopSetup->period);\n   83  \n   84:     if(loopSetup->dmaCallBack != NULL)\n   85      {\n   86          EDMA_DRV_InstallCallback(loopSetup->dmaCh, loopSetup->dmaCallBack, loopSetup->dmaCh);\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_dspi_master_driver.h:\n  288   * function which contains the parameters for the bus (the transfer function then calls\n  289   * this function). However, the user has the option to call this function directly especially\n  290:  * to get the calculated baud rate, at which point they may pass in NULL for the device\n  291   * structure in the transfer function (assuming they have called this configure bus function\n  292   * first). This is an example to set up the dspi_device_t structure to call\n  ...\n  331   * @param instance The instance number of the DSPI peripheral.\n  332   * @param device Pointer to the device information structure. This structure contains the settings\n  333:  *  for the SPI bus configuration in this transfer. You may pass NULL for this\n  334   *  parameter, in which case the current bus configuration is used unmodified. The device can be\n  335   *  configured separately by calling the DSPI_DRV_MasterConfigureBus function.\n  336:  * @param sendBuffer The pointer to the data buffer of the data to send. You may pass NULL for this\n  337   *  parameter and  bytes with a value of 0 (zero) is sent.\n  338:  * @param receiveBuffer Pointer to the buffer where the received bytes are stored. If you pass NULL\n  339   *  for this parameter, the received bytes are ignored.\n  340   * @param transferByteCount The number of bytes to send and receive.\n  ...\n  370   * @param instance The instance number of the DSPI peripheral.\n  371   * @param device Pointer to the device information structure. This structure contains the settings\n  372:  *  for the SPI bus configuration in this transfer. You may pass NULL for this\n  373   *  parameter, in which case the current bus configuration is used unmodified. The device can be\n  374   *  configured separately by calling the DSPI_DRV_MasterConfigureBus function.\n  375:  * @param sendBuffer The pointer to the data buffer of the data to send. You may pass NULL for this\n  376   *  parameter, in which case bytes with a value of 0 (zero) are sent.\n  377:  * @param receiveBuffer Pointer to the buffer where the received bytes are stored. If you pass NULL\n  378   *  for this parameter, the received bytes are ignored.\n  379   * @param transferByteCount The number of bytes to send and receive.\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_edma_driver.c:\n   40  \n   41  /*! @brief EDMA global structure to maintain EDMA resource */\n   42: edma_state_t *g_edma = NULL;\n   43  \n   44  /*******************************************************************************\n   ..\n  175  #endif\n  176  \n  177:     g_edma = NULL;\n  178  \n  179      return kStatus_EDMA_Success;\n  ...\n  310  \n  311      EDMA_DRV_LOCK();\n  312:     g_edma->chn[channel] = NULL;\n  313      EDMA_DRV_UNLOCK();\n  314      return kStatus_EDMA_Success;\n  ...\n  378          chn = g_edma->chn[channel];\n  379  \n  380:         if ((chn != NULL) && (EDMA_HAL_GetIntStatusFlag(edmaRegBase, edmaChannel) != 0))\n  381          {\n  382              EDMA_DRV_ClearIntStatus(channel);\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_edma_driver.h:\n  493   * channel complete event or the channel error event.\n  494   *\n  495:  * To un-register the callback function, the user can set the callback function to \"NULL\" and call this\n  496   * function.\n  497   *\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_gpio_driver.h:\n  168   * inputPin[] array and the gpio_output_pin_user_config_t outputPin[] array in the user file.\n  169   * Then, call the GPIO_DRV_Init() function and pass in the two arrays. If the input or output\n  170:  * pins are not needed, pass in a NULL.\n  171   * \n  172   * This is an example to define an input pin array:\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_lptmr_hal.h:\n   98      kStatus_LPTMR_Success                   = 0x0U, /*!< Succeed. */\n   99      kStatus_LPTMR_NotInitlialized           = 0x1U, /*!< LPTMR is not initialized yet. */\n  100:     kStatus_LPTMR_NullArgument              = 0x2U, /*!< Argument is NULL.*/\n  101      kStatus_LPTMR_InvalidPrescalerValue     = 0x3U, /*!< Value 0 is not valid in pulse counter mode. */\n  102      kStatus_LPTMR_InvalidInTimeCounterMode  = 0x4U, /*!< Function can not called in time counter mode. */\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_os_abstraction.h:\n  478   * @note Use the return value to check whether the task is\n  479   *       created successfully. DO NOT check handler. For uC/OS-III,\n  480:  *       handler is not NULL even if the task creation has failed.\n  481   */\n  482  osa_status_t OSA_TaskCreate(task_t          task,\n  ...\n  706   * @param size Amount of bytes to reserve.\n  707   *\n  708:  * @return Pointer to the reserved memory. NULL if memory could not be allocated.\n  709   */\n  710  void * OSA_MemAlloc(size_t size);\n  ...\n  715   * @param size Amount of bytes to reserve.\n  716   *\n  717:  * @return Pointer to the reserved memory. NULL if memory could not be allocated.\n  718   */\n  719  void * OSA_MemAllocZero(size_t size);\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_os_abstraction_bm.h:\n  129   */\n  130  #define OSA_TASK_DEFINE(task, stackSize) \\\n  131:     task_stack_t* task##_stack = NULL;   \\\n  132      task_handler_t task##_task_handler\n  133  \n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_os_abstraction_free_rtos.c:\n   47  \n   48      *pSem = xSemaphoreCreateCounting(0xFF, initValue);\n   49:     if (*pSem==NULL)\n   50      {\n   51          return kStatus_OSA_Error; /* creating semaphore failed */\n   ..\n  174      assert(pMutex);\n  175      *pMutex = xSemaphoreCreateMutex();\n  176:     if (NULL == *pMutex)\n  177      {\n  178          return kStatus_OSA_Error;\n  ...\n  632   * Function Name : OSA_MemAlloc\n  633   * Description   : This function is used to allocate amount of memory in bytes.\n  634:  * Return the pointer to the memory if success, otherwise return NULL;\n  635   *\n  636   *END**************************************************************************/\n  ...\n  645   * Description   : This function is used to allocate amount of memory in bytes\n  646   * and initializes it to 0.\n  647:  * Return the pointer to the memory if success, otherwise return NULL;\n  648   *\n  649   *END**************************************************************************/\n  ...\n  652      void *ptr = pvPortMalloc(size);\n  653  \n  654:     if (ptr==NULL)\n  655      {\n  656:       return NULL; /* failed allocating memory */\n  657      }\n  658      return memset(ptr, 0, size);\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_uart_common.c:\n   36  \n   37  /* Pointer to uart runtime state structure.*/\n   38: void * g_uartStatePtr[HW_UART_INSTANCE_COUNT] = { NULL };\n   39  \n   40  /* Table of base addresses for uart instances. */\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_uart_driver.c:\n  195  \n  196      /* Cleared state pointer. */\n  197:     g_uartStatePtr[instance] = NULL;\n  198  \n  199      /* Gate UART module clock */\n  ...\n  702  \n  703                  /* Invoke callback if have one. */\n  704:                 if (uartState->rxCallback != NULL)\n  705                  {\n  706                      /* The callback will end the receiving early if not return\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/hal/fsl_uart_edma_driver.c:\n  240  \n  241      /* Cleared state pointer. */\n  242:     g_uartStatePtr[instance] = NULL;\n  243  \n  244      /* Gate UART module clock */\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/osa-d/fsl_os_abstraction.h:\n  497   * @note Use the return value to check whether the task is\n  498   *       created successfully. DO NOT check handler. For uC/OS-III,\n  499:  *       handler is not NULL even if the task creation has failed.\n  500   */\n  501  osa_status_t OSA_TaskCreate(task_t          task,\n  ...\n  725   * @param size Amount of bytes to reserve.\n  726   *\n  727:  * @return Pointer to the reserved memory. NULL if memory could not be allocated.\n  728   */\n  729  void * OSA_MemAlloc(size_t size);\n  ...\n  734   * @param size Amount of bytes to reserve.\n  735   *\n  736:  * @return Pointer to the reserved memory. NULL if memory could not be allocated.\n  737   */\n  738  void * OSA_MemAllocZero(size_t size);\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/osa-d/fsl_os_abstraction_bm.h:\n  129   */\n  130  #define OSA_TASK_DEFINE(task, stackSize) \\\n  131:     task_stack_t* task##_stack = NULL;   \\\n  132      task_handler_t task##_task_handler\n  133  \n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/osa-d/fsl_os_abstraction_free_rtos.h:\n  143   */\n  144  #define OSA_TASK_DEFINE(task, stackSize) \\\n  145:     task_stack_t* task##_stack = NULL;   \\\n  146      task_handler_t task##_task_handler\n  147      \n  ...\n  168   */\n  169  #define MSG_QUEUE_DECLARE(name, number, size) \\\n  170:     msg_queue_t *name = NULL\n  171  \n  172  /* @}*/\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/osa-d/fsl_os_abstraction_mqx.h:\n  156   */\n  157  #define OSA_TASK_DEFINE(task, stackSize) \\\n  158:     task_stack_t* task##_stack = NULL;   \\\n  159      task_handler_t task##_task_handler\n  160      \n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/system/hwtimer/fsl_hwtimer.h:\n  215   *\n  216   * @return kHwtimerSuccess or an error code Returned from low level init function.\n  217:  * @return kHwtimerInvalidInput     When input parameter hwtimer is a NULL pointer\n  218:  * @return kHwtimerInvalidPointer   When device structure points to NULL.\n  219   *\n  220   * @warning The initialization function has to be called prior using any other API function.\n  ...\n  234   *\n  235   * @return kHwtimerSuccess or an error code Returned from low level DEINIT function.\n  236:  * @return kHwtimerInvalidInput     When input parameter hwtimer is a NULL pointer\n  237:  * @return kHwtimerInvalidPointer   When device structure points to NULL.\n  238   *\n  239   * @see HWTIMER_SYS_Init\n  ...\n  256   *\n  257   * @return kHwtimerSuccess or an error code Returned from low level SETDIV function.\n  258:  * @return kHwtimerInvalidInput      When input parameter hwtimer is a NULL pointer\n  259:  * @return kHwtimerInvalidPointer    When device structure points to NULL.\n  260   * @return kHwtimerClockManagerError When Clock manager returns error. \n  261   *\n  ...\n  283   *\n  284   * @return kHwtimerSuccess or an error code Returned from low level SETDIV function.\n  285:  * @return kHwtimerInvalidInput      When input parameter hwtimer or his device structure are NULL pointers.\n  286:  * @return kHwtimerInvalidPointer    When low level SETDIV function point to NULL.\n  287   * @return kHwtimerClockManagerError When Clock manager returns error.\n  288   *\n  ...\n  304   *\n  305   * @return frequency    Already set frequency of hwtimer\n  306:  * @return 0            When input parameter hwtimer is NULL pointer or his divider member is zero or clock manager returns error.\n  307   *\n  308   * @see HWTIMER_SYS_SetFreq\n  ...\n  323   *\n  324   * @return period       Already set period of hwtimer.\n  325:  * @return 0            Input parameter hwtimer is NULL pointer or clock manager returns error.\n  326   *\n  327   * @see HWTIMER_SYS_SetFreq\n  ...\n  342   *\n  343   * @return kHwtimerSuccess or an error code Returned from low level START function.\n  344:  * @return kHwtimerInvalidInput      When input parameter hwtimer is a NULL pointer\n  345:  * @return kHwtimerInvalidPointer    When device structure points to NULL.\n  346   *\n  347   * @see HWTIMER_SYS_Init\n  ...\n  359   *\n  360   * @return kHwtimerSuccess or an error code Returned from low level STOP function.\n  361:  * @return kHwtimerInvalidInput      When input parameter hwtimer is a NULL pointer\n  362:  * @return kHwtimerInvalidPointer    When device structure points to NULL.\n  363   *\n  364   * @see HWTIMER_SYS_Init\n  ...\n  376   *\n  377   * @return modulo       resolution of hwtimer.\n  378:  * @return 0            Input parameter hwtimer is NULL pointer.\n  379   *\n  380   * @see HWTIMER_SYS_SetFreq\n  ...\n  397   *\n  398   * @return kHwtimerSuccess or an error code Returned from low level GET_TIME function.\n  399:  * @return kHwtimerInvalidInput   When input parameter hwtimer or input parameter time are NULL pointers.\n  400:  * @return kHwtimerInvalidPointer When device structure points to NULL.\n  401   *\n  402   * @see HWTIMER_SYS_SetFreq\n  ...\n  419   *\n  420   * @return Low 32 bits of 64 bit tick value.\n  421:  * @return 0  When input parameter hwtimer is NULL pointer.\n  422   *\n  423   * @see HWTIMER_SYS_SetFreq\n  ...\n  439   * @param callback_data [in] Data pointer for the function callback_func.\n  440   *\n  441:  * @return kHwtimerInvalidInput When input parameter hwtimer is NULL pointer.\n  442   * @return kHwtimerSuccess      When registration callback succeed.\n  443   *\n  ...\n  457   * @param hwtimer[in] Pointer to hwtimer structure.\n  458   *\n  459:  * @return kHwtimerInvalidInput When input parameter hwtimer is NULL pointer.\n  460   * @return kHwtimerSuccess      When callback block succeed.\n  461   *\n  ...\n  476   * @param hwtimer[in] Pointer to hwtimer structure.\n  477   *\n  478:  * @return kHwtimerInvalidInput When input parameter hwtimer is NULL pointer.\n  479   * @return kHwtimerSuccess      When callback unblock succeed.\n  480   *\n  ...\n  492   * @param hwtimer[in] Pointer to hwtimer structure.\n  493   *\n  494:  * @return kHwtimerInvalidInput When input parameter hwtimer is NULL pointer.\n  495   * @return kHwtimerSuccess      When callback cancel succeed.\n  496   *\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/system/hwtimer/src/fsl_hwtimer.c:\n   62   {\n   63      /* Check input parameters */\n   64:     if ((hwtimer == NULL) || (kDevif == NULL))\n   65      {\n   66          return kHwtimerInvalidInput;\n   67      }\n   68  \n   69:     assert(NULL != kDevif->init);\n   70  \n   71      /* Initialize hwtimer structure */\n   ..\n   74      hwtimer->divider = 0U;\n   75      hwtimer->modulo  = 0U;\n   76:     hwtimer->callbackFunc = NULL;\n   77:     hwtimer->callbackData = NULL;\n   78      hwtimer->callbackPending = 0U;\n   79      hwtimer->callbackBlocked = 0U;\n   ..\n   96  \n   97      /* Check input parameters */\n   98:     if (NULL == hwtimer)\n   99      {\n  100          return kHwtimerInvalidInput;\n  101      }\n  102:     if (NULL == hwtimer->devif)\n  103      {\n  104          return kHwtimerInvalidPointer;\n  105      }\n  106      /* Stop timer if runs */\n  107:     assert(NULL != hwtimer->devif->stop);\n  108      result = hwtimer->devif->stop(hwtimer);\n  109      if (kHwtimerSuccess != result)\n  ...\n  113  \n  114      /* De-initialize timer. */\n  115:     assert(NULL != hwtimer->devif->deinit);\n  116      result = hwtimer->devif->deinit(hwtimer);\n  117      if (kHwtimerSuccess != result)\n  ...\n  120      }\n  121  \n  122:     hwtimer->devif      = NULL;\n  123      hwtimer->ticks      = 0U;\n  124      hwtimer->divider    = 0U;\n  125      hwtimer->modulo     = 0U;\n  126:     hwtimer->callbackFunc = NULL;\n  127:     hwtimer->callbackData = NULL;\n  128      hwtimer->callbackPending = 0U;\n  129      hwtimer->callbackBlocked = 0U;\n  ...\n  145  \n  146      /* Check input parameters */\n  147:     if ((NULL == hwtimer) || (0U == freq))\n  148      {\n  149          return kHwtimerInvalidInput;\n  150      }\n  151:     if (NULL == hwtimer->devif)\n  152      {\n  153          return kHwtimerInvalidPointer;\n  ...\n  168          divider = 1U;\n  169      }\n  170:     assert(NULL != hwtimer->devif->setDiv);\n  171      return hwtimer->devif->setDiv(hwtimer, divider);\n  172  }\n  ...\n  185  \n  186      /* Check input parameters */\n  187:     if ((NULL == hwtimer) || (0U == period))\n  188      {\n  189          return kHwtimerInvalidInput;\n  190      }\n  191:     if (NULL == hwtimer->devif)\n  192      {\n  193          return kHwtimerInvalidPointer;\n  ...\n  213          divider = 0xFFFFFFFFU;\n  214      }\n  215:     assert(NULL != hwtimer->devif->setDiv);\n  216      return hwtimer->devif->setDiv(hwtimer, (uint32_t)divider);\n  217  }\n  ...\n  230  \n  231      /* Check input parameters */\n  232:     if (NULL == hwtimer)\n  233      {\n  234          return 0U;\n  ...\n  263  \n  264      /* Check input parameters */\n  265:     if (NULL == hwtimer)\n  266      {\n  267          return 0U;\n  ...\n  291  {\n  292      /* Check input parameters */\n  293:     if (NULL == hwtimer)\n  294      {\n  295          return kHwtimerInvalidInput;\n  296      }\n  297:     if (NULL == hwtimer->devif)\n  298      {\n  299          return kHwtimerInvalidPointer;\n  300      }\n  301      /* Start timer */\n  302:     assert(NULL != hwtimer->devif->start);\n  303      return hwtimer->devif->start(hwtimer);\n  304  }\n  ...\n  316  \n  317      /* Check input parameters */\n  318:     if (NULL == hwtimer)\n  319      {\n  320          return kHwtimerInvalidInput;\n  321      }\n  322:     if (NULL == hwtimer->devif)\n  323      {\n  324          return kHwtimerInvalidPointer;\n  325      }\n  326  \n  327:     assert(NULL != hwtimer->devif->stop);\n  328      result = hwtimer->devif->stop(hwtimer);\n  329      hwtimer->callbackPending = 0U;\n  ...\n  343  {\n  344      /* Check input parameters */\n  345:     if (NULL == hwtimer)\n  346      {\n  347          return 0U;\n  ...\n  364  {\n  365      /* Check input parameters */\n  366:     if ((NULL == hwtimer) || (NULL == time))\n  367      {\n  368          return kHwtimerInvalidInput;\n  369      }\n  370:     if (NULL == hwtimer->devif)\n  371      {\n  372          return kHwtimerInvalidPointer;\n  373      }\n  374  \n  375:     assert(NULL != hwtimer->devif->getTime);\n  376      return hwtimer->devif->getTime(hwtimer, time);\n  377  }\n  ...\n  390  {\n  391      /* Check input parameters */\n  392:     if (NULL == hwtimer)\n  393      {\n  394          return 0U;\n  ...\n  412  \n  413      /* Check input parameters */\n  414:     if (NULL == hwtimer)\n  415      {\n  416          return kHwtimerInvalidInput;\n  ...\n  419      hwtimerVol = hwtimer;\n  420      /* Volatile used to prevent optimization of following lines. Interrupt may happen meanwhile. */\n  421:     hwtimerVol->callbackFunc = NULL; /* Prevent callback execution with old data */\n  422      hwtimerVol->callbackPending = 0U;\n  423      hwtimerVol->callbackData = callbackData;\n  ...\n  438  {\n  439      /* Check input parameters */\n  440:     if (NULL == hwtimer)\n  441      {\n  442          return kHwtimerInvalidInput;\n  ...\n  463  \n  464      /* Check input parameters */\n  465:     if (NULL == hwtimer)\n  466      {\n  467          return kHwtimerInvalidInput;\n  ...\n  474      {\n  475          callbackFunc = hwtimerVol->callbackFunc;\n  476:         if (NULL != callbackFunc)\n  477          {\n  478              /* Prevent invocation of callback from ISR (callback may not be re-entrant) */\n  479:             hwtimerVol->callbackFunc = NULL;\n  480              callbackFunc(hwtimerVol->callbackData);\n  481              /* Allow invocation of callback from ISR */\n  ...\n  498  {\n  499      /* Check input parameters */\n  500:     if (NULL == hwtimer)\n  501      {\n  502          return kHwtimerInvalidInput;\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/system/hwtimer/src/fsl_hwtimer_pit.c:\n   91  static hwtimer_t *g_hwtimersPit[FSL_FEATURE_PIT_TIMER_COUNT] = {0U};\n   92  static mutex_t g_lock_data; /* Lock used for g_hwtimersPit locking */\n   93: static mutex_t *g_lock = NULL; /* pointer to lock data */\n   94  \n   95  \n   ..\n  102   * @brief Interrupt service routine.\n  103   *\n  104:  * Checks whether callback_func is not NULL,\n  105   * and unless callback is blocked by callback_blocked being non-zero it calls the callback function with callback_data as parameter,\n  106   * otherwise callback_pending is set to non-zero value.\n  ...\n  123          hwtimer_t *hwtimer =  g_hwtimersPit[i];\n  124          /* If hwtimer exist*/\n  125:         if (NULL != hwtimer)\n  126          {\n  127              uint32_t pitChannel =  hwtimer->llContext[0U];\n  ...\n  142                  hwtimer->ticks++;\n  143  \n  144:                 if (NULL != hwtimer->callbackFunc)\n  145                  {\n  146                      if (hwtimer->callbackBlocked)\n  ...\n  197      }\n  198  \n  199:     assert(NULL != hwtimer);\n  200  \n  201      /* We need to store pitId of timer in context struct */\n  ...\n  222      /* Enter critical section to avoid interrupt create locking */\n  223      OSA_EnterCritical(kCriticalDisableInt);\n  224:     if (g_lock == NULL)\n  225      {\n  226          /* Initialize synchronization object */\n  ...\n  287      int i;\n  288  \n  289:     assert(NULL != hwtimer);\n  290  \n  291      pitChannel = hwtimer->llContext[0U];\n  ...\n  302          return kHwtimerLockError;\n  303      }\n  304:     /* Pit can have shared interrupt vectors. We need un-register interrupt only when all hwtimers are de-inited(set to NULL) */\n  305:     g_hwtimersPit[pitChannel] = NULL;\n  306  \n  307      if (kStatus_OSA_Success != OSA_MutexUnlock(g_lock))\n  ...\n  313      for (i = 0U; i < FSL_FEATURE_PIT_TIMER_COUNT; i++)\n  314      {\n  315:         if (NULL != g_hwtimersPit[i])\n  316          {\n  317              break;\n  ...\n  321      if (i == FSL_FEATURE_PIT_TIMER_COUNT)\n  322      {\n  323:         if(kStatus_OSA_Success != OSA_InstallIntHandler(kpitIrqIds[pitChannel], NULL))\n  324          {\n  325              return kHwtimerRegisterHandlerError;\n  ...\n  334          return kHwtimerLockError;\n  335      }\n  336:     g_lock = NULL;\n  337      OSA_ExitCritical(kCriticalDisableInt);\n  338  \n  ...\n  366      uint32_t pitChannel;\n  367      uint32_t baseAddr = g_pitBaseAddr[0];\n  368:     assert(NULL != hwtimer);\n  369      assert(0U != divider);\n  370  \n  ...\n  406      uint32_t pitChannel;\n  407      uint32_t baseAddr = g_pitBaseAddr[0];\n  408:     assert(NULL != hwtimer);\n  409  \n  410      pitChannel = hwtimer->llContext[0U];\n  ...\n  442      uint32_t pitChannel;\n  443      uint32_t baseAddr = g_pitBaseAddr[0];\n  444:     assert(NULL != hwtimer);\n  445  \n  446      pitChannel = hwtimer->llContext[0U];\n  ...\n  480      uint32_t    tempCval;\n  481      uint32_t baseAddr = g_pitBaseAddr[0];\n  482:     assert(NULL != hwtimer);\n  483:     assert(NULL != time);\n  484  \n  485      pitChannel = hwtimer->llContext[0U];\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/system/hwtimer/src/fsl_hwtimer_systick.c:\n   61  };\n   62  \n   63: static hwtimer_t *g_hwtimersSystick = NULL;\n   64  static mutex_t g_lock_data; /* Lock used for g_hwtimersPit locking */\n   65: static mutex_t *g_lock = NULL; /* pointer to lock data */\n   66  \n   67  \n   ..\n   76   *\n   77   * This ISR is used when SysTick counted to 0.\n   78:  * Checks whether callback_func is not NULL,\n   79   * and unless callback is blocked by callback_blocked being non-zero it calls the callback function with callback_data as parameter,\n   80   * otherwise callback_pending is set to non-zero value.\n   ..\n   98      }\n   99  \n  100:     if (NULL != hwtimer)\n  101      {\n  102  \n  ...\n  104          hwtimer->ticks++;\n  105  \n  106:         if (NULL != hwtimer->callbackFunc)\n  107          {\n  108              if (hwtimer->callbackBlocked)\n  ...\n  150  {\n  151  \n  152:     assert(NULL != hwtimer);\n  153      /* We count only with one systick module inside core */\n  154      if ( 1U <= systickId)\n  ...\n  169      /* Enter critical section to avoid interrupt create locking */\n  170      OSA_EnterCritical(kCriticalDisableInt);\n  171:     if (g_lock == NULL)\n  172      {\n  173          /* Initialize synchronization object */\n  ...\n  227  static _hwtimer_error_code_t HWTIMER_SYS_SystickDeinit(hwtimer_t *hwtimer)\n  228  {\n  229:     assert(NULL != hwtimer);\n  230  \n  231:     if (kStatus_OSA_Success != OSA_InstallIntHandler(SysTick_IRQn, NULL))\n  232      {\n  233          return kHwtimerRegisterHandlerError;\n  ...\n  247      }\n  248  \n  249:     g_hwtimersSystick = NULL;\n  250  \n  251      if (kStatus_OSA_Success != OSA_MutexUnlock(g_lock))\n  ...\n  261          return kHwtimerLockError;\n  262      }\n  263:     g_lock = NULL;\n  264      OSA_ExitCritical(kCriticalDisableInt);\n  265  \n  ...\n  291  {\n  292  \n  293:     assert(NULL != hwtimer);\n  294      assert(0U != divider);\n  295  \n  ...\n  336  static _hwtimer_error_code_t HWTIMER_SYS_SystickStart(hwtimer_t *hwtimer)\n  337  {\n  338:     assert(NULL != hwtimer);\n  339  \n  340      /* A write of any value to current value register clears the field to 0, and also clears the SYST_CSR COUNTFLAG bit to 0. */\n  ...\n  367  static _hwtimer_error_code_t HWTIMER_SYS_SystickStop(hwtimer_t *hwtimer)\n  368  {\n  369:     assert(NULL != hwtimer);\n  370  \n  371      /* Disable timer and interrupt */\n  ...\n  400      uint32_t tempVal;\n  401  \n  402:     assert(NULL != hwtimer);\n  403:     assert(NULL != time);\n  404  \n  405      /* Enter critical section to avoid disabling interrupt from pit for very long time */\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/system/power/fsl_power_manager.h:\n  486   * @param callbacksPtr A pointer to an array with references to callback configurations.\n  487   *  These callbacks are statically registered in the Power manager. If there are\n  488:  *  no callbacks to register during Power manager initialization, use NULL value.\n  489   * @param callbacksNumber Number of statically registered callbacks. Size of callbacksPtr\n  490   *  array.\n  ...\n  666            255,\n  667            0,\n  668:           NULL,\n  669:           NULL\n  670          };\n  671  \n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/system/power/src/fsl_power_manager.c:\n  105  {\n  106      /* Check input parameter - at least one power mode configuration is required */\n  107:     if ((powerConfigsPtr == NULL) || (configsNumber == 0U))\n  108      {\n  109          return kPowerManagerError;\n  ...\n  118      gPowerManagerState.configsNumber = configsNumber;\n  119      /* Store references to user-defined callback configurations and increment call-back handle counter */\n  120:     if (callbacksPtr != NULL)\n  121      {\n  122          gPowerManagerState.staticCallbacks = callbacksPtr;\n  ...\n  185      power_manager_dynamic_callback_user_config_t * currentDynamicCallback; /* Pointer to node in linked list of dynamically registered call-backs */\n  186      uint8_t currentStaticCallback = 0U;      /* Index to array of statically registered call-backs */\n  187:     power_manager_dynamic_callback_user_config_t * lastDynamicCallback = NULL; /* Pointer to call-back which will be serviced as last */\n  188      uint8_t lastStaticCallback;         /* Index to call-back which will be serviced as last */\n  189      gPowerManagerState.lastErroneousHandle = 0U; /* Default value of handle of last call-back that returned error */\n  ...\n  229  \n  230      /* From all dynamically registered call-backs... */\n  231:     for (currentDynamicCallback = gPowerManagerState.dynamicCallbacks; currentDynamicCallback != NULL; currentDynamicCallback = currentDynamicCallback->next)\n  232      {\n  233          /* ...notify only those which asked to be called before the power mode change */\n  ...\n  452  \n  453          /* From all dynamically registered call-backs... */\n  454:         for (currentDynamicCallback = gPowerManagerState.dynamicCallbacks; currentDynamicCallback != NULL; currentDynamicCallback = currentDynamicCallback->next)\n  455          {\n  456              /* ...notify only those which asked to be called after the power mode change */\n  ...\n  658      POWER_SYS_LOCK();\n  659      /* Any already registered call-back? */\n  660:     if (gPowerManagerState.dynamicCallbacks != NULL)\n  661      {\n  662          /* Go trough already registered call-backs... */\n  663:         for (currentCallback = gPowerManagerState.dynamicCallbacks; currentCallback != NULL; currentCallback = currentCallback->next)\n  664          {\n  665              /* ...ordered by their priority */\n  ...\n  669                  callbackPtr->next = currentCallback;\n  670                  callbackPtr->prev = currentCallback->prev;\n  671:                 if (currentCallback->prev == NULL)\n  672                  {\n  673                      /* If registered call-back is first in linked list (has highest priority) update the list head reference */\n  ...\n  682              }\n  683              /* Add the call-back to the end of list (has the lowest priority) */\n  684:             if (currentCallback->next == NULL)\n  685              {\n  686                  currentCallback->next = callbackPtr;\n  687:                 callbackPtr->next = NULL;\n  688                  callbackPtr->prev = currentCallback;\n  689              }\n  ...\n  694      {\n  695          gPowerManagerState.dynamicCallbacks = callbackPtr;\n  696:         callbackPtr->next = NULL;\n  697:         callbackPtr->prev = NULL;\n  698      }\n  699      /* Increment call-backs counter */\n  ...\n  732  \n  733      /* Go through all already registered call-backs... */\n  734:     for (currentCallback = gPowerManagerState.dynamicCallbacks; currentCallback != NULL; currentCallback = currentCallback->next)\n  735      {\n  736          /* ...find the referenced one... */\n  ...\n  738          {\n  739              /* ...and remove it from linked list */\n  740:             if (currentCallback->next != NULL)\n  741              {\n  742                  currentCallback->next->prev = currentCallback->prev;\n  743              }\n  744:             if (currentCallback->prev != NULL)\n  745              {\n  746                  currentCallback->prev->next = currentCallback->next;\n  ...\n  758      POWER_SYS_UNLOCK();\n  759      /* Call-back to be removed not found? */\n  760:     if (currentCallback == NULL)\n  761      {\n  762          return kPowerManagerErrorOutOfRange;\n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/utilities/fsl_debug_console.c:\n  216  \n  217  #if ((defined(__GNUC__)) && (!defined(FSL_RTOS_MQX)))\n  218:     setvbuf(stdout, NULL, _IONBF, 0);\n  219:     setvbuf(stdin, NULL, _IONBF, 0);\n  220:     setvbuf(stderr, NULL, _IONBF, 0);\n  221  #endif\n  222  \n\n/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/utilities/mem_tools.c:\n   42      /* Allocate more than enough memory. */\n   43      char *temp = (char *)OSA_MemAlloc(ptrSize + (alignment - 1));\n   44:     if(temp == NULL)\n   45      {\n   46:         return NULL;  /* Return NULL if not enough space for allocation request. */\n   47      }\n   48  \n   ..\n   72      char count;\n   73  \n   74:     if(ptr != NULL)\n   75      {\n   76          char *temp = ptr;\n   ..\n   85          }\n   86          OSA_MemFree(temp);\n   87:         temp = NULL;\n   88      }\n   89  \n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/micokit_ext_mfg.c:\n   36  WEAK void user_key1_clicked_callback(void)\n   37  {\n   38:   if(NULL != mfg_test_state_change_sem){\n   39      if( 0 < mfg_test_module_number){\n   40        mfg_test_module_number = (mfg_test_module_number - 1)%(MFG_TEST_MAX_MODULE_NUM+1);\n   ..\n   57  WEAK void user_key2_clicked_callback(void)\n   58  {\n   59:   if(NULL != mfg_test_state_change_sem){\n   60      mfg_test_module_number = (mfg_test_module_number+1)%(MFG_TEST_MAX_MODULE_NUM+1);\n   61      mico_rtos_set_semaphore(&mfg_test_state_change_sem);  // start next module\n   ..\n   75  #define OLED_MFG_TEST_PREFIX         \"TEST:\"\n   76  \n   77: mico_semaphore_t mfg_test_state_change_sem = NULL;\n   78  volatile int16_t mfg_test_module_number = 0;\n   79  volatile bool scanap_done = false;\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/ambient_light_sensor/apds9930.c:\n   40  {\n   41    OSStatus err = kNoErr;\n   42:   mico_i2c_message_t apds_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n   43  \n   44    uint8_t array[APDS_BUFFER_LEN];\n   ..\n   61  {\n   62    OSStatus err = kNoErr;\n   63:   mico_i2c_message_t apds_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n   64  \n   65    err = MicoI2cBuildRxMessage(&apds_i2c_msg, reg_data, cnt, 3);\n   ..\n   82  {\n   83    OSStatus err = kNoErr;\n   84:   err = APDS9930_I2C_bus_write(0xA0|reg_addr, NULL, 0);\n   85    err = APDS9930_I2C_bus_read(reg_data, 1);\n   86    return err;  \n   ..\n   90  {\n   91    OSStatus err = kNoErr;\n   92:   err = APDS9930_I2C_bus_write(0x80|CLIT_ADDR, NULL, 0);\n   93    return err;\n   94  }\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/key/keys.c:\n   48    \n   49    if ( MicoGpioInputGet( (mico_gpio_t)USER_KEY1 ) == 0 ) {\n   50:     MicoGpioEnableIRQ( (mico_gpio_t)USER_KEY1, IRQ_TRIGGER_RISING_EDGE, _user_key1_irq_handler, NULL );\n   51      _default_key1_start_time = mico_get_time()+1;\n   52      mico_start_timer(&_user_key1_timer);\n   ..\n   57        user_key1_clicked_callback();\n   58      }\n   59:     MicoGpioEnableIRQ( (mico_gpio_t)USER_KEY1, IRQ_TRIGGER_FALLING_EDGE, _user_key1_irq_handler, NULL );\n   60      mico_stop_timer(&_user_key1_timer);\n   61      _default_key1_start_time = 0;\n   ..\n   76    \n   77    if ( MicoGpioInputGet( (mico_gpio_t)USER_KEY2 ) == 0 ) {\n   78:     MicoGpioEnableIRQ( (mico_gpio_t)USER_KEY2, IRQ_TRIGGER_RISING_EDGE, _user_key2_irq_handler, NULL );\n   79      _default_key2_start_time = mico_get_time()+1;\n   80      mico_start_timer(&_user_key2_timer);\n   ..\n   85        user_key2_clicked_callback();\n   86      }\n   87:     MicoGpioEnableIRQ( (mico_gpio_t)USER_KEY2, IRQ_TRIGGER_FALLING_EDGE, _user_key2_irq_handler, NULL );\n   88      mico_stop_timer(&_user_key2_timer);\n   89      _default_key2_start_time = 0;\n   ..\n  101  {\n  102     MicoGpioInitialize( (mico_gpio_t)USER_KEY1, INPUT_PULL_UP );\n  103:    mico_init_timer(&_user_key1_timer, user_key1_long_press_timeout, _user_key1_timeout_handler, NULL);\n  104:    MicoGpioEnableIRQ( (mico_gpio_t)USER_KEY1, IRQ_TRIGGER_FALLING_EDGE, _user_key1_irq_handler, NULL );\n  105  }\n  106  \n  ...\n  108  {\n  109     MicoGpioInitialize( (mico_gpio_t)USER_KEY2, INPUT_PULL_UP );\n  110:    mico_init_timer(&_user_key2_timer, user_key2_long_press_timeout, _user_key2_timeout_handler, NULL);\n  111:    MicoGpioEnableIRQ( (mico_gpio_t)USER_KEY2, IRQ_TRIGGER_FALLING_EDGE, _user_key2_irq_handler, NULL );\n  112  }\n  113  \n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/lcd/oled.c:\n   46  uint8_t spi_tx_buffer = 0;\n   47  //mico_spi_message_segment_t oled_spi_msg = {\n   48: //  &spi_tx_buffer, NULL, 0\n   49  //};\n   50  \n   ..\n   85    platform_spi_config_t config;\n   86    platform_spi_message_segment_t oled_spi_msg =\n   87:             { &dat,            NULL,       (unsigned long) 1 };\n   88  \n   89    config.chip_select = &platform_gpio_pins[micokit_spi_oled.chip_select];\n   ..\n   92    config.bits        = micokit_spi_oled.bits;\n   93    \n   94:   if( platform_spi_drivers[micokit_spi_oled.port].spi_mutex == NULL)\n   95      mico_rtos_init_mutex( &platform_spi_drivers[micokit_spi_oled.port].spi_mutex );\n   96  \n   ..\n  288    config.bits        = micokit_spi_oled.bits;\n  289  \n  290:   if( platform_spi_drivers[micokit_spi_oled.port].spi_mutex == NULL)\n  291      mico_rtos_init_mutex( &platform_spi_drivers[micokit_spi_oled.port].spi_mutex );\n  292  \n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/motion_sensor/BMA2x2/bma2x2.c:\n   81  	communication routine*/\n   82  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n   83: 	if (p_bma2x2 == BMA2x2_NULL) {\n   84  		/* Check the struct p_bma2x2 is empty */\n   85: 		return E_BMA2x2_NULL_PTR;\n   86  		} else {\n   87  			/* Read the data from the register*/\n   ..\n  159  	communication routine*/\n  160  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  161: 	if (p_bma2x2 == BMA2x2_NULL) {\n  162  		/* Check the struct p_bma2x2 is empty */\n  163: 		return E_BMA2x2_NULL_PTR;\n  164  		} else {\n  165  		/* Write the data to the register*/\n  ...\n  192  	communication routine*/\n  193  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  194: 	if (p_bma2x2 == BMA2x2_NULL) {\n  195  		/* Check the struct p_bma2x2 is empty */\n  196: 		return E_BMA2x2_NULL_PTR;\n  197  		} else {\n  198  			/*Read the data from the register*/\n  ...\n  233  	u8	v_data_u8[ARRAY_SIZE_TWO] = {\n  234  	C_BMA2x2_ZERO_U8X, C_BMA2x2_ZERO_U8X};\n  235: 	if (p_bma2x2 == BMA2x2_NULL) {\n  236  		/* Check the struct p_bma2x2 is empty */\n  237: 		return E_BMA2x2_NULL_PTR;\n  238  		} else {\n  239  		switch (V_BMA2x2RESOLUTION_U8) {\n  ...\n  297  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  298  	u8	data = C_BMA2x2_ZERO_U8X;\n  299: 	if (p_bma2x2 == BMA2x2_NULL) {\n  300  		/* Check the struct p_bma2x2 is empty */\n  301: 		return E_BMA2x2_NULL_PTR;\n  302  		} else {\n  303  			/* Read the sensor X data*/\n  ...\n  339  	*/\n  340  	u8 v_data_u8[ARRAY_SIZE_TWO] = {C_BMA2x2_ZERO_U8X, C_BMA2x2_ZERO_U8X};\n  341: 	if (p_bma2x2 == BMA2x2_NULL) {\n  342  		/* Check the struct p_bma2x2 is empty */\n  343: 		return E_BMA2x2_NULL_PTR;\n  344  		} else {\n  345  		switch (V_BMA2x2RESOLUTION_U8) {\n  ...\n  404  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  405  	u8	data = C_BMA2x2_ZERO_U8X;\n  406: 	if (p_bma2x2 == BMA2x2_NULL) {\n  407  		/* Check the struct p_bma2x2 is empty */\n  408: 		return E_BMA2x2_NULL_PTR;\n  409  		} else {\n  410  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n  ...\n  445  	*/\n  446  	u8 v_data_u8[ARRAY_SIZE_TWO] = {C_BMA2x2_ZERO_U8X, C_BMA2x2_ZERO_U8X};\n  447: 	if (p_bma2x2 == BMA2x2_NULL) {\n  448  		/* Check the struct p_bma2x2 is empty */\n  449: 		return E_BMA2x2_NULL_PTR;\n  450  		} else {\n  451  		switch (V_BMA2x2RESOLUTION_U8) {\n  ...\n  510  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  511  	u8	data = C_BMA2x2_ZERO_U8X;\n  512: 	if (p_bma2x2 == BMA2x2_NULL) {\n  513  		/* Check the struct p_bma2x2 is empty */\n  514: 		return E_BMA2x2_NULL_PTR;\n  515  		} else {\n  516  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n  ...\n  557  	C_BMA2x2_ZERO_U8X, C_BMA2x2_ZERO_U8X,\n  558  	C_BMA2x2_ZERO_U8X, C_BMA2x2_ZERO_U8X};\n  559: 	if (p_bma2x2 == BMA2x2_NULL) {\n  560  		/* Check the struct p_bma2x2 is empty */\n  561: 		return E_BMA2x2_NULL_PTR;\n  562  		} else {\n  563  		switch (V_BMA2x2RESOLUTION_U8) {\n  ...\n  664  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  665  	u8	v_data_u8 = C_BMA2x2_ZERO_U8X;\n  666: 	if (p_bma2x2 == BMA2x2_NULL) {\n  667  		/* Check the struct p_bma2x2 is empty */\n  668: 		return E_BMA2x2_NULL_PTR;\n  669  		} else {\n  670  		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n  ...\n  709  	communication routine*/\n  710  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  711: 	if (p_bma2x2 == BMA2x2_NULL) {\n  712  		/* Check the struct p_bma2x2 is empty */\n  713: 		return E_BMA2x2_NULL_PTR;\n  714  		} else {\n  715  			/* Read the interrupt status register 0x0B*/\n  ...\n  741  	communication routine*/\n  742  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  743: 	if (p_bma2x2 == BMA2x2_NULL) {\n  744  		/* Check the struct p_bma2x2 is empty */\n  745: 		return E_BMA2x2_NULL_PTR;\n  746  		} else {\n  747  			/* Read the interrupt status register 0x0C*/\n  ...\n  772  	communication routine*/\n  773  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  774: 	if (p_bma2x2 == BMA2x2_NULL) {\n  775  		/* Check the struct p_bma2x2 is empty */\n  776: 		return E_BMA2x2_NULL_PTR;\n  777  		} else {\n  778  			/* Read the interrupt status register 0x0E*/\n  ...\n  806  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  807  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n  808: 	if (p_bma2x2 == BMA2x2_NULL) {\n  809  		/* Check the struct p_bma2x2 is empty */\n  810: 		return E_BMA2x2_NULL_PTR;\n  811  		} else {\n  812  			/* Read the FIFO frame count*/\n  ...\n  842  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  843  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n  844: 	if (p_bma2x2 == BMA2x2_NULL) {\n  845  		/* Check the struct p_bma2x2 is empty */\n  846: 		return E_BMA2x2_NULL_PTR;\n  847  		} else {\n  848  			/* Read the status of fifo over run*/\n  ...\n  878  	communication routine*/\n  879  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  880: 	if (p_bma2x2 == BMA2x2_NULL) {\n  881  		/* Check the struct p_bma2x2 is empty */\n  882: 		return E_BMA2x2_NULL_PTR;\n  883  		} else {\n  884  			/* Read the interrupt status register 0x09*/\n  ...\n  916  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  917  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n  918: 	if (p_bma2x2 == BMA2x2_NULL) {\n  919  		/* Check the struct p_bma2x2 is empty */\n  920: 		return E_BMA2x2_NULL_PTR;\n  921  		} else {\n  922  		/* Read the range register 0x0F*/\n  ...\n  955  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n  956  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n  957: 	if (p_bma2x2 == BMA2x2_NULL) {\n  958  		/* Check the struct p_bma2x2 is empty */\n  959: 		return E_BMA2x2_NULL_PTR;\n  960  		} else {\n  961  		if ((v_range_u8 == C_BMA2x2_THREE_U8X) ||\n  ...\n 1027  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1028  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 1029: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1030  		/* Check the struct p_bma2x2 is empty */\n 1031: 		return E_BMA2x2_NULL_PTR;\n 1032  		} else {\n 1033  			/* Read the bandwidth register 0x10*/\n ....\n 1072  u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 1073  u8 v_data_bw_u8 = C_BMA2x2_ZERO_U8X;\n 1074: if (p_bma2x2 == BMA2x2_NULL) {\n 1075  		/* Check the struct p_bma2x2 is empty */\n 1076: 		return E_BMA2x2_NULL_PTR;\n 1077  	} else {\n 1078  	/* Check the chip id 0xFB, it support upto 500Hz*/\n ....\n 1227  u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 1228  u8 v_data2_u8 = C_BMA2x2_ZERO_U8X;\n 1229: if (p_bma2x2 == BMA2x2_NULL) {\n 1230  	/* Check the struct p_bma2x2 is empty */\n 1231: 		return E_BMA2x2_NULL_PTR;\n 1232  	} else {\n 1233  		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 1331  	u8 v_data2_u8 = C_BMA2x2_ZERO_U8X;\n 1332  	u8 v_pre_fifo_config_data = C_BMA2x2_ZERO_U8X;\n 1333: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1334  		/* Check the struct p_bma2x2 is empty */\n 1335: 		return E_BMA2x2_NULL_PTR;\n 1336  	} else {\n 1337  		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 1429  {\n 1430  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_SUCCESS;\n 1431: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1432  		/* Check the struct p_bma2x2 is empty */\n 1433: 		return E_BMA2x2_NULL_PTR;\n 1434  	} else {\n 1435  	if (v_power_mode_u8 < C_BMA2x2_SIX_U8X) {\n ....\n 1511  	communication routine*/\n 1512  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1513: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1514  		/* Check the struct p_bma2x2 is empty */\n 1515: 		return E_BMA2x2_NULL_PTR;\n 1516  		} else {\n 1517  			/* read the sleep duration */\n ....\n 1562  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1563  	u8 v_data_sleep_durn_u8 = C_BMA2x2_ZERO_U8X;\n 1564: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1565  		/* Check the struct p_bma2x2 is empty */\n 1566: 		return E_BMA2x2_NULL_PTR;\n 1567  		} else {\n 1568  		if (v_sleep_durn_u8 > C_BMA2x2_FOUR_U8X &&\n ....\n 1669  	communication routine*/\n 1670  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1671: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1672  		/* Check the struct p_bma2x2 is empty */\n 1673: 		return E_BMA2x2_NULL_PTR;\n 1674  		} else {\n 1675  			/*Read the SLEEP TIMER MODE*/\n ....\n 1708  	communication routine*/\n 1709  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1710: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1711  		/* Check the struct p_bma2x2 is empty */\n 1712: 		return E_BMA2x2_NULL_PTR;\n 1713  		} else {\n 1714  		if (v_sleep_timer_u8 < C_BMA2x2_TWO_U8X) {\n ....\n 1751  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1752  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 1753: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1754: 		return  E_BMA2x2_NULL_PTR;\n 1755  		} else {\n 1756  			/* Read the high bandwidth*/\n ....\n 1786  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1787  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 1788: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1789: 		return  E_BMA2x2_NULL_PTR;\n 1790  		}  else {\n 1791  			/* Write the high bandwidth*/\n ....\n 1826  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1827  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 1828: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1829: 		return  E_BMA2x2_NULL_PTR;\n 1830  		} else {\n 1831  			/*Read the shadow dis*/\n ....\n 1863  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1864  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 1865: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1866: 		return  E_BMA2x2_NULL_PTR;\n 1867  		} else {\n 1868  			/* Write the shadow dis*/\n ....\n 1899  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1900  	u8 v_data_u8 = BMA2x2_ENABLE_SOFT_RESET_VALUE;\n 1901: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1902  		/* Check the struct p_bma2x2 is empty */\n 1903: 		return E_BMA2x2_NULL_PTR;\n 1904  		}  else {\n 1905  			/*! To reset the sensor\n ....\n 1933  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 1934  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 1935: 	if (p_bma2x2 == BMA2x2_NULL) {\n 1936: 		return  E_BMA2x2_NULL_PTR;\n 1937  		} else {\n 1938  			/* Write the update image*/\n ....\n 1999  	communication routine*/\n 2000  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2001: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2002  		/* Check the struct p_bma2x2 is empty */\n 2003: 		return E_BMA2x2_NULL_PTR;\n 2004  		} else {\n 2005  		switch (v_intr_type_u8) {\n ....\n 2159  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 2160  	u8 v_data2_u8 = C_BMA2x2_ZERO_U8X;\n 2161: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2162  		/* Check the struct p_bma2x2 is empty */\n 2163: 		return E_BMA2x2_NULL_PTR;\n 2164  		} else {\n 2165  		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 2271  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2272  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 2273: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2274  		/* Check the struct p_bma2x2 is empty */\n 2275: 		return E_BMA2x2_NULL_PTR;\n 2276  		} else {\n 2277  			/* Read fifo full interrupt */\n ....\n 2311  	communication routine*/\n 2312  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2313: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2314  		/* Check the struct p_bma2x2 is empty */\n 2315: 		return E_BMA2x2_NULL_PTR;\n 2316  		} else {\n 2317  		if (v_fifo_full_u8 < C_BMA2x2_TWO_U8X) {\n ....\n 2362  	communication routine*/\n 2363  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2364: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2365  		/* Check the struct p_bma2x2 is empty */\n 2366: 		return E_BMA2x2_NULL_PTR;\n 2367  		} else {\n 2368  			/* Read the fifo water mark*/\n ....\n 2404  	communication routine*/\n 2405  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2406: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2407  		/* Check the struct p_bma2x2 is empty */\n 2408: 		return E_BMA2x2_NULL_PTR;\n 2409  		} else {\n 2410  		if (v_fifo_wm_u8 < C_BMA2x2_TWO_U8X) {\n ....\n 2461  	communication routine*/\n 2462  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2463: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2464  		/* Check the struct p_bma2x2 is empty */\n 2465: 		return E_BMA2x2_NULL_PTR;\n 2466  		} else {\n 2467  		/* Read the slow no motion interrupt */\n ....\n 2541  	communication routine*/\n 2542  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2543: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2544  		/* Check the struct p_bma2x2 is empty */\n 2545: 		return E_BMA2x2_NULL_PTR;\n 2546  		} else {\n 2547  		/* Write the slow no motion interrupt*/\n ....\n 2646  	communication routine*/\n 2647  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2648: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2649  		/* Check the struct p_bma2x2 is empty */\n 2650: 		return E_BMA2x2_NULL_PTR;\n 2651  		} else {\n 2652  		switch (v_channel_u8) {\n ....\n 2711  	communication routine*/\n 2712  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2713: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2714  		/* Check the struct p_bma2x2 is empty */\n 2715: 		return E_BMA2x2_NULL_PTR;\n 2716  		} else {\n 2717  		switch (v_channel_u8) {\n ....\n 2781  	communication routine*/\n 2782  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2783: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2784  		/* Check the struct p_bma2x2 is empty */\n 2785: 		return E_BMA2x2_NULL_PTR;\n 2786  		} else {\n 2787  		switch (v_channel_u8) {\n ....\n 2843  	communication routine*/\n 2844  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2845: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2846  		/* Check the struct p_bma2x2 is empty */\n 2847: 		return E_BMA2x2_NULL_PTR;\n 2848  		} else {\n 2849  		/* write the high_g interrupt*/\n ....\n 2917  	communication routine*/\n 2918  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2919: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2920  		/* Check the struct p_bma2x2 is empty */\n 2921: 		return E_BMA2x2_NULL_PTR;\n 2922  		} else {\n 2923  		/* Read the slope value */\n ....\n 2981  	communication routine*/\n 2982  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 2983: 	if (p_bma2x2 == BMA2x2_NULL) {\n 2984  		/* Check the struct p_bma2x2 is empty */\n 2985: 		return E_BMA2x2_NULL_PTR;\n 2986  		} else {\n 2987  		switch (v_channel_u8) {\n ....\n 3056  	communication routine*/\n 3057  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3058: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3059  		/* Check the struct p_bma2x2 is empty */\n 3060: 		return E_BMA2x2_NULL_PTR;\n 3061  		} else {\n 3062  		/* Read the slow no motion interrupt */\n ....\n 3121  	communication routine*/\n 3122  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3123: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3124  		/* Check the struct p_bma2x2 is empty */\n 3125: 		return E_BMA2x2_NULL_PTR;\n 3126  		} else {\n 3127  		switch (v_channel_u8) {\n ....\n 3197  	communication routine*/\n 3198  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3199: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3200  		/* Check the struct p_bma2x2 is empty */\n 3201: 		return E_BMA2x2_NULL_PTR;\n 3202  		} else {\n 3203  		/* read the double tap*/\n ....\n 3261  	communication routine*/\n 3262  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3263: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3264  		/* Check the struct p_bma2x2 is empty */\n 3265: 		return E_BMA2x2_NULL_PTR;\n 3266  		} else {\n 3267  		switch (v_channel_u8) {\n ....\n 3336  	communication routine*/\n 3337  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3338: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3339  		/* Check the struct p_bma2x2 is empty */\n 3340: 		return E_BMA2x2_NULL_PTR;\n 3341  		} else {\n 3342  		switch (v_channel_u8) {\n ....\n 3399  	communication routine*/\n 3400  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3401: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3402  		/* Check the struct p_bma2x2 is empty */\n 3403: 		return E_BMA2x2_NULL_PTR;\n 3404  		} else {\n 3405  		switch (v_channel_u8) {\n ....\n 3472  	communication routine*/\n 3473  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3474: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3475  		/* Check the struct p_bma2x2 is empty */\n 3476: 		return E_BMA2x2_NULL_PTR;\n 3477  		} else {\n 3478  		switch (v_channel_u8) {\n ....\n 3534  	communication routine*/\n 3535  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3536: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3537  		/* Check the struct p_bma2x2 is empty */\n 3538: 		return E_BMA2x2_NULL_PTR;\n 3539  		} else {\n 3540  		switch (v_channel_u8) {\n ....\n 3608  	communication routine*/\n 3609  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3610: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3611  		/* Check the struct p_bma2x2 is empty */\n 3612: 		return E_BMA2x2_NULL_PTR;\n 3613  		} else {\n 3614  		switch (v_channel_u8) {\n ....\n 3672  	communication routine*/\n 3673  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3674: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3675  		/* Check the struct p_bma2x2 is empty */\n 3676: 		return E_BMA2x2_NULL_PTR;\n 3677  		} else {\n 3678  		switch (v_channel_u8) {\n ....\n 3745  	communication routine*/\n 3746  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3747: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3748  		/* Check the struct p_bma2x2 is empty */\n 3749: 		return E_BMA2x2_NULL_PTR;\n 3750  		} else {\n 3751  		switch (v_channel_u8) {\n ....\n 3808  	communication routine*/\n 3809  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3810: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3811  		/* Check the struct p_bma2x2 is empty */\n 3812: 		return E_BMA2x2_NULL_PTR;\n 3813  		} else {\n 3814  		switch (v_channel_u8) {\n ....\n 3871  	communication routine*/\n 3872  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3873: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3874  		/* Check the struct p_bma2x2 is empty */\n 3875: 		return E_BMA2x2_NULL_PTR;\n 3876  		} else {\n 3877  			/* read the fifo watermark interrupt */\n ....\n 3909  	communication routine*/\n 3910  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3911: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3912  		/* Check the struct p_bma2x2 is empty */\n 3913: 		return E_BMA2x2_NULL_PTR;\n 3914  		} else {\n 3915  		if (v_intr1_fifo_wm_u8 < C_BMA2x2_TWO_U8X) {\n ....\n 3956  	communication routine*/\n 3957  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3958: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3959  		/* Check the struct p_bma2x2 is empty */\n 3960: 		return E_BMA2x2_NULL_PTR;\n 3961  		} else {\n 3962  			/* read the fifo watermark interrupt2*/\n ....\n 3994  	communication routine*/\n 3995  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 3996: 	if (p_bma2x2 == BMA2x2_NULL) {\n 3997  		/* Check the struct p_bma2x2 is empty */\n 3998: 		return E_BMA2x2_NULL_PTR;\n 3999  		} else {\n 4000  		if (v_intr2_fifo_wm_u8 < C_BMA2x2_TWO_U8X) {\n ....\n 4043  	communication routine*/\n 4044  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4045: 	if (p_bma2x2 == BMA2x2_NULL) {\n 4046  		/* Check the struct p_bma2x2 is empty */\n 4047: 		return E_BMA2x2_NULL_PTR;\n 4048  		} else {\n 4049  			/* read the fifo full interrupt1*/\n ....\n 4083  	communication routine*/\n 4084  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4085: 	if (p_bma2x2 == BMA2x2_NULL) {\n 4086  		/* Check the struct p_bma2x2 is empty */\n 4087: 		return E_BMA2x2_NULL_PTR;\n 4088  		} else {\n 4089  		if (v_intr1_fifo_full_u8 < C_BMA2x2_TWO_U8X) {\n ....\n 4133  	communication routine*/\n 4134  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4135: 	if (p_bma2x2 == BMA2x2_NULL) {\n 4136  		/* Check the struct p_bma2x2 is empty */\n 4137: 		return E_BMA2x2_NULL_PTR;\n 4138  		} else {\n 4139  			/* read the fifo full interrupt2*/\n ....\n 4174  	communication routine*/\n 4175  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4176: 	if (p_bma2x2 == BMA2x2_NULL) {\n 4177  		/* Check the struct p_bma2x2 is empty */\n 4178: 		return E_BMA2x2_NULL_PTR;\n 4179  		} else {\n 4180  		if (v_intr2_fifo_full_u8 < C_BMA2x2_TWO_U8X) {\n ....\n 4234  	communication routine*/\n 4235  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4236: 	if (p_bma2x2 == BMA2x2_NULL) {\n 4237: 		return  E_BMA2x2_NULL_PTR;\n 4238  		} else {\n 4239  		/* read the source interrupt register */\n ....\n 4330  	communication routine*/\n 4331  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4332: 		if (p_bma2x2 == BMA2x2_NULL) {\n 4333: 			return  E_BMA2x2_NULL_PTR;\n 4334  		} else {\n 4335  		switch (v_channel_u8) {\n ....\n 4454  		communication routine*/\n 4455  		BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4456: 		if (p_bma2x2 == BMA2x2_NULL) {\n 4457: 			return  E_BMA2x2_NULL_PTR;\n 4458  		} else {\n 4459  		switch (v_channel_u8) {\n ....\n 4515  		communication routine*/\n 4516  		BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4517: 		if (p_bma2x2 == BMA2x2_NULL) {\n 4518: 			return  E_BMA2x2_NULL_PTR;\n 4519  		}  else {\n 4520  		switch (v_channel_u8) {\n ....\n 4585  		communication routine*/\n 4586  		BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4587: 		if (p_bma2x2 == BMA2x2_NULL) {\n 4588: 			return  E_BMA2x2_NULL_PTR;\n 4589  		} else {\n 4590  		switch (v_channel_u8) {\n ....\n 4645  		communication routine*/\n 4646  		BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4647: 		if (p_bma2x2 == BMA2x2_NULL) {\n 4648: 			return  E_BMA2x2_NULL_PTR;\n 4649  		} else {\n 4650  		switch (v_channel_u8) {\n ....\n 4708  	communication routine*/\n 4709  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4710: 	if (p_bma2x2 == BMA2x2_NULL) {\n 4711  		/* Check the struct p_bma2x2 is empty */\n 4712: 		return E_BMA2x2_NULL_PTR;\n 4713  		} else {\n 4714  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 4761  	communication routine*/\n 4762  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4763: 	if (p_bma2x2 == BMA2x2_NULL) {\n 4764  		/* Check the struct p_bma2x2 is empty */\n 4765: 		return E_BMA2x2_NULL_PTR;\n 4766  		} else {\n 4767  			/* read the latch duration */\n ....\n 4813  BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4814  u8 v_latch_durn_u8 = C_BMA2x2_ZERO_U8X;\n 4815: if (p_bma2x2 == BMA2x2_NULL)  {\n 4816  		/* Check the struct p_bma2x2 is empty */\n 4817: 		return E_BMA2x2_NULL_PTR;\n 4818  		} else  {\n 4819  		if (v_latch_intr_u8 < C_BMA2x2_SIXTEEN_U8X) {\n ....\n 4963  	communication routine*/\n 4964  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 4965: 	if (p_bma2x2 == BMA2x2_NULL) {\n 4966  		/* Check the struct p_bma2x2 is empty */\n 4967: 		return E_BMA2x2_NULL_PTR;\n 4968  		} else {\n 4969  		/* write the duration data */\n ....\n 5053  	communication routine*/\n 5054  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5055: 	if (p_bma2x2 == BMA2x2_NULL)  {\n 5056  		/* Check the struct p_bma2x2 is empty */\n 5057: 		return E_BMA2x2_NULL_PTR;\n 5058  		}  else  {\n 5059  		/* write duration data */\n ....\n 5174  	communication routine*/\n 5175  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5176: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5177  		/* Check the struct p_bma2x2 is empty */\n 5178: 		return E_BMA2x2_NULL_PTR;\n 5179  		} else {\n 5180  		switch (v_channel_u8) {\n ....\n 5285  	communication routine*/\n 5286  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5287: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5288  		/* Check the struct p_bma2x2 is empty */\n 5289: 		return E_BMA2x2_NULL_PTR;\n 5290  		} else {\n 5291  		switch (v_channel_u8) {\n ....\n 5366  	communication routine*/\n 5367  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5368: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5369  		/* Check the struct p_bma2x2 is empty */\n 5370: 		return E_BMA2x2_NULL_PTR;\n 5371  		} else {\n 5372  		switch (v_channel_u8) {\n ....\n 5434  	communication routine*/\n 5435  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5436: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5437  		/* Check the struct p_bma2x2 is empty */\n 5438: 		return E_BMA2x2_NULL_PTR;\n 5439  		} else {\n 5440  		switch (v_channel_u8) {\n ....\n 5494  	communication routine*/\n 5495  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5496: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5497  		/* Check the struct p_bma2x2 is empty */\n 5498: 		return E_BMA2x2_NULL_PTR;\n 5499  		} else {\n 5500  			/* read the low-g mode*/\n ....\n 5531  	communication routine*/\n 5532  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5533: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5534  		/* Check the struct p_bma2x2 is empty */\n 5535: 		return E_BMA2x2_NULL_PTR;\n 5536  		} else {\n 5537  			/* write the low-g mode*/\n ....\n 5580  	communication routine*/\n 5581  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5582: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5583  		/* Check the struct p_bma2x2 is empty */\n 5584: 		return E_BMA2x2_NULL_PTR;\n 5585  		} else {\n 5586  			/* read the tap duration*/\n ....\n 5624  	communication routine*/\n 5625  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5626: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5627  		/* Check the struct p_bma2x2 is empty */\n 5628: 		return E_BMA2x2_NULL_PTR;\n 5629  		} else {\n 5630  			/* write the tap duration */\n ....\n 5666  	communication routine*/\n 5667  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5668: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5669  		/* Check the struct p_bma2x2 is empty */\n 5670: 		return E_BMA2x2_NULL_PTR;\n 5671  		} else {\n 5672  			/* read tap shock value */\n ....\n 5705  	communication routine*/\n 5706  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5707: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5708  		/* Check the struct p_bma2x2 is empty */\n 5709: 		return E_BMA2x2_NULL_PTR;\n 5710  		} else {\n 5711  			/* write tap shock value*/\n ....\n 5747  	communication routine*/\n 5748  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5749: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5750  		/* Check the struct p_bma2x2 is empty */\n 5751: 		return E_BMA2x2_NULL_PTR;\n 5752  		} else {\n 5753  			/* read the tap quiet value*/\n ....\n 5785  	communication routine*/\n 5786  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5787: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5788  		/* Check the struct p_bma2x2 is empty */\n 5789: 		return E_BMA2x2_NULL_PTR;\n 5790  		} else {\n 5791  			/* write the tap quiet value*/\n ....\n 5831  	communication routine*/\n 5832  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5833: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5834  		/* Check the struct p_bma2x2 is empty */\n 5835: 		return E_BMA2x2_NULL_PTR;\n 5836  		} else {\n 5837  			/* read the tap threshold*/\n ....\n 5873  	communication routine*/\n 5874  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5875: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5876  		/* Check the struct p_bma2x2 is empty */\n 5877: 		return E_BMA2x2_NULL_PTR;\n 5878  		} else {\n 5879  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 5915  	communication routine*/\n 5916  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5917: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5918  		/* Check the struct p_bma2x2 is empty */\n 5919: 		return E_BMA2x2_NULL_PTR;\n 5920  		} else {\n 5921  			/* read tap samples */\n ....\n 5955  	communication routine*/\n 5956  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 5957: 	if (p_bma2x2 == BMA2x2_NULL) {\n 5958  		/* Check the struct p_bma2x2 is empty */\n 5959: 		return E_BMA2x2_NULL_PTR;\n 5960  		} else {\n 5961  			/* write tap samples */\n ....\n 5999  	communication routine*/\n 6000  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6001: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6002  		/* Check the struct p_bma2x2 is empty */\n 6003: 		return E_BMA2x2_NULL_PTR;\n 6004  		} else {\n 6005  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(\n ....\n 6039  	communication routine*/\n 6040  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6041: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6042  		/* Check the struct p_bma2x2 is empty */\n 6043: 		return E_BMA2x2_NULL_PTR;\n 6044  		} else {\n 6045  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 6088  	communication routine*/\n 6089  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6090: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6091  		/* Check the struct p_bma2x2 is empty */\n 6092: 		return E_BMA2x2_NULL_PTR;\n 6093  		} else {\n 6094  			/* Read the orient block data */\n ....\n 6134  	communication routine*/\n 6135  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6136: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6137  		/* Check the struct p_bma2x2 is empty */\n 6138: 		return E_BMA2x2_NULL_PTR;\n 6139  		} else {\n 6140  			/* write the orient block data */\n ....\n 6172  	communication routine*/\n 6173  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6174: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6175  		/* Check the struct p_bma2x2 is empty */\n 6176: 		return E_BMA2x2_NULL_PTR;\n 6177  		} else {\n 6178  			/* read the orient hysteresis data*/\n ....\n 6207  	communication routine*/\n 6208  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6209: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6210  		/* Check the struct p_bma2x2 is empty */\n 6211: 		return E_BMA2x2_NULL_PTR;\n 6212  		} else {\n 6213  			/* write the orient hysteresis data */\n ....\n 6255  	communication routine*/\n 6256  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6257: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6258  		/* Check the struct p_bma2x2 is empty */\n 6259: 		return E_BMA2x2_NULL_PTR;\n 6260  		} else {\n 6261  		switch (v_channel_u8) {\n ....\n 6316  	communication routine*/\n 6317  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6318: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6319  		/* Check the struct p_bma2x2 is empty */\n 6320: 		return E_BMA2x2_NULL_PTR;\n 6321  		} else {\n 6322  		switch (v_channel_u8) {\n ....\n 6375  	communication routine*/\n 6376  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6377: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6378  		/* Check the struct p_bma2x2 is empty */\n 6379: 		return E_BMA2x2_NULL_PTR;\n 6380  		} else {\n 6381  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 6413  	communication routine*/\n 6414  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6415: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6416  		/* Check the struct p_bma2x2 is empty */\n 6417: 		return E_BMA2x2_NULL_PTR;\n 6418  		} else {\n 6419  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 6454  	communication routine*/\n 6455  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6456: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6457  		/* Check the struct p_bma2x2 is empty */\n 6458: 		return E_BMA2x2_NULL_PTR;\n 6459  		} else {\n 6460  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 6490  	communication routine*/\n 6491  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6492: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6493  		/* Check the struct p_bma2x2 is empty */\n 6494: 		return E_BMA2x2_NULL_PTR;\n 6495  		} else {\n 6496  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(\n ....\n 6535  	communication routine*/\n 6536  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6537: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6538  		/* Check the struct p_bma2x2 is empty */\n 6539: 		return E_BMA2x2_NULL_PTR;\n 6540  		} else {\n 6541  			/* read the flat hold time */\n ....\n 6578  	communication routine*/\n 6579  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6580: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6581  		/* Check the struct p_bma2x2 is empty */\n 6582: 		return E_BMA2x2_NULL_PTR;\n 6583  		} else {\n 6584  			/* write the flat hold time */\n ....\n 6620  	communication routine*/\n 6621  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6622: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6623  		/* Check the struct p_bma2x2 is empty */\n 6624: 		return E_BMA2x2_NULL_PTR;\n 6625  		} else {\n 6626  			/* read the fifo water mark trigger */\n ....\n 6658  	communication routine*/\n 6659  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6660: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6661  		/* Check the struct p_bma2x2 is empty */\n 6662: 		return E_BMA2x2_NULL_PTR;\n 6663  		} else {\n 6664  		if (fifo_wml_trig < C_BMA2x2_THIRTYTWO_U8X) {\n ....\n 6709  	communication routine*/\n 6710  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6711: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6712  		/* Check the struct p_bma2x2 is empty */\n 6713: 		return E_BMA2x2_NULL_PTR;\n 6714  		} else {\n 6715  			/* read the self test axis*/\n ....\n 6751  	communication routine*/\n 6752  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6753: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6754  		/* Check the struct p_bma2x2 is empty */\n 6755: 		return E_BMA2x2_NULL_PTR;\n 6756  		} else {\n 6757  		if (v_selftest_axis_u8 < C_BMA2x2_FOUR_U8X) {\n ....\n 6799  	communication routine*/\n 6800  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6801: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6802  		/* Check the struct p_bma2x2 is empty */\n 6803: 		return E_BMA2x2_NULL_PTR;\n 6804  		} else {\n 6805  			/* read self test sign */\n ....\n 6839  	communication routine*/\n 6840  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6841: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6842  		/* Check the struct p_bma2x2 is empty */\n 6843: 		return E_BMA2x2_NULL_PTR;\n 6844  		} else {\n 6845  		if (v_selftest_sign_u8 < C_BMA2x2_TWO_U8X) {\n ....\n 6885  	communication routine*/\n 6886  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6887: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6888: 		return  E_BMA2x2_NULL_PTR;\n 6889  	} else {\n 6890  		/* read the nvm program mode*/\n ....\n 6921  	communication routine*/\n 6922  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6923: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6924  		/* Check the struct p_bma2x2 is empty */\n 6925: 		return E_BMA2x2_NULL_PTR;\n 6926  	} else {\n 6927  		/* write the nvm program mode*/\n ....\n 6965  	communication routine*/\n 6966  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 6967: 	if (p_bma2x2 == BMA2x2_NULL) {\n 6968  		/* Check the struct p_bma2x2 is empty */\n 6969: 		return E_BMA2x2_NULL_PTR;\n 6970  	} else {\n 6971  		/* set the nvm program trigger */\n ....\n 7008  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7009  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 7010: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7011  		/* Check the struct p_bma2x2 is empty */\n 7012: 		return E_BMA2x2_NULL_PTR;\n 7013  	} else {\n 7014  		/* read the nvm program ready*/\n ....\n 7047  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7048  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 7049: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7050  		/* Check the struct p_bma2x2 is empty */\n 7051: 		return E_BMA2x2_NULL_PTR;\n 7052  	} else {\n 7053  		/* write the nvm program ready*/\n ....\n 7086  	communication routine*/\n 7087  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7088: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7089  		/* Check the struct p_bma2x2 is empty */\n 7090: 		return E_BMA2x2_NULL_PTR;\n 7091  		} else {\n 7092  			/* read the spi status*/\n ....\n 7126  	communication routine*/\n 7127  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7128: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7129  		/* Check the struct p_bma2x2 is empty */\n 7130: 		return E_BMA2x2_NULL_PTR;\n 7131  		} else {\n 7132  			/* write the spi status*/\n ....\n 7182  	communication routine*/\n 7183  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7184: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7185  		/* Check the struct p_bma2x2 is empty */\n 7186: 		return E_BMA2x2_NULL_PTR;\n 7187  		} else {\n 7188  		switch (v_channel_u8) {\n ....\n 7248  	communication routine*/\n 7249  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7250: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7251  		/* Check the struct p_bma2x2 is empty */\n 7252: 		return E_BMA2x2_NULL_PTR;\n 7253  		} else {\n 7254  		switch (v_channel_u8) {\n ....\n 7322  	communication routine*/\n 7323  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7324: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7325  		/* Check the struct p_bma2x2 is empty */\n 7326: 		return E_BMA2x2_NULL_PTR;\n 7327  		} else {\n 7328  		switch (v_channel_u8) {\n ....\n 7397  	communication routine*/\n 7398  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7399: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7400  		/* Check the struct p_bma2x2 is empty */\n 7401: 		return E_BMA2x2_NULL_PTR;\n 7402  		} else {\n 7403  		switch (v_channel_u8) {\n ....\n 7475  	communication routine*/\n 7476  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7477: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7478  		/* Check the struct p_bma2x2 is empty */\n 7479: 		return E_BMA2x2_NULL_PTR;\n 7480  		} else {\n 7481  		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 7512  	communication routine*/\n 7513  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7514: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7515  		/* Check the struct p_bma2x2 is empty */\n 7516: 		return E_BMA2x2_NULL_PTR;\n 7517  		} else {\n 7518  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 7552  	communication routine*/\n 7553  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7554: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7555  		/* Check the struct p_bma2x2 is empty */\n 7556: 		return E_BMA2x2_NULL_PTR;\n 7557  		} else {\n 7558  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n ....\n 7615  	communication routine*/\n 7616  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7617: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7618  		/* Check the struct p_bma2x2 is empty */\n 7619: 		return E_BMA2x2_NULL_PTR;\n 7620  		} else {\n 7621  		switch (v_channel_u8) {\n ....\n 7708  	communication routine*/\n 7709  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7710: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7711  		/* Check the struct p_bma2x2 is empty */\n 7712: 		return E_BMA2x2_NULL_PTR;\n 7713  		} else {\n 7714  		switch (v_channel_u8) {\n ....\n 7804  	communication routine*/\n 7805  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7806: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7807  		/* Check the struct p_bma2x2 is empty */\n 7808: 		return E_BMA2x2_NULL_PTR;\n 7809  		} else {\n 7810  		switch (v_channel_u8) {\n ....\n 7866  	communication routine*/\n 7867  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7868: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7869  		/* Check the struct p_bma2x2 is empty */\n 7870: 		return E_BMA2x2_NULL_PTR;\n 7871  		} else {\n 7872  		switch (v_channel_u8) {\n ....\n 7923  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7924  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 7925: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7926  		/* Check the struct p_bma2x2 is empty */\n 7927: 		return E_BMA2x2_NULL_PTR;\n 7928  		} else {\n 7929  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(\n ....\n 7964  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 7965  	u8 v_config_data_u8 = C_BMA2x2_ZERO_U8X;\n 7966: 	if (p_bma2x2 == BMA2x2_NULL) {\n 7967  		/* Check the struct p_bma2x2 is empty */\n 7968: 		return E_BMA2x2_NULL_PTR;\n 7969  		} else {\n 7970  		if (v_fifo_mode_u8 < C_BMA2x2_FOUR_U8X) {\n ....\n 8018  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 8019  	u8 v_data_u8 = C_BMA2x2_ZERO_U8X;\n 8020: 	if (p_bma2x2 == BMA2x2_NULL) {\n 8021  		/* Check the struct p_bma2x2 is empty */\n 8022: 		return E_BMA2x2_NULL_PTR;\n 8023  		} else {\n 8024  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(\n ....\n 8060  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 8061  	u8 v_config_data_u8 = C_BMA2x2_ZERO_U8X;\n 8062: 	if (p_bma2x2 == BMA2x2_NULL) {\n 8063  		/* Check the struct p_bma2x2 is empty */\n 8064: 		return E_BMA2x2_NULL_PTR;\n 8065  		} else {\n 8066  		if (v_fifo_data_select_u8 < C_BMA2x2_FOUR_U8X) {\n ....\n 8110  	communication routine*/\n 8111  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 8112: 	if (p_bma2x2 == BMA2x2_NULL) {\n 8113  		/* Check the struct p_bma2x2 is empty */\n 8114: 		return E_BMA2x2_NULL_PTR;\n 8115  		} else {\n 8116  			/*GET FIFO DATA OUTPUT REGISTER*/\n ....\n 8145  	communication routine*/\n 8146  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 8147: 	if (p_bma2x2 == BMA2x2_NULL) {\n 8148  		/* Check the struct p_bma2x2 is empty */\n 8149: 		return E_BMA2x2_NULL_PTR;\n 8150  		} else {\n 8151  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(\n ....\n 8183  	C_BMA2x2_ZERO_U8X, C_BMA2x2_ZERO_U8X,\n 8184  	C_BMA2x2_ZERO_U8X};\n 8185: 	if (p_bma2x2 == BMA2x2_NULL) {\n 8186  		/* Check the struct p_bma2x2 is empty */\n 8187: 		return E_BMA2x2_NULL_PTR;\n 8188  		} else {\n 8189  		switch (V_BMA2x2RESOLUTION_U8) {\n ....\n 8293  	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = BMA2x2_ERROR;\n 8294  	u8	v_data_u8 = C_BMA2x2_ZERO_U8X;\n 8295: 	if (p_bma2x2 == BMA2x2_NULL) {\n 8296  		/* Check the struct p_bma2x2 is empty */\n 8297: 		return E_BMA2x2_NULL_PTR;\n 8298  		} else {\n 8299  			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/motion_sensor/BMA2x2/bma2x2.h:\n  442  /**************************************************************/\n  443  #define E_OUT_OF_RANGE          ((s8)-2)\n  444: #define E_BMA2x2_NULL_PTR       ((s8)-127)\n  445: #define BMA2x2_NULL             ((u8)0)\n  446  #define BMA2x2_ERROR					((s8)-1)\n  447  #define	BMA2x2_SUCCESS					((u8)0)\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/motion_sensor/BMA2x2/bma2x2_user.c:\n  307  s8 BMA2x2_I2C_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)\n  308  {\n  309:         mico_i2c_message_t bma2x2_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n  310  	s32 iError = 0;\n  311  	u8 array[I2C_BUFFER_LEN];\n  ...\n  348  s8 BMA2x2_I2C_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)\n  349  {\n  350:         mico_i2c_message_t bma2x2_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n  351  	s32 iError = 0;\n  352  	u8 array[I2C_BUFFER_LEN] = {0};\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/motion_sensor/BMG160/bmg160.c:\n  116  	u8 v_data_u8[BMG160_X_DATA_SIZE] = {\n  117  	BMG160_INIT_VALUE, BMG160_INIT_VALUE};\n  118: 	/* check the p_bmg160 struct pointer is NULL*/\n  119: 	if (p_bmg160 == BMG160_NULL) {\n  120: 		return  E_BMG160_NULL_PTR;\n  121  		} else {\n  122  		/* read the gyro x data */\n  ...\n  158  	u8 v_data_u8[BMG160_Y_DATA_SIZE] = {\n  159  	BMG160_INIT_VALUE, BMG160_INIT_VALUE};\n  160: 	/* check the p_bmg160 struct pointer is NULL*/\n  161: 	if (p_bmg160 == BMG160_NULL) {\n  162: 		return  E_BMG160_NULL_PTR;\n  163  		} else {\n  164  		/* read the gyro  y data*/\n  ...\n  199  	u8 v_data_u8[BMG160_Z_DATA_SIZE] = {\n  200  	BMG160_INIT_VALUE, BMG160_INIT_VALUE};\n  201: 	/* check the p_bmg160 struct pointer is NULL*/\n  202: 	if (p_bmg160 == BMG160_NULL) {\n  203: 		return  E_BMG160_NULL_PTR;\n  204  		} else {\n  205  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n  ...\n  246  	BMG160_INIT_VALUE, BMG160_INIT_VALUE,\n  247  	BMG160_INIT_VALUE, BMG160_INIT_VALUE};\n  248: 	/* check the p_bmg160 struct pointer is NULL*/\n  249: 	if (p_bmg160 == BMG160_NULL) {\n  250: 		return  E_BMG160_NULL_PTR;\n  251  		} else {\n  252  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n  ...\n  318  	BMG160_INIT_VALUE, BMG160_INIT_VALUE,\n  319  	BMG160_INIT_VALUE, BMG160_INIT_VALUE};\n  320: 	/* check the p_bmg160 struct pointer is NULL*/\n  321: 	if (p_bmg160 == BMG160_NULL) {\n  322: 		return  E_BMG160_NULL_PTR;\n  323  		} else {\n  324  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n  ...\n  381  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  382  	u8 v_data_u8  = BMG160_INIT_VALUE;\n  383: 	/* check the p_bmg160 struct pointer is NULL*/\n  384: 	if (p_bmg160 == BMG160_NULL) {\n  385: 		return  E_BMG160_NULL_PTR;\n  386  		} else {\n  387  		/* read temperature data*/\n  ...\n  415  	/* variable used to return the bus communication status*/\n  416  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  417: 	/* check the p_bmg160 struct pointer is NULL*/\n  418: 	if (p_bmg160 == BMG160_NULL) {\n  419: 		return  E_BMG160_NULL_PTR;\n  420  		} else {\n  421  		comres = p_bmg160->BMG160_BUS_READ_FUNC\n  ...\n  446  	/* variable used to return the bus communication status*/\n  447  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  448: 	/* check the p_bmg160 struct pointer is NULL*/\n  449: 	if (p_bmg160 == BMG160_NULL) {\n  450: 		return  E_BMG160_NULL_PTR;\n  451  		} else {\n  452  		comres = p_bmg160->BMG160_BURST_READ_FUNC(p_bmg160->dev_addr,\n  ...\n  477  	/* variable used to return the bus communication status*/\n  478  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  479: 	/* check the p_bmg160 struct pointer is NULL*/\n  480: 	if (p_bmg160 == BMG160_NULL) {\n  481: 		return  E_BMG160_NULL_PTR;\n  482  		} else {\n  483  		comres = p_bmg160->BMG160_BUS_WRITE_FUNC\n  ...\n  509  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  510  	u8 v_data_u8  = BMG160_INIT_VALUE;\n  511: 	/* check the p_bmg160 struct pointer is NULL*/\n  512: 	if (p_bmg160 == BMG160_NULL) {\n  513: 		return  E_BMG160_NULL_PTR;\n  514  		} else {\n  515  		/* read the interrupt status any motion and high rate*/\n  ...\n  549  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  550  	u8 v_data_u8  = BMG160_INIT_VALUE;\n  551: 	/* check the p_bmg160 struct pointer is NULL*/\n  552: 	if (p_bmg160 == BMG160_NULL) {\n  553: 		return  E_BMG160_NULL_PTR;\n  554  		} else {\n  555  		/* read the interrupt status*/\n  ...\n  590  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  591  	u8 v_data_u8  = BMG160_INIT_VALUE;\n  592: 	/* check the p_bmg160 struct pointer is NULL*/\n  593: 	if (p_bmg160 == BMG160_NULL) {\n  594: 		return  E_BMG160_NULL_PTR;\n  595  		} else {\n  596  		/* read the interrupt status */\n  ...\n  633  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  634  	u8 v_data_u8  = BMG160_INIT_VALUE;\n  635: 	/* check the p_bmg160 struct pointer is NULL*/\n  636: 	if (p_bmg160 == BMG160_NULL) {\n  637: 		return  E_BMG160_NULL_PTR;\n  638  		} else {\n  639  		/* read the interrupt status */\n  ...\n  675  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  676  	u8 v_data_u8  = BMG160_INIT_VALUE;\n  677: 	/* check the p_bmg160 struct pointer is NULL*/\n  678: 	if (p_bmg160 == BMG160_NULL) {\n  679: 		return  E_BMG160_NULL_PTR;\n  680  		} else {\n  681  		/* read the gyro range */\n  ...\n  717  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  718  	u8 v_data_u8  = BMG160_INIT_VALUE;\n  719: 	/* check the p_bmg160 struct pointer is NULL*/\n  720: 	if (p_bmg160 == BMG160_NULL) {\n  721: 		return  E_BMG160_NULL_PTR;\n  722  		} else {\n  723  		if (v_range_u8 < BMG160_BIT_LENGTH_RANGE) {\n  ...\n  772  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  773  	u8 v_data_u8  = BMG160_INIT_VALUE;\n  774: 	/* check the p_bmg160 struct pointer is NULL*/\n  775: 	if (p_bmg160 == BMG160_NULL) {\n  776: 		return  E_BMG160_NULL_PTR;\n  777  		} else {\n  778  		/* read gyro bandwidth*/\n  ...\n  819  	u8 v_mode_u8r  = BMG160_INIT_VALUE;\n  820  	u8 v_auto_sleep_dur = BMG160_INIT_VALUE;\n  821: 	/* check the p_bmg160 struct pointer is NULL*/\n  822: 	if (p_bmg160 == BMG160_NULL) {\n  823: 		return  E_BMG160_NULL_PTR;\n  824  		} else {\n  825  		if (v_bw_u8 < BMG160_BIT_LENGTH_BW) {\n  ...\n  878  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  879  	u8 v_data_u8 = BMG160_INIT_VALUE;\n  880: 	/* check the p_bmg160 struct pointer is NULL*/\n  881: 	if (p_bmg160 == BMG160_NULL) {\n  882: 		return  E_BMG160_NULL_PTR;\n  883  		} else {\n  884  		/* READ PMU TRIGGER*/\n  ...\n  919  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  920  	u8 v_data_u8 = BMG160_INIT_VALUE;\n  921: 	/* check the p_bmg160 struct pointer is NULL*/\n  922: 	if (p_bmg160 == BMG160_NULL) {\n  923: 		return  E_BMG160_NULL_PTR;\n  924  		} else {\n  925  		/* WRITE PMU TRIGGER*/\n  ...\n  960  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  961  	u8 v_data_u8  = BMG160_INIT_VALUE;\n  962: 	/* check the p_bmg160 struct pointer is NULL*/\n  963: 	if (p_bmg160 == BMG160_NULL) {\n  964: 		return  E_BMG160_NULL_PTR;\n  965  		} else {\n  966  		/* read high bandwidth*/\n  ...\n  998  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n  999  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1000: 	/* check the p_bmg160 struct pointer is NULL*/\n 1001: 	if (p_bmg160 == BMG160_NULL) {\n 1002: 		return  E_BMG160_NULL_PTR;\n 1003  		} else {\n 1004  		if (v_high_bw_u8 < BMG160_BIT_LENGTH_HIGH_BW) {\n ....\n 1045  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1046  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1047: 	/* check the p_bmg160 struct pointer is NULL*/\n 1048: 	if (p_bmg160 == BMG160_NULL) {\n 1049: 		return  E_BMG160_NULL_PTR;\n 1050  		} else {\n 1051  		/* read shadow dis*/\n ....\n 1083  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1084  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1085: 	/* check the p_bmg160 struct pointer is NULL*/\n 1086: 	if (p_bmg160 == BMG160_NULL) {\n 1087: 		return  E_BMG160_NULL_PTR;\n 1088  		} else {\n 1089  		if (v_shadow_dis_u8 < BMG160_BIT_LENGTH_SHADOW_DIS) {\n ....\n 1126  \n 1127  	v_soft_rst_u8 = BMG160_SOFT_RESET;\n 1128: 	/* check the p_bmg160 struct pointer is NULL*/\n 1129: 	if (p_bmg160 == BMG160_NULL) {\n 1130: 		return  E_BMG160_NULL_PTR;\n 1131  		} else {\n 1132  		/* write soft reset*/\n ....\n 1162  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1163  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1164: 	/* check the p_bmg160 struct pointer is NULL*/\n 1165: 	if (p_bmg160 == BMG160_NULL) {\n 1166: 		return  E_BMG160_NULL_PTR;\n 1167  		} else {\n 1168  		/* read the data enable interrupt */\n ....\n 1200  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1201  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1202: 	/* check the p_bmg160 struct pointer is NULL*/\n 1203: 	if (p_bmg160 == BMG160_NULL) {\n 1204: 		return  E_BMG160_NULL_PTR;\n 1205  		} else {\n 1206  		/* write the data enable interrupt*/\n ....\n 1243  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1244  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1245: 	/* check the p_bmg160 struct pointer is NULL*/\n 1246: 	if (p_bmg160 == BMG160_NULL) {\n 1247: 		return  E_BMG160_NULL_PTR;\n 1248  		} else {\n 1249  		/* read the fifo enable */\n ....\n 1281  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1282  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1283: 	/* check the p_bmg160 struct pointer is NULL*/\n 1284: 	if (p_bmg160 == BMG160_NULL) {\n 1285: 		return  E_BMG160_NULL_PTR;\n 1286  		} else {\n 1287  		if (v_fifo_enable_u8 < BMG160_BIT_LENGTH_FIFO) {\n ....\n 1329  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1330  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1331: 	/* check the p_bmg160 struct pointer is NULL*/\n 1332: 	if (p_bmg160 == BMG160_NULL) {\n 1333: 		return  E_BMG160_NULL_PTR;\n 1334  		} else {\n 1335  		/* read auto offset*/\n ....\n 1367  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1368  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1369: 	/* check the p_bmg160 struct pointer is NULL*/\n 1370: 	if (p_bmg160 == BMG160_NULL) {\n 1371: 		return  E_BMG160_NULL_PTR;\n 1372  		} else {\n 1373  		/* write auto offset */\n ....\n 1415  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1416  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1417: 	/* check the p_bmg160 struct pointer is NULL*/\n 1418: 	if (p_bmg160 == BMG160_NULL) {\n 1419: 		return  E_BMG160_NULL_PTR;\n 1420  		} else {\n 1421  		switch (v_param_u8) {\n ....\n 1476  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1477  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1478: 	/* check the p_bmg160 struct pointer is NULL*/\n 1479: 	if (p_bmg160 == BMG160_NULL) {\n 1480: 		return  E_BMG160_NULL_PTR;\n 1481  		} else {\n 1482  		switch (v_param_u8) {\n ....\n 1547  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1548  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1549: 	/* check the p_bmg160 struct pointer is NULL*/\n 1550: 	if (p_bmg160 == BMG160_NULL) {\n 1551: 		return  E_BMG160_NULL_PTR;\n 1552  		} else {\n 1553  		switch (v_param_u8) {\n ....\n 1608  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1609  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1610: 	/* check the p_bmg160 struct pointer is NULL*/\n 1611: 	if (p_bmg160 == BMG160_NULL) {\n 1612: 		return  E_BMG160_NULL_PTR;\n 1613  		} else {\n 1614  		switch (v_param_u8) {\n ....\n 1670  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1671  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1672: 	/* check the p_bmg160 struct pointer is NULL*/\n 1673: 	if (p_bmg160 == BMG160_NULL) {\n 1674: 		return  E_BMG160_NULL_PTR;\n 1675  		} else {\n 1676  		/* read high_rate enable */\n ....\n 1709  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1710  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1711: 	/* check the p_bmg160 struct pointer is NULL*/\n 1712: 	if (p_bmg160 == BMG160_NULL) {\n 1713: 		return  E_BMG160_NULL_PTR;\n 1714  		} else {\n 1715  		/* write high_rate enable */\n ....\n 1751  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1752  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1753: 	/* check the p_bmg160 struct pointer is NULL*/\n 1754: 	if (p_bmg160 == BMG160_NULL) {\n 1755: 		return  E_BMG160_NULL_PTR;\n 1756  		} else {\n 1757  		/* read any motion interrupt*/\n ....\n 1790  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1791  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1792: 	/* check the p_bmg160 struct pointer is NULL*/\n 1793: 	if (p_bmg160 == BMG160_NULL) {\n 1794: 		return  E_BMG160_NULL_PTR;\n 1795  		} else {\n 1796  		/* write any motion interrupt */\n ....\n 1837  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1838  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1839: 	/* check the p_bmg160 struct pointer is NULL*/\n 1840: 	if (p_bmg160 == BMG160_NULL) {\n 1841: 		return  E_BMG160_NULL_PTR;\n 1842  		} else {\n 1843  		switch (v_axis_u8) {\n ....\n 1897  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1898  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1899: 	/* check the p_bmg160 struct pointer is NULL*/\n 1900: 	if (p_bmg160 == BMG160_NULL) {\n 1901: 		return  E_BMG160_NULL_PTR;\n 1902  		}   else {\n 1903  			switch (v_axis_u8) {\n ....\n 1965  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 1966  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 1967: 	/* check the p_bmg160 struct pointer is NULL*/\n 1968: 	if (p_bmg160 == BMG160_NULL) {\n 1969: 		return  E_BMG160_NULL_PTR;\n 1970  		} else {\n 1971  		switch (v_axis_u8) {\n ....\n 2025  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2026  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2027: 	/* check the p_bmg160 struct pointer is NULL*/\n 2028: 	if (p_bmg160 == BMG160_NULL) {\n 2029: 		return  E_BMG160_NULL_PTR;\n 2030  		} else {\n 2031  		switch (v_axis_u8) {\n ....\n 2093  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2094  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2095: 	/* check the p_bmg160 struct pointer is NULL*/\n 2096: 	if (p_bmg160 == BMG160_NULL) {\n 2097: 		return  E_BMG160_NULL_PTR;\n 2098  		} else {\n 2099  		switch (v_axis_u8) {\n ....\n 2153  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2154  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2155: 	/* check the p_bmg160 struct pointer is NULL*/\n 2156: 	if (p_bmg160 == BMG160_NULL) {\n 2157: 		return  E_BMG160_NULL_PTR;\n 2158  		} else {\n 2159  		switch (v_axis_u8) {\n ....\n 2215  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2216  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2217: 	/* check the p_bmg160 struct pointer is NULL*/\n 2218: 	if (p_bmg160 == BMG160_NULL) {\n 2219: 		return  E_BMG160_NULL_PTR;\n 2220  		} else {\n 2221  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n ....\n 2252  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2253  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2254: 	/* check the p_bmg160 struct pointer is NULL*/\n 2255: 	if (p_bmg160 == BMG160_NULL) {\n 2256: 		return  E_BMG160_NULL_PTR;\n 2257  		} else {\n 2258  		/* read fifo interrupt */\n ....\n 2297  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2298  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2299: 	/* check the p_bmg160 struct pointer is NULL*/\n 2300: 	if (p_bmg160 == BMG160_NULL) {\n 2301: 		return  E_BMG160_NULL_PTR;\n 2302  		} else {\n 2303  		switch (v_axis_u8) {\n ....\n 2360  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2361  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2362: 	/* check the p_bmg160 struct pointer is NULL*/\n 2363: 	if (p_bmg160 == BMG160_NULL) {\n 2364: 		return  E_BMG160_NULL_PTR;\n 2365  		} else {\n 2366  		/* read high rate interrupt*/\n ....\n 2399  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2400  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2401: 	/* check the p_bmg160 struct pointer is NULL*/\n 2402: 	if (p_bmg160 == BMG160_NULL) {\n 2403: 		return  E_BMG160_NULL_PTR;\n 2404  		} else {\n 2405  		/* write high rate interrupt */\n ....\n 2442  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2443  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2444: 	/* check the p_bmg160 struct pointer is NULL*/\n 2445: 	if (p_bmg160 == BMG160_NULL) {\n 2446: 		return  E_BMG160_NULL_PTR;\n 2447  		} else {\n 2448  		/* read any motion interrupt */\n ....\n 2481  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2482  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2483: 	/* check the p_bmg160 struct pointer is NULL*/\n 2484: 	if (p_bmg160 == BMG160_NULL) {\n 2485: 		return  E_BMG160_NULL_PTR;\n 2486  		} else {\n 2487  		/* write any motion interrupt */\n ....\n 2529  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2530  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2531: 	/* check the p_bmg160 struct pointer is NULL*/\n 2532: 	if (p_bmg160 == BMG160_NULL) {\n 2533: 		return  E_BMG160_NULL_PTR;\n 2534  		} else {\n 2535  		switch (v_param_u8) {\n ....\n 2590  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2591  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2592: 	/* check the p_bmg160 struct pointer is NULL*/\n 2593: 	if (p_bmg160 == BMG160_NULL) {\n 2594: 		return  E_BMG160_NULL_PTR;\n 2595  		} else {\n 2596  		switch (v_param_u8) {\n ....\n 2660  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2661  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 2662: 	/* check the p_bmg160 struct pointer is NULL*/\n 2663: 	if (p_bmg160 == BMG160_NULL) {\n 2664: 		return  E_BMG160_NULL_PTR;\n 2665  		} else {\n 2666  		switch (v_param_u8) {\n ....\n 2720  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2721  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2722: 	/* check the p_bmg160 struct pointer is NULL*/\n 2723: 	if (p_bmg160 == BMG160_NULL) {\n 2724: 		return  E_BMG160_NULL_PTR;\n 2725  		} else {\n 2726  		switch (v_param_u8) {\n ....\n 2782  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2783  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2784: 	/* check the p_bmg160 struct pointer is NULL*/\n 2785: 	if (p_bmg160 == BMG160_NULL) {\n 2786: 		return  E_BMG160_NULL_PTR;\n 2787  		} else {\n 2788  		/* read any motion threshold */\n ....\n 2818  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2819  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2820: 	/* check the p_bmg160 struct pointer is NULL*/\n 2821: 	if (p_bmg160 == BMG160_NULL) {\n 2822: 		return  E_BMG160_NULL_PTR;\n 2823  		} else {\n 2824  		/* write any motion threshold*/\n ....\n 2859  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2860  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2861: 	/* check the p_bmg160 struct pointer is NULL*/\n 2862: 	if (p_bmg160 == BMG160_NULL) {\n 2863: 		return  E_BMG160_NULL_PTR;\n 2864  		} else {\n 2865  		/* read awake duration*/\n ....\n 2897  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2898  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2899: 	/* check the p_bmg160 struct pointer is NULL*/\n 2900: 	if (p_bmg160 == BMG160_NULL) {\n 2901: 		return  E_BMG160_NULL_PTR;\n 2902  		} else {\n 2903  		/* write awake duration*/\n ....\n 2939  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2940  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2941: 	/* check the p_bmg160 struct pointer is NULL*/\n 2942: 	if (p_bmg160 == BMG160_NULL) {\n 2943: 		return  E_BMG160_NULL_PTR;\n 2944  		} else {\n 2945  		/* read any motion awake samples*/\n ....\n 2978  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 2979  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 2980: 	/* check the p_bmg160 struct pointer is NULL*/\n 2981: 	if (p_bmg160 == BMG160_NULL) {\n 2982: 		return  E_BMG160_NULL_PTR;\n 2983  		} else {\n 2984  		/* write awake duration samples*/\n ....\n 3028  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3029  	u8 v_data1_u8  = BMG160_INIT_VALUE;\n 3030: 	/* check the p_bmg160 struct pointer is NULL*/\n 3031: 	if (p_bmg160 == BMG160_NULL) {\n 3032: 		return  E_BMG160_NULL_PTR;\n 3033  		} else {\n 3034  		switch (v_channel_u8) {\n ....\n 3097  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3098  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3099: 	/* check the p_bmg160 struct pointer is NULL*/\n 3100: 	if (p_bmg160 == BMG160_NULL) {\n 3101: 		return  E_BMG160_NULL_PTR;\n 3102  		} else {\n 3103  		switch (v_channel_u8) {\n ....\n 3173  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3174  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3175: 	/* check the p_bmg160 struct pointer is NULL*/\n 3176: 	if (p_bmg160 == BMG160_NULL) {\n 3177: 		return  E_BMG160_NULL_PTR;\n 3178  		} else {\n 3179  		/* read fifo water mark enable */\n ....\n 3210  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3211  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3212: 	/* check the p_bmg160 struct pointer is NULL*/\n 3213: 	if (p_bmg160 == BMG160_NULL) {\n 3214: 		return  E_BMG160_NULL_PTR;\n 3215  		} else {\n 3216  		/* write fifo water mark enable*/\n ....\n 3254  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3255  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3256: 	/* check the p_bmg160 struct pointer is NULL*/\n 3257: 	if (p_bmg160 == BMG160_NULL) {\n 3258: 		return  E_BMG160_NULL_PTR;\n 3259  		} else {\n 3260  		/* write reset interrupt */\n ....\n 3293  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3294  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3295: 	/* check the p_bmg160 struct pointer is NULL*/\n 3296: 	if (p_bmg160 == BMG160_NULL) {\n 3297: 		return  E_BMG160_NULL_PTR;\n 3298  		} else {\n 3299  		/* write reset offset */\n ....\n 3335  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3336  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3337: 	/* check the p_bmg160 struct pointer is NULL*/\n 3338: 	if (p_bmg160 == BMG160_NULL) {\n 3339: 		return  E_BMG160_NULL_PTR;\n 3340  		} else {\n 3341  		/* read the latch status*/\n ....\n 3374  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3375  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3376: 	/* check the p_bmg160 struct pointer is NULL*/\n 3377: 	if (p_bmg160 == BMG160_NULL) {\n 3378: 		return  E_BMG160_NULL_PTR;\n 3379  		} else {\n 3380  		/* write the latch status */\n ....\n 3428  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3429  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3430: 	/* check the p_bmg160 struct pointer is NULL*/\n 3431: 	if (p_bmg160 == BMG160_NULL) {\n 3432: 		return  E_BMG160_NULL_PTR;\n 3433  		} else {\n 3434  		/* read latch interrupt */\n ....\n 3479  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3480  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3481: 	/* check the p_bmg160 struct pointer is NULL*/\n 3482: 	if (p_bmg160 == BMG160_NULL) {\n 3483: 		return  E_BMG160_NULL_PTR;\n 3484  		} else {\n 3485  		/* write latch interrupt */\n ....\n 3526  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3527  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3528: 	/* check the p_bmg160 struct pointer is NULL*/\n 3529: 	if (p_bmg160 == BMG160_NULL) {\n 3530: 		return  E_BMG160_NULL_PTR;\n 3531  		} else {\n 3532  		switch (v_channel_u8) {\n ....\n 3594  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3595  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3596: 	/* check the p_bmg160 struct pointer is NULL*/\n 3597: 	if (p_bmg160 == BMG160_NULL) {\n 3598: 		return  E_BMG160_NULL_PTR;\n 3599  		} else {\n 3600  		switch (v_channel_u8) {\n ....\n 3674  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3675  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3676: 	/* check the p_bmg160 struct pointer is NULL*/\n 3677: 	if (p_bmg160 == BMG160_NULL) {\n 3678: 		return  E_BMG160_NULL_PTR;\n 3679  		} else {\n 3680  		switch (v_channel_u8) {\n ....\n 3742  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3743  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3744: 	/* check the p_bmg160 struct pointer is NULL*/\n 3745: 	if (p_bmg160 == BMG160_NULL) {\n 3746: 		return  E_BMG160_NULL_PTR;\n 3747  		} else {\n 3748  		switch (v_channel_u8) {\n ....\n 3823  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3824  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3825: 	/* check the p_bmg160 struct pointer is NULL*/\n 3826: 	if (p_bmg160 == BMG160_NULL) {\n 3827: 		return  E_BMG160_NULL_PTR;\n 3828  		} else {\n 3829  		switch (v_channel_u8) {\n ....\n 3892  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3893  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3894: 	/* check the p_bmg160 struct pointer is NULL*/\n 3895: 	if (p_bmg160 == BMG160_NULL) {\n 3896: 		return  E_BMG160_NULL_PTR;\n 3897  		} else {\n 3898  		switch (v_channel_u8) {\n ....\n 3975  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 3976  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 3977: 	/* check the p_bmg160 struct pointer is NULL*/\n 3978: 	if (p_bmg160 == BMG160_NULL) {\n 3979: 		return  E_BMG160_NULL_PTR;\n 3980  		} else {\n 3981  		switch (v_channel_u8) {\n ....\n 4043  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4044  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4045: 	/* check the p_bmg160 struct pointer is NULL*/\n 4046: 	if (p_bmg160 == BMG160_NULL) {\n 4047: 		return  E_BMG160_NULL_PTR;\n 4048  		} else {\n 4049  		switch (v_channel_u8) {\n ....\n 4104  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4105  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4106: 	/* check the p_bmg160 struct pointer is NULL*/\n 4107: 	if (p_bmg160 == BMG160_NULL) {\n 4108: 		return  E_BMG160_NULL_PTR;\n 4109  		} else {\n 4110  		/* read slow offset threshold*/\n ....\n 4143  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4144  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4145: 	/* check the p_bmg160 struct pointer is NULL*/\n 4146: 	if (p_bmg160 == BMG160_NULL) {\n 4147: 		return  E_BMG160_NULL_PTR;\n 4148  		} else {\n 4149  		/* write slow offset threshold*/\n ....\n 4189  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4190  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4191: 	/* check the p_bmg160 struct pointer is NULL*/\n 4192: 	if (p_bmg160 == BMG160_NULL) {\n 4193: 		return  E_BMG160_NULL_PTR;\n 4194  		} else {\n 4195  		/* read slow offset duration*/\n ....\n 4232  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4233  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4234: 	/* check the p_bmg160 struct pointer is NULL*/\n 4235: 	if (p_bmg160 == BMG160_NULL) {\n 4236: 		return  E_BMG160_NULL_PTR;\n 4237  		} else {\n 4238  		/* write slow offset duration*/\n ....\n 4281  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4282  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4283: 	/* check the p_bmg160 struct pointer is NULL*/\n 4284: 	if (p_bmg160 == BMG160_NULL) {\n 4285: 		return  E_BMG160_NULL_PTR;\n 4286  		} else {\n 4287  		switch (v_channel_u8) {\n ....\n 4351  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4352  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4353: 	/* check the p_bmg160 struct pointer is NULL*/\n 4354: 	if (p_bmg160 == BMG160_NULL) {\n 4355: 		return  E_BMG160_NULL_PTR;\n 4356  		} else {\n 4357  		switch (v_channel_u8) {\n ....\n 4434  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4435  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4436: 	/* check the p_bmg160 struct pointer is NULL*/\n 4437: 	if (p_bmg160 == BMG160_NULL) {\n 4438: 		return  E_BMG160_NULL_PTR;\n 4439  		} else {\n 4440  		switch (v_channel_u8) {\n ....\n 4497  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4498  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4499: 	/* check the p_bmg160 struct pointer is NULL*/\n 4500: 	if (p_bmg160 == BMG160_NULL) {\n 4501: 		return  E_BMG160_NULL_PTR;\n 4502  		} else {\n 4503  		switch (v_channel_u8) {\n ....\n 4552  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4553  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4554: 	/* check the p_bmg160 struct pointer is NULL*/\n 4555: 	if (p_bmg160 == BMG160_NULL) {\n 4556: 		return  E_BMG160_NULL_PTR;\n 4557  		} else {\n 4558  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n ....\n 4597  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4598  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4599: 	/* check the p_bmg160 struct pointer is NULL*/\n 4600: 	if (p_bmg160 == BMG160_NULL) {\n 4601: 		return  E_BMG160_NULL_PTR;\n 4602  		} else {\n 4603  		/* read fast offset enable axis*/\n ....\n 4646  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4647  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 4648: 	/* check the p_bmg160 struct pointer is NULL*/\n 4649: 	if (p_bmg160 == BMG160_NULL) {\n 4650: 		return  E_BMG160_NULL_PTR;\n 4651  		} else {\n 4652  		switch (v_channel_u8) {\n ....\n 4717  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4718  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 4719: 	/* check the p_bmg160 struct pointer is NULL*/\n 4720: 	if (p_bmg160 == BMG160_NULL) {\n 4721: 		return  E_BMG160_NULL_PTR;\n 4722  		} else {\n 4723  		/* read NVM program*/\n ....\n 4752  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4753  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 4754: 	/* check the p_bmg160 struct pointer is NULL*/\n 4755: 	if (p_bmg160 == BMG160_NULL) {\n 4756: 		return  E_BMG160_NULL_PTR;\n 4757  		} else {\n 4758  		/* write NVM program*/\n ....\n 4790  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4791  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 4792: 	/* check the p_bmg160 struct pointer is NULL*/\n 4793: 	if (p_bmg160 == BMG160_NULL) {\n 4794: 		return  E_BMG160_NULL_PTR;\n 4795  		} else {\n 4796  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n ....\n 4824  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4825  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 4826: 	/* check the p_bmg160 struct pointer is NULL*/\n 4827: 	if (p_bmg160 == BMG160_NULL) {\n 4828: 		return  E_BMG160_NULL_PTR;\n 4829  		} else {\n 4830  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n ....\n 4862  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4863  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 4864: 	/* check the p_bmg160 struct pointer is NULL*/\n 4865: 	if (p_bmg160 == BMG160_NULL) {\n 4866: 		return  E_BMG160_NULL_PTR;\n 4867  		} else {\n 4868  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n ....\n 4897  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4898  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 4899: 	/* check the p_bmg160 struct pointer is NULL*/\n 4900: 	if (p_bmg160 == BMG160_NULL) {\n 4901: 		return  E_BMG160_NULL_PTR;\n 4902  		} else {\n 4903  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n ....\n 4943  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 4944  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 4945: 	/* check the p_bmg160 struct pointer is NULL*/\n 4946: 	if (p_bmg160 == BMG160_NULL) {\n 4947: 		return  E_BMG160_NULL_PTR;\n 4948  		} else {\n 4949  		switch (v_channel_u8) {\n ....\n 5003  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5004  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5005: 	/* check the p_bmg160 struct pointer is NULL*/\n 5006: 	if (p_bmg160 == BMG160_NULL) {\n 5007: 		return  E_BMG160_NULL_PTR;\n 5008  		} else {\n 5009  		switch (v_channel_u8) {\n ....\n 5065  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5066  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5067: 	/* check the p_bmg160 struct pointer is NULL*/\n 5068: 	if (p_bmg160 == BMG160_NULL) {\n 5069: 		return  E_BMG160_NULL_PTR;\n 5070  		} else {\n 5071  		comres = p_bmg160->BMG160_BUS_READ_FUNC(\n ....\n 5103  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5104  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5105: 	/* check the p_bmg160 struct pointer is NULL*/\n 5106: 	if (p_bmg160 == BMG160_NULL) {\n 5107: 		return  E_BMG160_NULL_PTR;\n 5108  		} else {\n 5109  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n ....\n 5141  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5142  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5143: 	/* check the p_bmg160 struct pointer is NULL*/\n 5144: 	if (p_bmg160 == BMG160_NULL) {\n 5145: 		return  E_BMG160_NULL_PTR;\n 5146  		} else {\n 5147  		/* read fifo tag*/\n ....\n 5177  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5178  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5179: 	/* check the p_bmg160 struct pointer is NULL*/\n 5180: 	if (p_bmg160 == BMG160_NULL) {\n 5181: 		return  E_BMG160_NULL_PTR;\n 5182  		} else {\n 5183  		if (v_fifo_tag_u8 < BMG160_BIT_LENGTH_FIFO_TAG) {\n ....\n 5221  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5222  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5223: 	/* check the p_bmg160 struct pointer is NULL*/\n 5224: 	if (p_bmg160 == BMG160_NULL) {\n 5225: 		return  E_BMG160_NULL_PTR;\n 5226  		} else {\n 5227  		comres = p_bmg160->BMG160_BUS_READ_FUNC(p_bmg160->dev_addr,\n ....\n 5255  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5256  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5257: 	/* check the p_bmg160 struct pointer is NULL*/\n 5258: 	if (p_bmg160 == BMG160_NULL) {\n 5259: 		return  E_BMG160_NULL_PTR;\n 5260  		} else {\n 5261  		if (v_fifo_wm_level_u8 < BMG160_FIFO_WM_LENGTH) {\n ....\n 5317  	u8 v_data1_u8r = BMG160_INIT_VALUE;\n 5318  	u8 v_data2_u8r = BMG160_INIT_VALUE;\n 5319: 	/* check the p_bmg160 struct pointer is NULL*/\n 5320: 	if (p_bmg160 == BMG160_NULL) {\n 5321: 		return  E_BMG160_NULL_PTR;\n 5322  		} else {\n 5323  		switch (v_axis_u8) {\n ....\n 5445  	u8 v_data1_u8r = BMG160_INIT_VALUE;\n 5446  	u8 v_data2_u8r = BMG160_INIT_VALUE;\n 5447: 	/* check the p_bmg160 struct pointer is NULL*/\n 5448: 	if (p_bmg160 == BMG160_NULL) {\n 5449: 		return  E_BMG160_NULL_PTR;\n 5450  		} else {\n 5451  		switch (v_axis_u8) {\n ....\n 5566  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5567  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5568: 	/* check the p_bmg160 struct pointer is NULL*/\n 5569: 	if (p_bmg160 == BMG160_NULL) {\n 5570: 		return  E_BMG160_NULL_PTR;\n 5571  		} else {\n 5572  		switch (v_param_u8) {\n ....\n 5621  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5622  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5623: 	/* check the p_bmg160 struct pointer is NULL*/\n 5624: 	if (p_bmg160 == BMG160_NULL) {\n 5625: 		return  E_BMG160_NULL_PTR;\n 5626  		} else {\n 5627  		switch (v_param_u8) {\n ....\n 5675  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5676  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5677: 	/* check the p_bmg160 struct pointer is NULL*/\n 5678: 	if (p_bmg160 == BMG160_NULL) {\n 5679: 		return  E_BMG160_NULL_PTR;\n 5680  		} else {\n 5681  		/* read the fifo data */\n ....\n 5709  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5710  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5711: 	/* check the p_bmg160 struct pointer is NULL*/\n 5712: 	if (p_bmg160 == BMG160_NULL) {\n 5713: 		return  E_BMG160_NULL_PTR;\n 5714  		} else {\n 5715  		/* read fifo over run and frame counter */\n ....\n 5741  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5742  	u8 v_data_u8  = BMG160_INIT_VALUE;\n 5743: 	/* check the p_bmg160 struct pointer is NULL*/\n 5744: 	if (p_bmg160 == BMG160_NULL) {\n 5745: 		return  E_BMG160_NULL_PTR;\n 5746  		} else {\n 5747  		/* read fifo frame counter */\n ....\n 5774  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5775  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5776: 	/* check the p_bmg160 struct pointer is NULL*/\n 5777: 	if (p_bmg160 == BMG160_NULL) {\n 5778: 		return  E_BMG160_NULL_PTR;\n 5779  		} else {\n 5780  		/* read fifo over run*/\n ....\n 5813  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5814  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5815: 	/* check the p_bmg160 struct pointer is NULL*/\n 5816: 	if (p_bmg160 == BMG160_NULL) {\n 5817: 		return  E_BMG160_NULL_PTR;\n 5818  		} else {\n 5819  		/* read fifo mode*/\n ....\n 5852  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5853  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5854: 	/* check the p_bmg160 struct pointer is NULL*/\n 5855: 	if (p_bmg160 == BMG160_NULL) {\n 5856: 		return  E_BMG160_NULL_PTR;\n 5857  		} else {\n 5858  		if (v_fifo_mode_u8 < BMG160_BIT_LENGTH_FIFO_MODE) {\n ....\n 5901  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5902  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5903: 	/* check the p_bmg160 struct pointer is NULL*/\n 5904: 	if (p_bmg160 == BMG160_NULL) {\n 5905: 		return  E_BMG160_NULL_PTR;\n 5906  		} else {\n 5907  		/* read fifo data select*/\n ....\n 5941  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 5942  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 5943: 	/* check the p_bmg160 struct pointer is NULL*/\n 5944: 	if (p_bmg160 == BMG160_NULL) {\n 5945: 		return  E_BMG160_NULL_PTR;\n 5946  		} else {\n 5947  		if (v_fifo_data_select_u8 <\n ....\n 5996  \n 5997  	if (p_bmg160 == BMG160_INIT_VALUE) {\n 5998: 		return  E_BMG160_NULL_PTR;\n 5999  		} else {\n 6000  		/* read the power mode*/\n ....\n 6067  \n 6068  	if (p_bmg160 == BMG160_INIT_VALUE) {\n 6069: 		return  E_BMG160_NULL_PTR;\n 6070  		} else {\n 6071  		if (v_power_mode_u8 < BMG160_BIT_LENGTH_POWER_MODE) {\n ....\n 6287  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 6288  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 6289: 	/* check the p_bmg160 struct pointer is NULL*/\n 6290: 	if (p_bmg160 == BMG160_NULL) {\n 6291: 		return  E_BMG160_NULL_PTR;\n 6292  		} else {\n 6293  		/* read auto sleep duration*/\n ....\n 6345  u8 v_data_u8 = BMG160_INIT_VALUE;\n 6346  u8 v_auto_sleep_durn_u8r = BMG160_INIT_VALUE;\n 6347: /* check the p_bmg160 struct pointer is NULL*/\n 6348: if (p_bmg160 == BMG160_NULL) {\n 6349: 	return  E_BMG160_NULL_PTR;\n 6350  } else {\n 6351  	/* write auto sleep duration*/\n ....\n 6481  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 6482  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 6483: 	/* check the p_bmg160 struct pointer is NULL*/\n 6484: 	if (p_bmg160 == BMG160_NULL) {\n 6485: 		return  E_BMG160_NULL_PTR;\n 6486  		} else {\n 6487  		/* read sleep duration */\n ....\n 6524  	BMG160_RETURN_FUNCTION_TYPE comres = BMG160_ERROR;\n 6525  	u8 v_data_u8 = BMG160_INIT_VALUE;\n 6526: 	/* check the p_bmg160 struct pointer is NULL*/\n 6527: 	if (p_bmg160 == BMG160_NULL) {\n 6528: 		return  E_BMG160_NULL_PTR;\n 6529  		} else {\n 6530  		if (v_durn_u8 < BMG160_BIT_LENGTH_DURN) {\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/motion_sensor/BMG160/bmg160.h:\n 1430  /**********************************************/\n 1431  \n 1432: #define BMG160_NULL                             (0)\n 1433: /**< constant declaration of NULL */\n 1434  #define BMG160_DISABLE                          (0)\n 1435  /**< It refers BMG160 disable */\n ....\n 1547  #define C_BMG160_FAILURE						(1)\n 1548  /**< It refers BMG160 operation is Failure */\n 1549: #define E_BMG160_NULL_PTR               ((s8)-127)\n 1550  #define E_BMG160_OUT_OF_RANGE           ((s8)-2)\n 1551  #define BMG160_ERROR							((s8)-1)\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/motion_sensor/BMG160/bmg160_user.c:\n  287  s8 BMG160_I2C_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)\n  288  {\n  289:         mico_i2c_message_t bmg160_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n  290  	s32 iError = BMG160_INIT_VALUE;\n  291  	u8 array[I2C_BUFFER_LEN];\n  ...\n  327  s8 BMG160_I2C_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)\n  328  {\n  329:         mico_i2c_message_t bmg160_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n  330  	s32 iError = BMG160_INIT_VALUE;\n  331  	u8 array[I2C_BUFFER_LEN] = {BMG160_INIT_VALUE};\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/motion_sensor/BMM050/bmm050.c:\n  263  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n  264  	u8 v_data_u8 = BMM050_INIT_VALUE;\n  265: 	/* check the p_bmm050 pointer is NULL*/\n  266: 	if (p_bmm050 == BMM050_NULL) {\n  267: 		return E_BMM050_NULL_PTR;\n  268  		} else {\n  269  		/* select the functional state*/\n  ...\n  365  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n  366  	u8 v_data_u8 = BMM050_INIT_VALUE;\n  367: 	/* check the p_bmm050 pointer is NULL*/\n  368: 	if (p_bmm050 == BMM050_NULL) {\n  369: 		return  E_BMM050_NULL_PTR;\n  370  		} else {\n  371  		/* read the functional state*/\n  ...\n  423  	} raw_data_xyz_t;\n  424  \n  425: 	/* check the p_bmm050 pointer is NULL*/\n  426: 	if (p_bmm050 == BMM050_NULL) {\n  427: 		return  E_BMM050_NULL_PTR;\n  428  		} else {\n  429  		/* read the mag xyz and r data*/\n  ...\n  546  	} raw_data_xyz_t;\n  547  \n  548: 	/* check the p_bmm050 pointer is NULL*/\n  549: 	if (p_bmm050 == BMM050_NULL) {\n  550: 		return  E_BMM050_NULL_PTR;\n  551  		} else {\n  552  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(p_bmm050->dev_addr,\n  ...\n  668  	} raw_data_xyz_t;\n  669  \n  670: 	/* check the p_bmm050 pointer is NULL*/\n  671: 	if (p_bmm050 == BMM050_NULL) {\n  672: 		return  E_BMM050_NULL_PTR;\n  673  		} else {\n  674  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(p_bmm050->dev_addr,\n  ...\n  785  		u16 raw_data_r;\n  786  	} raw_data_xyz_t;\n  787: 	/* check the p_bmm050 pointer is NULL*/\n  788: 	if (p_bmm050 == BMM050_NULL) {\n  789: 		return  E_BMM050_NULL_PTR;\n  790  		} else {\n  791  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(p_bmm050->dev_addr,\n  ...\n  909  	} raw_data_xyz_t;\n  910  \n  911: 	/* check the p_bmm050 pointer is NULL*/\n  912: 	if (p_bmm050 == BMM050_NULL) {\n  913: 		return  E_BMM050_NULL_PTR;\n  914  		} else {\n  915  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(p_bmm050->dev_addr,\n  ...\n 1031  	} raw_data_xyz_t;\n 1032  \n 1033: 	/* check the p_bmm050 pointer is NULL*/\n 1034: 	if (p_bmm050 == BMM050_NULL) {\n 1035: 		return  E_BMM050_NULL_PTR;\n 1036  		} else {\n 1037  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(p_bmm050->dev_addr,\n ....\n 1132  	/* variable used to return the bus communication result*/\n 1133  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1134: 	/* check the p_bmm050 pointer is NULL*/\n 1135: 	if (p_bmm050 == BMM050_NULL) {\n 1136: 		return  E_BMM050_NULL_PTR;\n 1137  		} else {\n 1138  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(p_bmm050->dev_addr,\n ....\n 1163  	/* variable used to return the bus communication result*/\n 1164  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1165: 	/* check the p_bmm050 pointer is NULL*/\n 1166: 	if (p_bmm050 == BMM050_NULL) {\n 1167: 		return  E_BMM050_NULL_PTR;\n 1168  		} else {\n 1169  		com_rslt = p_bmm050->BMM050_BUS_WRITE_FUNC(p_bmm050->dev_addr,\n ....\n 1191  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1192  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1193: 	/* check the p_bmm050 pointer is NULL*/\n 1194: 	if (p_bmm050 == BMM050_NULL) {\n 1195: 		return  E_BMM050_NULL_PTR;\n 1196  		} else {\n 1197  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(\n ....\n 1229  	BMM050_INIT_VALUE, BMM050_INIT_VALUE, BMM050_INIT_VALUE};\n 1230  	u8 v_result_u8 = BMM050_INIT_VALUE;\n 1231: 	/* check the p_bmm050 pointer is NULL*/\n 1232: 	if (p_bmm050 == BMM050_NULL) {\n 1233: 		return  E_BMM050_NULL_PTR;\n 1234  		} else {\n 1235  		/* read self test*/\n ....\n 1280  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1281  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1282: 	/* check the p_bmm050 pointer is NULL*/\n 1283: 	if (p_bmm050 == BMM050_NULL) {\n 1284: 		return  E_BMM050_NULL_PTR;\n 1285  		} else {\n 1286  		/* write spi3 */\n ....\n 1324  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1325  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1326: 	/* check the p_bmm050 pointer is NULL*/\n 1327: 	if (p_bmm050 == BMM050_NULL) {\n 1328: 		return  E_BMM050_NULL_PTR;\n 1329  		} else {\n 1330  		/* set the data rate */\n ....\n 1370  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1371  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1372: 	/* check the p_bmm050 pointer is NULL*/\n 1373: 	if (p_bmm050 == BMM050_NULL) {\n 1374: 		return  E_BMM050_NULL_PTR;\n 1375  		} else {\n 1376  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(\n ....\n 1406  	BMM050_INIT_VALUE, BMM050_INIT_VALUE,\n 1407  	BMM050_INIT_VALUE, BMM050_INIT_VALUE};\n 1408: 	/* check the p_bmm050 pointer is NULL*/\n 1409: 	if (p_bmm050 == BMM050_NULL) {\n 1410: 		return  E_BMM050_NULL_PTR;\n 1411  		} else {\n 1412  		/* set sleep mode to prepare for forced measurement.\n ....\n 1567  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1568  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1569: 	/* check the p_bmm050 pointer is NULL*/\n 1570: 	if (p_bmm050 == BMM050_NULL) {\n 1571: 		return  E_BMM050_NULL_PTR;\n 1572  		} else {\n 1573  		switch (v_advanced_selftest_u8) {\n ....\n 1653  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1654  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1655: 	/* check the p_bmm050 pointer is NULL*/\n 1656: 	if (p_bmm050 == BMM050_NULL) {\n 1657: 		return  E_BMM050_NULL_PTR;\n 1658  		} else {\n 1659  		/* read advanced self test */\n ....\n 1690  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1691  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1692: 	/* check the p_bmm050 pointer is NULL*/\n 1693: 	if (p_bmm050 == BMM050_NULL) {\n 1694: 		return  E_BMM050_NULL_PTR;\n 1695  		} else {\n 1696  		/* read power control bit */\n ....\n 1728  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1729  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1730: 	/* check the p_bmm050 pointer is NULL*/\n 1731: 	if (p_bmm050 == BMM050_NULL) {\n 1732: 		return  E_BMM050_NULL_PTR;\n 1733  		} else {\n 1734  		/* write power control bit*/\n ....\n 1766  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1767  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1768: 	/* check the p_bmm050 pointer is NULL*/\n 1769: 	if (p_bmm050 == BMM050_NULL) {\n 1770: 		return  E_BMM050_NULL_PTR;\n 1771  		} else {\n 1772  		/* read XY repetitions*/\n ....\n 1799  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1800  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1801: 	/* check the p_bmm050 pointer is NULL*/\n 1802: 	if (p_bmm050 == BMM050_NULL) {\n 1803: 		return  E_BMM050_NULL_PTR;\n 1804  		} else {\n 1805  		/* write XY repetitions*/\n ....\n 1831  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1832  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1833: 	/* check the p_bmm050 pointer is NULL*/\n 1834: 	if (p_bmm050 == BMM050_NULL) {\n 1835: 		return  E_BMM050_NULL_PTR;\n 1836  		} else {\n 1837  		/* read Z repetitions*/\n ....\n 1863  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 1864  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 1865: 	/* check the p_bmm050 pointer is NULL*/\n 1866: 	if (p_bmm050 == BMM050_NULL) {\n 1867: 		return  E_BMM050_NULL_PTR;\n 1868  		} else {\n 1869  		/* write Z repetitions*/\n ....\n 2259  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 2260  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 2261: 	/* check the p_bmm050 pointer is NULL*/\n 2262: 	if (p_bmm050 == BMM050_NULL) {\n 2263: 		return  E_BMM050_NULL_PTR;\n 2264  		} else {\n 2265  		/* read control measurement */\n ....\n 2301  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 2302  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 2303: 	/* check the p_bmm050 pointer is NULL*/\n 2304: 	if (p_bmm050 == BMM050_NULL) {\n 2305: 		return  E_BMM050_NULL_PTR;\n 2306  		} else {\n 2307  		/* read control measurement */\n ....\n 2338  	BMM050_RETURN_FUNCTION_TYPE com_rslt = BMM050_ERROR;\n 2339  	u8 v_data_u8 = BMM050_INIT_VALUE;\n 2340: 	/* check the p_bmm050 pointer is NULL*/\n 2341: 	if (p_bmm050 == BMM050_NULL) {\n 2342: 		return  E_BMM050_NULL_PTR;\n 2343  		} else {\n 2344  		v_data_u8 = BMM050_ON;\n ....\n 2408  	BMM050_INIT_VALUE, BMM050_INIT_VALUE,\n 2409  	BMM050_INIT_VALUE, BMM050_INIT_VALUE};\n 2410: 	/* check the p_bmm050 pointer is NULL*/\n 2411: 	if (p_bmm050 == BMM050_NULL) {\n 2412: 		return  E_BMM050_NULL_PTR;\n 2413  		} else {\n 2414  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(p_bmm050->dev_addr,\n ....\n 2501  	BMM050_INIT_VALUE, BMM050_INIT_VALUE,\n 2502  	BMM050_INIT_VALUE, BMM050_INIT_VALUE};\n 2503: 	/* check the p_bmm050 pointer is NULL*/\n 2504: 	if (p_bmm050 == BMM050_NULL) {\n 2505: 		return  E_BMM050_NULL_PTR;\n 2506  		} else {\n 2507  		com_rslt = p_bmm050->BMM050_BUS_READ_FUNC(p_bmm050->dev_addr,\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/motion_sensor/BMM050/bmm050.h:\n  716  \n  717  /** Error code definitions**/\n  718: #define E_BMM050_NULL_PTR           ((s8)-127)\n  719  #define BMM050_ERROR                ((s8)-1)\n  720  #define E_BMM050_OUT_OF_RANGE       ((s8)-2)\n  721: #define BMM050_NULL                 ((u8)0)\n  722  #define E_BMM050_UNDEFINED_MODE     (0)\n  723  \n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/motion_sensor/BMM050/bmm050_user.c:\n  273  s8 BMM050_I2C_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)\n  274  {\n  275:         mico_i2c_message_t bmm050_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n  276  	s32 iError = BMM050_INIT_VALUE;\n  277  	u8 array[I2C_BUFFER_LEN];\n  ...\n  315  s8 BMM050_I2C_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)\n  316  {\n  317:         mico_i2c_message_t bmm050_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n  318  	s32 iError = BMM050_INIT_VALUE;\n  319  	u8 array[I2C_BUFFER_LEN] = {BMM050_INIT_VALUE};\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/temp_hum_sensor/BME280/bme280.c:\n  127  	u8 a_data_u8r[BME280_TEMPERATURE_DATA_SIZE] = {\n  128  	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE};\n  129: 	/* check the p_bme280 structure pointer as NULL*/\n  130: 	if (p_bme280 == BME280_NULL) {\n  131: 		return E_BME280_NULL_PTR;\n  132  		} else {\n  133  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n  ...\n  246  	u8 a_data_u8[BME280_PRESSURE_DATA_SIZE] = {\n  247  	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE};\n  248: 	/* check the p_bme280 structure pointer as NULL*/\n  249: 	if (p_bme280 == BME280_NULL) {\n  250: 		return E_BME280_NULL_PTR;\n  251  		} else {\n  252  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n  ...\n  380  	u8 a_data_u8[BME280_HUMIDITY_DATA_SIZE] = {\n  381  	BME280_INIT_VALUE, BME280_INIT_VALUE};\n  382: 	/* check the p_bme280 structure pointer as NULL*/\n  383: 	if (p_bme280 == BME280_NULL) {\n  384: 		return E_BME280_NULL_PTR;\n  385  		} else {\n  386  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n  ...\n  504  	BME280_INIT_VALUE, BME280_INIT_VALUE,\n  505  	BME280_INIT_VALUE, BME280_INIT_VALUE};\n  506: 	/* check the p_bme280 structure pointer as NULL*/\n  507: 	if (p_bme280 == BME280_NULL) {\n  508: 		return E_BME280_NULL_PTR;\n  509  		} else {\n  510  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n  ...\n  571  	s32 v_uncom_temperature_s32 = BME280_INIT_VALUE;\n  572  	s32 v_uncom_humidity_s32 = BME280_INIT_VALUE;\n  573: 	/* check the p_bme280 structure pointer as NULL*/\n  574: 	if (p_bme280 == BME280_NULL) {\n  575: 		return E_BME280_NULL_PTR;\n  576  		} else {\n  577  			/* read the uncompensated pressure,\n  ...\n  634  	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE,\n  635  	BME280_INIT_VALUE, BME280_INIT_VALUE, BME280_INIT_VALUE};\n  636: 	/* check the p_bme280 structure pointer as NULL*/\n  637: 	if (p_bme280 == BME280_NULL) {\n  638: 		return E_BME280_NULL_PTR;\n  639  		} else {\n  640  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n  ...\n  766  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n  767  	u8 v_data_u8 = BME280_INIT_VALUE;\n  768: 	/* check the p_bme280 structure pointer as NULL*/\n  769: 	if (p_bme280 == BME280_NULL) {\n  770: 		return E_BME280_NULL_PTR;\n  771  		} else {\n  772  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n  ...\n  815  	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;\n  816  	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;\n  817: 	/* check the p_bme280 structure pointer as NULL*/\n  818: 	if (p_bme280 == BME280_NULL) {\n  819: 		return E_BME280_NULL_PTR;\n  820  		} else {\n  821  			v_data_u8 = p_bme280->ctrl_meas_reg;\n  ...\n  904  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n  905  	u8 v_data_u8 = BME280_INIT_VALUE;\n  906: 	/* check the p_bme280 structure pointer as NULL*/\n  907: 	if (p_bme280 == BME280_NULL) {\n  908: 		return E_BME280_NULL_PTR;\n  909  		} else {\n  910  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n  ...\n  954  	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;\n  955  	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;\n  956: 	/* check the p_bme280 structure pointer as NULL*/\n  957: 	if (p_bme280 == BME280_NULL) {\n  958: 		return E_BME280_NULL_PTR;\n  959  		} else {\n  960  			v_data_u8 = p_bme280->ctrl_meas_reg;\n  ...\n 1043  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n 1044  	u8 v_data_u8 = BME280_INIT_VALUE;\n 1045: 	/* check the p_bme280 structure pointer as NULL*/\n 1046: 	if (p_bme280 == BME280_NULL) {\n 1047: 		return E_BME280_NULL_PTR;\n 1048  		} else {\n 1049  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n ....\n 1107  	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;\n 1108  	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;\n 1109: 	/* check the p_bme280 structure pointer as NULL*/\n 1110: 	if (p_bme280 == BME280_NULL) {\n 1111: 		return E_BME280_NULL_PTR;\n 1112  		} else {\n 1113  			/* write humidity oversampling*/\n ....\n 1195  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n 1196  	u8 v_mode_u8r = BME280_INIT_VALUE;\n 1197: 	/* check the p_bme280 structure pointer as NULL*/\n 1198: 	if (p_bme280 == BME280_NULL) {\n 1199: 		return E_BME280_NULL_PTR;\n 1200  		} else {\n 1201  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n ....\n 1236  	u8 v_pre_config_value_u8 = BME280_INIT_VALUE;\n 1237  	u8 v_data_u8 = BME280_INIT_VALUE;\n 1238: 	/* check the p_bme280 structure pointer as NULL*/\n 1239: 	if (p_bme280 == BME280_NULL) {\n 1240: 		return E_BME280_NULL_PTR;\n 1241  		} else {\n 1242  			if (v_power_mode_u8 <= BME280_NORMAL_MODE) {\n ....\n 1322  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n 1323  	u8 v_data_u8 = BME280_SOFT_RESET_CODE;\n 1324: 	/* check the p_bme280 structure pointer as NULL*/\n 1325: 	if (p_bme280 == BME280_NULL) {\n 1326: 		return E_BME280_NULL_PTR;\n 1327  		} else {\n 1328  			com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(\n ....\n 1358  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n 1359  	u8 v_data_u8 = BME280_INIT_VALUE;\n 1360: 	/* check the p_bme280 structure pointer as NULL*/\n 1361: 	if (p_bme280 == BME280_NULL) {\n 1362: 		return E_BME280_NULL_PTR;\n 1363  		} else {\n 1364  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n ....\n 1400  	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;\n 1401  	u8 v_pre_ctrl_hum_value_u8 =  BME280_INIT_VALUE;\n 1402: 	/* check the p_bme280 structure pointer as NULL*/\n 1403: 	if (p_bme280 == BME280_NULL) {\n 1404: 		return E_BME280_NULL_PTR;\n 1405  		} else {\n 1406  			v_data_u8 = p_bme280->config_reg;\n ....\n 1485  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n 1486  	u8 v_data_u8 = BME280_INIT_VALUE;\n 1487: 	/* check the p_bme280 structure pointer as NULL*/\n 1488: 	if (p_bme280 == BME280_NULL) {\n 1489: 		return E_BME280_NULL_PTR;\n 1490  		} else {\n 1491  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n ....\n 1528  	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;\n 1529  	u8 v_pre_ctrl_hum_value_u8 =  BME280_INIT_VALUE;\n 1530: 	/* check the p_bme280 structure pointer as NULL*/\n 1531: 	if (p_bme280 == BME280_NULL) {\n 1532: 		return E_BME280_NULL_PTR;\n 1533  		} else {\n 1534  			v_data_u8 = p_bme280->config_reg;\n ....\n 1612  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n 1613  	u8 v_data_u8 = BME280_INIT_VALUE;\n 1614: 	/* check the p_bme280 structure pointer as NULL*/\n 1615: 	if (p_bme280 == BME280_NULL) {\n 1616: 		return E_BME280_NULL_PTR;\n 1617  		} else {\n 1618  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n ....\n 1666  	u8 v_prev_pow_mode_u8 = BME280_INIT_VALUE;\n 1667  	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;\n 1668: 	/* check the p_bme280 structure pointer as NULL*/\n 1669: 	if (p_bme280 == BME280_NULL) {\n 1670: 		return E_BME280_NULL_PTR;\n 1671  		} else {\n 1672  			v_data_u8 = p_bme280->config_reg;\n ....\n 1747  BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n 1748  u8 v_data_u8 = BME280_INIT_VALUE;\n 1749: if (p_bme280 == BME280_NULL) {\n 1750: 	return E_BME280_NULL_PTR;\n 1751  } else {\n 1752  	if (v_work_mode_u8 <= BME280_ULTRAHIGHRESOLUTION_MODE) {\n ....\n 1830  	u8 pre_ctrl_config_value = BME280_INIT_VALUE;\n 1831  	u8 v_pre_ctrl_hum_value_u8 = BME280_INIT_VALUE;\n 1832: 	/* check the p_bme280 structure pointer as NULL*/\n 1833: 	if (p_bme280 == BME280_NULL) {\n 1834: 		return E_BME280_NULL_PTR;\n 1835  		} else {\n 1836  			v_mode_u8r = p_bme280->ctrl_meas_reg;\n ....\n 1923  	/* used to return the communication result*/\n 1924  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n 1925: 	/* check the p_bme280 structure pointer as NULL*/\n 1926: 	if (p_bme280 == BME280_NULL) {\n 1927: 		return E_BME280_NULL_PTR;\n 1928  		} else {\n 1929  			com_rslt = p_bme280->BME280_BUS_WRITE_FUNC(\n ....\n 1955  	/* used to return the communication result*/\n 1956  	BME280_RETURN_FUNCTION_TYPE com_rslt = BME280_ERROR;\n 1957: 	/* check the p_bme280 structure pointer as NULL*/\n 1958: 	if (p_bme280 == BME280_NULL) {\n 1959: 		return E_BME280_NULL_PTR;\n 1960  		} else {\n 1961  			com_rslt = p_bme280->BME280_BUS_READ_FUNC(\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/temp_hum_sensor/BME280/bme280.h:\n  436  /***************************************************************/\n  437  /* Constants */\n  438: #define BME280_NULL                          (0)\n  439  #define BME280_RETURN_FUNCTION_TYPE          s8\n  440  /* shift definitions*/\n  ...\n  477  /***************************************************/\n  478  #define	BME280_SUCCESS					((u8)0)\n  479: #define E_BME280_NULL_PTR       ((s8)-127)\n  480  #define E_BME280_COMM_RES       ((s8)-1)\n  481  #define E_BME280_OUT_OF_RANGE   ((s8)-2)\n\n/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/temp_hum_sensor/BME280/bme280_user.c:\n  317  s8 BME280_I2C_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)\n  318  {\n  319:         mico_i2c_message_t user_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n  320    \n  321  	s32 iError = BME280_INIT_VALUE;\n  ...\n  358  s8 BME280_I2C_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)\n  359  {\n  360:         mico_i2c_message_t user_i2c_msg = {NULL, NULL, 0, 0, 0, false};\n  361      \n  362  	s32 iError = BME280_INIT_VALUE;\n\n/Users/William/Develop/MiCO/Platform/Drivers/spi_flash/spi_flash.c:\n   34  #include \"spi_flash_internal.h\"\n   35  #include \"spi_flash_platform_interface.h\"\n   36: #include <string.h> /* for NULL */\n   37  \n   38  #define sFLASH_SPI_PAGESIZE       0x100\n   ..\n   40  int sflash_read_ID( const sflash_handle_t* const handle, void* const data_addr )\n   41  {\n   42:     return generic_sflash_command( handle, SFLASH_READ_JEDEC_ID, 0, NULL, 3, NULL, data_addr );\n   43  }\n   44  \n   ..\n   48      {\n   49          /* Send write-enable command */\n   50:         int status = generic_sflash_command( handle, SFLASH_WRITE_ENABLE, 0, NULL, 0, NULL, NULL );\n   51          if ( status != 0 )\n   52          {\n   ..\n   71  \n   72              /* Re-Enable writing */\n   73:             if (0 != ( status = generic_sflash_command( handle, SFLASH_WRITE_ENABLE, 0, NULL, 0, NULL, NULL ) ) )\n   74              {\n   75                  return status;\n   ..\n   91          return status;\n   92      }\n   93:     return generic_sflash_command( handle, SFLASH_CHIP_ERASE1, 0, NULL, 0, NULL, NULL );\n   94  }\n   95  \n   ..\n  107          return status;\n  108      }\n  109:     retval = generic_sflash_command( handle, SFLASH_SECTOR_ERASE, 3, device_address_array, 0, NULL, NULL );\n  110      check_string(retval == 0, \"SPI Flash erase error\");\n  111      return retval;\n  ...\n  114  int sflash_read_status_register( const sflash_handle_t* const handle, void* const dest_addr )\n  115  {\n  116:     return generic_sflash_command( handle, SFLASH_READ_STATUS_REGISTER, 0, NULL, 1, NULL, dest_addr );\n  117  }\n  118  \n  ...\n  125                                        ( ( device_address & 0x000000FF ) >>  0 ) };\n  126  \n  127:     return generic_sflash_command( handle, SFLASH_READ, 3, device_address_array, size, NULL, data_addr );\n  128  }\n  129  \n  ...\n  264          }\n  265  \n  266:         if ( 0 != ( status = generic_sflash_command( handle, SFLASH_WRITE, 3, curr_device_address, write_size, data_addr_ptr, NULL ) ) )\n  267          {\n  268              return status;\n  ...\n  375      {\n  376          int status;\n  377:         if ( 0 != ( status = generic_sflash_command( handle, SFLASH_ENABLE_WRITE_STATUS_REGISTER, 0, NULL, 0, NULL, NULL ) ) )\n  378          {\n  379              return status;\n  ...\n  382  #endif /* ifdef SFLASH_SUPPORT_SST_PARTS */\n  383  \n  384:     return generic_sflash_command( handle, SFLASH_WRITE_STATUS_REGISTER, 0, NULL, 1, &status_register_val, NULL );\n  385  }\n  386  \n  ...\n  436                                                                   sflash_command_t             cmd,\n  437                                                                   unsigned long                num_initial_parameter_bytes,\n  438:                             /*@null@*/ /*@observer@*/            const void* const            parameter_bytes,\n  439                                                                   unsigned long                num_data_bytes,\n  440:                             /*@null@*/ /*@observer@*/            const void* const            data_MOSI,\n  441:                             /*@null@*/ /*@out@*/ /*@dependent@*/ void* const                  data_MISO )\n  442  {\n  443      int status;\n  ...\n  445      sflash_platform_message_segment_t segments[3] =\n  446      {\n  447:             { &cmd,            NULL,       (unsigned long) 1 },\n  448:             { parameter_bytes, NULL,       num_initial_parameter_bytes },\n  449              /*@-compdef@*/ /* Lint: Tell lint that it is OK that data_MISO is not completely defined */\n  450              { data_MOSI,       data_MISO,  num_data_bytes }\n\n/Users/William/Develop/MiCO/Platform/Drivers/spi_flash/spi_flash_internal.h:\n  105  int sflash_read_status_register ( const sflash_handle_t* handle, void* dest_addr );\n  106  int sflash_write_status_register( const sflash_handle_t* handle, char value );\n  107: int generic_sflash_command      ( const sflash_handle_t* handle, sflash_command_t cmd, unsigned long num_initial_parameter_bytes, /*@null@*/ /*@observer@*/ const void* parameter_bytes, unsigned long num_data_bytes, /*@null@*/ /*@observer@*/ const void* const data_MOSI, /*@null@*/ /*@out@*/ /*@dependent@*/ void* const data_MISO );\n  108  \n  109  \n\n/Users/William/Develop/MiCO/Platform/Drivers/spi_flash/spi_flash_platform.c:\n   45      }\n   46  \n   47:     if( platform_peripheral_out != NULL)\n   48:       *platform_peripheral_out = NULL;\n   49      \n   50      return 0;\n\n/Users/William/Develop/MiCO/Platform/Drivers/spi_flash/spi_flash_platform_interface.h:\n   43   typedef struct\n   44   {\n   45:      /*@null@*/ /*@observer@*/  const void*   tx_buffer;\n   46:      /*@null@*/ /*@dependent@*/ void*         rx_buffer;\n   47                                  unsigned long length;\n   48   } sflash_platform_message_segment_t;\n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Class/AUDIO/Src/usbh_audio.c:\n  172    USBH_AUDIO_Process,\n  173    USBH_AUDIO_SOFProcess,\n  174:   NULL,\n  175  };\n  176  \n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Class/CDC/Src/usbh_cdc.c:\n  126    USBH_CDC_Process,\n  127    USBH_CDC_SOFProcess,\n  128:   NULL,\n  129  };\n  130  /**\n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Class/HID/Src/usbh_hid.c:\n  118    USBH_HID_Process,\n  119    USBH_HID_SOFProcess,\n  120:   NULL,\n  121  };\n  122  /**\n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Class/HID/Src/usbh_hid_keybd.c:\n  353   else\n  354   {\n  355:   return NULL; \n  356   }  \n  357  }\n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Class/HID/Src/usbh_hid_mouse.c:\n  210   else\n  211   {\n  212:   return NULL; \n  213   }\n  214  }\n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Class/MSC/Src/usbh_msc.c:\n  119    USBH_MSC_Process,\n  120    USBH_MSC_SOFProcess,\n  121:   NULL,\n  122  };\n  123  \n  ...\n  524   \n  525    case MSC_READ: \n  526:     scsi_status = USBH_MSC_SCSI_Read(phost,lun, 0, NULL, 0) ;\n  527      \n  528      if(scsi_status == USBH_OK)\n  ...\n  546      \n  547    case MSC_WRITE: \n  548:     scsi_status = USBH_MSC_SCSI_Write(phost,lun, 0, NULL, 0) ;\n  549      \n  550      if(scsi_status == USBH_OK)\n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Class/MTP/Src/usbh_mtp.c:\n  125    USBH_MTP_Process,\n  126    USBH_MTP_SOFProcess,\n  127:   NULL,\n  128  };\n  129  /**\n  ...\n  168      MTP_Handle =  phost->pActiveClass->pData; \n  169      \n  170:     if( MTP_Handle == NULL)\n  171      {\n  172        status = USBH_FAIL;  \n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Core/Inc/usbh_def.h:\n   44  #include \"usbh_conf.h\"\n   45  \n   46: #ifndef NULL\n   47: #define NULL ((void *)0)\n   48  #endif\n   49  \n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Core/Src/usbh_core.c:\n   97  {\n   98    /* Check whether the USB Host handle is valid */\n   99:   if(phost == NULL)\n  100    {\n  101      USBH_ErrLog(\"Invalid Host handle\");\n  ...\n  107    \n  108    /* Unlink class*/\n  109:   phost->pActiveClass = NULL;\n  110    phost->ClassNumber = 0;\n  111    \n  ...\n  114    \n  115    /* Assign User process */\n  116:   if(pUsrFunc != NULL)\n  117    {\n  118      phost->pUser = pUsrFunc;\n  ...\n  122    \n  123    /* Create USB Host Queue */\n  124:   mico_rtos_init_queue( (mico_queue_t *) &(phost->os_event), NULL, sizeof(uint16_t), 10 );\n  125    \n  126    /*Create USB Host Task */\n  127:   mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"USBH\", USBH_Process_OS, 0x4C0, (void*)phost );\n  128    phost->thread = osThreadId1;\n  129  #endif  \n  ...\n  144    DeInitStateMachine(phost);\n  145    \n  146:   if(phost->pData != NULL)\n  147    {\n  148:     phost->pActiveClass->pData = NULL;\n  149      USBH_LL_Stop(phost);\n  150    }\n  ...\n  487      {\n  488        /* user callback for end of device basic enumeration */\n  489:       if(phost->pUser != NULL)\n  490        {\n  491          phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);\n  ...\n  518      else\n  519      {\n  520:       phost->pActiveClass = NULL;\n  521        \n  522        for (idx = 0; idx < USBH_MAX_NUM_SUPPORTED_CLASS ; idx ++)\n  ...\n  528        }\n  529        \n  530:       if(phost->pActiveClass != NULL)\n  531        {\n  532          if(phost->pActiveClass->Init(phost)== USBH_OK)\n  ...\n  559      /* process class standard contol requests state machine */ \n  560      \n  561:     if(phost->pActiveClass != NULL)\n  562      {\n  563        status = phost->pActiveClass->Requests(phost);\n  ...\n  581    case HOST_CLASS:   \n  582      /* process class state machine */\n  583:     if(phost->pActiveClass != NULL)\n  584      { \n  585        phost->pActiveClass->BgndProcess(phost);\n  ...\n  592      \n  593      /* Re-Initilaize Host for new Enumeration */\n  594:     if(phost->pActiveClass != NULL)\n  595      {\n  596        phost->pActiveClass->DeInit(phost); \n  597:       phost->pActiveClass = NULL;\n  598      }     \n  599      break;\n  ...\n  819  void  USBH_HandleSof  (USBH_HandleTypeDef *phost)\n  820  {\n  821:   if((phost->gState == HOST_CLASS)&&(phost->pActiveClass != NULL))\n  822    {\n  823      phost->pActiveClass->SOFProcess(phost);\n  ...\n  837      phost->gState = HOST_IDLE ;\n  838      \n  839:     if(phost->pUser != NULL)\n  840      {    \n  841        phost->pUser(phost, HOST_USER_CONNECTION);\n  ...\n  870    phost->device.is_connected = 0; \n  871     \n  872:   if(phost->pUser != NULL)\n  873    {    \n  874      phost->pUser(phost, HOST_USER_DISCONNECTION);\n\n/Users/William/Develop/MiCO/Platform/Drivers/STM32_USB_Host_Library/Core/Src/usbh_ctlreq.c:\n  478    uint16_t idx;\n  479    \n  480:   /* The UNICODE string descriptor is not NULL-terminated. The string length is\n  481    computed by substracting two from the value of the first byte of the descriptor.\n  482    */\n\n/Users/William/Develop/MiCO/Platform/MCU/mico_platform_common.c:\n  333      return kUnsupportedErr;\n  334  \n  335:   if( platform_spi_drivers[spi->port].spi_mutex == NULL)\n  336      mico_rtos_init_mutex( &platform_spi_drivers[spi->port].spi_mutex );\n  337    \n  ...\n  355      return kUnsupportedErr;\n  356  \n  357:   if( platform_spi_drivers[spi->port].spi_mutex == NULL)\n  358      mico_rtos_init_mutex( &platform_spi_drivers[spi->port].spi_mutex );\n  359    \n  ...\n  373      return kUnsupportedErr;\n  374    \n  375:   if( platform_spi_drivers[spi->port].spi_mutex == NULL)\n  376      mico_rtos_init_mutex( &platform_spi_drivers[spi->port].spi_mutex );\n  377    \n  ...\n  507  {\n  508    if( (inPartition < 0) || (inPartition >= MICO_PARTITION_MAX))\n  509:     return NULL;\n  510    else\n  511      return (mico_logic_partition_t *)&mico_partitions[ inPartition ];\n  ...\n  521    require_action_quiet( mico_partitions[ partition ].partition_owner != MICO_FLASH_NONE, exit, err = kNotFoundErr );\n  522    \n  523:   if( platform_flash_drivers[ mico_partitions[ partition ].partition_owner ].flash_mutex == NULL){\n  524      err = mico_rtos_init_mutex( &platform_flash_drivers[ mico_partitions[ partition ].partition_owner ].flash_mutex );\n  525      require_noerr( err, exit );\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/platform_adc.c:\n  115    platform_mcu_powersave_disable();\n  116    \n  117:   require_action_quiet( adc != NULL, exit, err = kParamErr);\n  118    \n  119    if( initialized != true )\n  ...\n  145    platform_mcu_powersave_disable();\n  146    \n  147:   require_action_quiet( adc != NULL, exit, err = kParamErr);\n  148    \n  149    channel_num = adc->channel;\n  ...\n  183    platform_mcu_powersave_disable();\n  184    \n  185:   require_action_quiet( adc != NULL, exit, err = kParamErr);\n  186    \n  187    adc_disable();\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/platform_flash.c:\n  102    OSStatus err = kNoErr;\n  103  \n  104:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  105  \n  106    if( peripheral->flash_type == FLASH_TYPE_EMBEDDED ){\n  ...\n  126    OSStatus err = kNoErr;\n  127  \n  128:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  129    require_action( start_address >= peripheral->flash_start_addr \n  130                 && end_address   <= peripheral->flash_start_addr + peripheral->flash_length - 1, exit, err = kParamErr);\n  ...\n  153    OSStatus err = kNoErr;\n  154  \n  155:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  156    require_action( *start_address >= peripheral->flash_start_addr \n  157                 && *start_address + length <= peripheral->flash_start_addr + peripheral->flash_length, exit, err = kParamErr);\n  ...\n  181    OSStatus err = kNoErr;\n  182  \n  183:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  184    require_action( (*start_address >= peripheral->flash_start_addr) \n  185                 && (*start_address + length) <= ( peripheral->flash_start_addr + peripheral->flash_length), exit, err = kParamErr);\n  ...\n  209    OSStatus err = kNoErr;\n  210  \n  211:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  212    require_action( start_address >= peripheral->flash_start_addr \n  213                 && end_address   <= peripheral->flash_start_addr + peripheral->flash_length - 1, exit, err = kParamErr);\n  ...\n  238    OSStatus err = kNoErr;\n  239  \n  240:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  241    require_action( start_address >= peripheral->flash_start_addr \n  242                 && end_address   <= peripheral->flash_start_addr + peripheral->flash_length - 1, exit, err = kParamErr);\n  ...\n  298    }\n  299  \n  300:   require_action( flash_lock( start_address, end_address, NULL, NULL ) == FLASH_RC_OK, exit, err = kGeneralErr );\n  301  \n  302  exit:\n  ...\n  316  \n  317    //mem_flash_op_enter();\n  318:   require_action( flash_unlock( start_address, start_address + data_length - 1, NULL, NULL ) == FLASH_RC_OK, exit, err = kGeneralErr );\n  319  \n  320    require_action( flash_write((*flash_address), data, data_length, false) == FLASH_RC_OK, exit, err = kGeneralErr );\n  321    *flash_address += data_length;\n  322  \n  323:   require_action( flash_lock( start_address, start_address + data_length - 1, NULL, NULL ) == FLASH_RC_OK, exit, err = kGeneralErr );\n  324    //mem_flash_op_exit();\n  325  \n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/platform_gpio.c:\n   98    \n   99    platform_mcu_powersave_disable();\n  100:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  101    \n  102    switch ( config )\n  ...\n  158  \n  159    platform_mcu_powersave_disable( );\n  160:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  161  \n  162    /* Set pin mode and disable GPIO peripheral */\n  ...\n  174  \n  175    platform_mcu_powersave_disable();\n  176:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  177    \n  178    ioport_disable_pin( gpio->pin );\n  ...\n  187    OSStatus err = kNoErr;\n  188    \n  189:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  190    platform_mcu_powersave_disable();\n  191    \n  ...\n  201    OSStatus err = kNoErr;\n  202    \n  203:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  204    platform_mcu_powersave_disable();\n  205    \n  ...\n  215    OSStatus err = kNoErr;\n  216    \n  217:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  218    platform_mcu_powersave_disable();\n  219    \n  ...\n  231    platform_mcu_powersave_disable();\n  232    \n  233:   require_quiet( gpio != NULL, exit);\n  234    \n  235    result = ( ioport_get_pin_level( gpio->pin ) == false ) ? false : true;\n  ...\n  251      \n  252    platform_mcu_powersave_disable();\n  253:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  254  \n  255    NVIC_DisableIRQ( irq_vectors[port] );\n  ...\n  312    \n  313    platform_mcu_powersave_disable();\n  314:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  315  \n  316    /* Disable interrupt on pin */\n  ...\n  325    gpio_irq_data[port][mask].wakeup_pin = false;\n  326    gpio_irq_data[port][mask].arg        = 0;\n  327:   gpio_irq_data[port][mask].callback   = NULL;\n  328    \n  329  exit:\n  ...\n  360      for ( iter = 0; iter < PINS_PER_PORT; iter++, status >>= 1, mask >>= 1 )\n  361      {\n  362:           if ( ( ( mask & 0x1 ) != 0 ) && ( ( status & 0x1 ) != 0 ) && ( gpio_irq_data[port][iter].callback != NULL ) )\n  363            {\n  364                if ( gpio_irq_data[port][iter].wakeup_pin == true )\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/platform_i2c.c:\n   78    \n   79    platform_mcu_powersave_disable( );\n   80:   require_action_quiet( i2c != NULL, exit, err = kParamErr);\n   81    \n   82    twi_options_t     twi_slave_config;\n   ..\n  166    platform_mcu_powersave_disable();\n  167    /* Check input arguments */\n  168:   require_action_quiet( (i2c != NULL) && ( config != NULL ) &&( messages != NULL ) && ( number_of_messages != 0 ), exit, err = kParamErr );\n  169    \n  170    for ( i = 0; i < number_of_messages && err == kNoErr; i++ )\n  171    {\n  172      platform_i2c_message_t* message_pointer = &messages[i];\n  173:     check_string( message_pointer != NULL, \"Message pointer shouldn't be null\" );\n  174      for ( retry_count = 0; retry_count < message_pointer->retries; retry_count++ )\n  175      {\n  176        err = kNoErr;\n  177        \n  178:       if ( message_pointer->tx_buffer != NULL )\n  179        {\n  180          /** Get the extension boards info */\n  ...\n  190        \n  191        \n  192:       if (   message_pointer->rx_buffer != NULL )\n  193        {\n  194          /** Get the extension boards info */\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/platform_rng.c:\n   67      uint32_t *pWord = inBuffer;\n   68      uint32_t tempRDM;\n   69:     uint8_t *pByte = NULL;\n   70      int inWordCount;\n   71      int remainByteCount;\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/platform_spi.c:\n   70    platform_mcu_powersave_disable( );\n   71  \n   72:   require_action_quiet( ( driver != NULL ) && ( peripheral != NULL ) && ( config != NULL ), exit, err = kParamErr);\n   73  \n   74    driver->peripheral = (platform_spi_t *)peripheral;\n   ..\n   94    pdc_spi_packet.ul_addr = 0;\n   95    pdc_spi_packet.ul_size = 1;\n   96:   pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL );\n   97:   pdc_rx_init( spi_pdc, &pdc_spi_packet, NULL );\n   98  \n   99    /* Configure an SPI peripheral. */\n  ...\n  140  \n  141    /* Send and read */\n  142:   if( data_in != NULL && data_out != NULL )\n  143    {\n  144      pdc_spi_packet.ul_addr = (uint32_t)data_in;\n  145      pdc_spi_packet.ul_size = (uint32_t)data_length;\n  146:     pdc_rx_init( spi_pdc, &pdc_spi_packet, NULL );  \n  147  \n  148      pdc_spi_packet.ul_addr = (uint32_t)data_out;\n  149      pdc_spi_packet.ul_size = (uint32_t)data_length;\n  150:     pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL );  \n  151  \n  152      /* Enable the RX and TX PDC transfer requests */\n  ...\n  163      pdc_spi_packet.ul_addr = 0;\n  164      pdc_spi_packet.ul_size = 1;\n  165:     pdc_rx_init( spi_pdc, &pdc_spi_packet, NULL ); \n  166:     pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL );  \n  167    }\n  168    /* Send Only */\n  169:   else if( data_in == NULL && data_out != NULL)  \n  170    {\n  171      pdc_spi_packet.ul_addr = (uint32_t)data_out;\n  172      pdc_spi_packet.ul_size = (uint32_t)data_length;\n  173:     pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL ); \n  174  \n  175      /* Enable the TX PDC transfer requests */\n  ...\n  186      pdc_spi_packet.ul_addr = 0;\n  187      pdc_spi_packet.ul_size = 1;\n  188:     pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL );  \n  189  \n  190      spi_read( spi->port, &junk2, &junk3);\n  191    }\n  192    /* Read Only */\n  193:   else if( data_in != NULL && data_out == NULL)\n  194    {\n  195      pdc_spi_packet.ul_addr = (uint32_t)data_in;\n  196      pdc_spi_packet.ul_size = (uint32_t)data_length;\n  197:     pdc_rx_init( spi_pdc, &pdc_spi_packet, NULL );  \n  198  \n  199      pdc_spi_packet.ul_addr = (uint32_t)data_in;\n  200      pdc_spi_packet.ul_size = (uint32_t)data_length;\n  201:     pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL );  \n  202  \n  203      /* Enable the RX and TX PDC transfer requests */\n  ...\n  214      pdc_spi_packet.ul_addr = 0;\n  215      pdc_spi_packet.ul_size = 1;\n  216:     pdc_rx_init( spi_pdc, &pdc_spi_packet, NULL ); \n  217:     pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL );  \n  218    }\n  219  \n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/platform_uart.c:\n   89    platform_mcu_powersave_disable();\n   90    \n   91:   require_action_quiet( ( driver != NULL ) && ( peripheral != NULL ) && ( config != NULL ), exit, err = kParamErr);\n   92:   require_action_quiet( (optional_ring_buffer->buffer != NULL ) && (optional_ring_buffer->size != 0), exit, err = kUnsupportedErr);\n   93    \n   94    driver->rx_size              = 0;\n   ..\n  113  \n  114    /* Init CTS and RTS pins (if available) */\n  115:   if ( peripheral->cts_pin != NULL && (config->flow_control == FLOW_CONTROL_CTS || config->flow_control == FLOW_CONTROL_CTS_RTS) )\n  116    {\n  117      hardware_shaking = true;\n  ...\n  119    }\n  120  \n  121:   if ( peripheral->rts_pin != NULL && (config->flow_control == FLOW_CONTROL_CTS || config->flow_control == FLOW_CONTROL_CTS_RTS) )\n  122    {\n  123      hardware_shaking = true;\n  ...\n  198    pdc_uart_tx_packet.ul_size = (uint32_t)1;\n  199  \n  200:   pdc_tx_init( usart_get_pdc_base( driver->peripheral->port ), &pdc_uart_tx_packet, NULL );\n  201  \n  202    usart_enable_interrupt( peripheral->port, US_IER_ENDRX | US_IER_RXBUFF | US_IER_RXRDY | US_IER_ENDTX );\n  ...\n  216    \n  217    platform_mcu_powersave_disable();\n  218:   require_action_quiet( ( driver != NULL ), exit, err = kParamErr);\n  219    \n  220    usart_disable_interrupt( driver->peripheral->port, 0xffffffff );\n  ...\n  234    platform_gpio_deinit( driver->peripheral->rx_pin );\n  235  \n  236:   if ( driver->peripheral->cts_pin != NULL )\n  237    {\n  238      platform_gpio_deinit( driver->peripheral->cts_pin );\n  239    }\n  240  \n  241:   if ( driver->peripheral->rts_pin != NULL )\n  242    {\n  243      platform_gpio_deinit( driver->peripheral->rts_pin );\n  ...\n  249  #endif\n  250  \n  251:   driver->peripheral = NULL;\n  252    memset( driver, 0, sizeof(platform_uart_driver_t) );\n  253    \n  ...\n  268  #endif\n  269    \n  270:   require_action_quiet( ( driver != NULL ) && ( data_out != NULL ) && ( size != 0 ), exit, err = kParamErr);\n  271    \n  272    /* reset DMA transmission result. the result is assigned in interrupt handler */\n  ...\n  276    pdc_uart_packet.ul_addr = (uint32_t) data_out;\n  277    pdc_uart_packet.ul_size = size;\n  278:   pdc_tx_init( usart_get_pdc_base( driver->peripheral->port ), &pdc_uart_packet, NULL);\n  279  \n  280    /* Enable Tx DMA transmission */\n  ...\n  303    //platform_mcu_powersave_disable();\n  304  \n  305:   require_action_quiet( ( driver != NULL ) && ( data_in != NULL ) && ( expected_data_size != 0 ), exit, err = kParamErr);\n  306:   require_action_quiet( driver->rx_ring_buffer != NULL , exit, err = kUnsupportedErr);\n  307  \n  308    while ( expected_data_size != 0 )\n  ...\n  393      dma_packet.ul_size = (uint32_t)1;\n  394  \n  395:     pdc_tx_init( usart_get_pdc_base( driver->peripheral->port ), &dma_packet, NULL );\n  396  \n  397      /* Notifies waiting thread that Tx DMA transfer is complete */\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/boards/sensors_xplained/sensors_xplained.c:\n  278   * interrupt is detected.  The \\c arg parameter is used to pass the address\n  279   * of user-defined input and output storage for the callback handler.  Calling\n  280:  * the routine with the \\c handler parameter set to 0 (the NULL pointer) will\n  281   * fail with \\c false returned to the caller.\n  282   *\n  ...\n  298  	/* Ensure that the caller has specified a function address. */\n  299  \n  300: 	if (handler == NULL) {\n  301  		return status;\n  302  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/boards/sensors_xplained/sensors_xplained.h:\n  445   * interrupt is detected.  The \\c arg parameter is used to pass the address\n  446   * of user-defined input and output storage for the callback handler.  Calling\n  447:  * the routine with the \\c handler parameter set to 0 (the NULL pointer) will\n  448   * fail with \\c false returned to the caller.\n  449   *\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/services/clock/mega/sysclk.h:\n  394  static inline void sysclk_enable_peripheral_clock(const volatile void *module)\n  395  {\n  396: 	if (module == NULL) {\n  397  		Assert(false);\n  398  	}\n  ...\n  461  static inline void sysclk_disable_peripheral_clock(const volatile void *module)\n  462  {\n  463: 	if (module == NULL) {\n  464  		Assert(false);\n  465  	}\n  ...\n  602  static inline uint32_t sysclk_get_peripheral_bus_hz(const volatile void *module)\n  603  {\n  604: 	if (module == NULL) {\n  605  		Assert(false);\n  606  		return 0;\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/services/clock/xmega/sysclk.h:\n  620  static inline uint32_t sysclk_get_peripheral_bus_hz(const volatile void *module)\n  621  {\n  622: 	if (module == NULL) {\n  623  		Assert(false);\n  624  		return 0;\n  ...\n  901  static inline void sysclk_enable_peripheral_clock(const volatile void *module)\n  902  {\n  903: 	if (module == NULL) {\n  904  		Assert(false);\n  905  	}\n  ...\n 1147  static inline void sysclk_disable_peripheral_clock(const volatile void *module)\n 1148  {\n 1149: 	if (module == NULL) {\n 1150  		Assert(false);\n 1151  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/services/ioport/unit_tests/unit_tests.c:\n  196  	stdio_serial_init(CONF_TEST_USART, &usart_serial_options);\n  197  \n  198: 	DEFINE_TEST_CASE(ioport_port_test, NULL, run_ioport_port_test, NULL,\n  199  			\"Test setting of various IOPORT functions\");\n  200: 	DEFINE_TEST_CASE(ioport_pin_test, NULL, run_ioport_pin_test, NULL,\n  201  			\"Test IOPORT pin level is getting changed\");\n  202  \n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/utils/membag/membag.c:\n  176  {\n  177  	uint8_t i;\n  178: 	struct membag *smallest_bag = NULL;\n  179  \n  180  	for (i = 0; i < ARRAY_LEN(membag_list); i++) {\n  ...\n  207  {\n  208  	uint8_t i;\n  209: 	struct membag *largest_bag = NULL;\n  210  \n  211  	for (i = 0; i < ARRAY_LEN(membag_list); i++) {\n  ...\n  242   *\n  243   * \\return Pointer to the start of an allocated block if one was found in the\n  244:  *         Membag pool, NULL if no suitable block was found.\n  245   */\n  246  void *membag_alloc(const size_t size)\n  247  {\n  248  	uint8_t i;\n  249: 	struct membag *smallest_bag = NULL;\n  250  	uintptr_t p;\n  251  \n  ...\n  266  \n  267  	/* We return the first available block in the bag that has one, and if\n  268: 	 * there is none, we return NULL.\n  269  	 */\n  270  	if (smallest_bag) {\n  ...\n  289  	}\n  290  \n  291: 	/* There is no available memory. Return NULL. */\n  292: 	return NULL;\n  293  }\n  294  \n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/utils/membag/unit_tests/unit_tests.c:\n  115  	data = membag_alloc(CONF_TEST_ALLOC_SIZE_SMALL);\n  116  \n  117: 	test_assert_false(test, data == NULL,\n  118  			\"Unable to allocate a small chunk!\");\n  119  \n  ...\n  124  	data = membag_alloc(CONF_TEST_ALLOC_SIZE_LARGE);\n  125  \n  126: 	test_assert_false(test, data == NULL,\n  127  			\"Unable to allocate a large chunk!\");\n  128  \n  ...\n  130  	data = membag_alloc(CONF_TEST_ALLOC_SIZE_TOO_LARGE);\n  131  \n  132: 	test_assert_true(test, data == NULL,\n  133  			\"Should not be able to allocate a too-large chunk!\");\n  134  }\n  ...\n  152  \n  153  	/* Check that all three membag allocations completed successfully. */\n  154: 	test_assert_false(test, (data1 == NULL) || (data2 == NULL) ||\n  155: 			(data3 == NULL),\n  156  			\"Less than three small chunks were allocated!\");\n  157  \n  ...\n  196  		/* Allocate the next largest block sized chunk of memory */\n  197  		data = membag_alloc(chunk_size);\n  198: 		test_assert_false(test, data == NULL,\n  199  				\"Unable to allocate a block sized chunk!\");\n  200  \n  ...\n  224  		data = membag_alloc(CONF_TEST_ALLOC_SIZE_SMALL);\n  225  \n  226: 		test_assert_false(test, data == NULL,\n  227  				\"Unable to allocate a small chunk!\");\n  228  	}\n  ...\n  231  	data = membag_alloc(CONF_TEST_ALLOC_SIZE_SMALL);\n  232  \n  233: 	test_assert_true(test, data == NULL,\n  234  			\"Should not be able to allocate small chunk while full!\");\n  235  \n  ...\n  242  		data = membag_alloc(CONF_TEST_ALLOC_SIZE_LARGE);\n  243  \n  244: 		test_assert_false(test, data == NULL,\n  245  				\"Unable to allocate a large chunk!\");\n  246  	}\n  ...\n  249  	data = membag_alloc(CONF_TEST_ALLOC_SIZE_LARGE);\n  250  \n  251: 	test_assert_true(test, data == NULL,\n  252  			\"Should not be able to allocate large chunk while full!\");\n  253  }\n  ...\n  270  		data = membag_alloc(CONF_TEST_ALLOC_SIZE_SMALL);\n  271  \n  272: 		test_assert_false(test, data == NULL,\n  273  				\"Unable to allocate a small chunk!\");\n  274  	}\n  ...\n  281  	data = membag_alloc(CONF_TEST_ALLOC_SIZE_SMALL);\n  282  \n  283: 	test_assert_false(test, data == NULL,\n  284  			\"Unable to re-allocate a small chunk!\");\n  285  }\n  ...\n  305  #endif\n  306  \n  307: 	DEFINE_TEST_CASE(membag_init_test, NULL, run_membag_init_test,\n  308: 			NULL, \"Test membag initialization\");\n  309: 	DEFINE_TEST_CASE(membag_alloc_test, NULL, run_membag_alloc_test,\n  310: 			NULL, \"Test membag memory allocation\");\n  311: 	DEFINE_TEST_CASE(membag_free_test, NULL, run_membag_free_test,\n  312: 			NULL, \"Test membag memory freeing\");\n  313: 	DEFINE_TEST_CASE(membag_get_test, NULL, run_membag_get_test,\n  314: 			NULL, \"Test membag get functions\");\n  315: 	DEFINE_TEST_CASE(membag_alloc_when_full_test, NULL,\n  316: 			run_membag_alloc_when_full_test, NULL,\n  317  			\"Test membag allocation when all membags are full\");\n  318: 	DEFINE_TEST_CASE(membag_realloc_test, NULL, run_membag_realloc_test,\n  319: 			NULL, \"Test membag allocation and reallocation\");\n  320  \n  321  	DEFINE_TEST_ARRAY(membag_tests) = {\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/utils/stdio/stdio_serial/stdio_serial.h:\n  113  	// For AVR32 and SAM GCC\n  114  	// Specify that stdout and stdin should not be buffered.\n  115: 	setbuf(stdout, NULL);\n  116: 	setbuf(stdin, NULL);\n  117  	// Note: Already the case in IAR's Normal DLIB default configuration\n  118  	// and AVR GCC library:\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/utils/stdio/stdio_usb/stdio_usb.c:\n   91  void stdio_usb_init(void)\n   92  {\n   93: 	stdio_base = NULL;\n   94  	ptr_put = stdio_usb_putchar;\n   95  	ptr_get = stdio_usb_getchar;\n   ..\n  110  	// For AVR32 and SAM GCC\n  111  	// Specify that stdout and stdin should not be buffered.\n  112: 	setbuf(stdout, NULL);\n  113: 	setbuf(stdin, NULL);\n  114  	// Note: Already the case in IAR's Normal DLIB default configuration\n  115  	// and AVR GCC library:\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/utils/unit_test/suite.c:\n   78   * \\see test_set_case(), test_get_case()\n   79   */\n   80: struct test_case *test_case_ptr = NULL;\n   81  \n   82  /**\n   ..\n  188  // Test is done, clear the stored test pointer\n  189  #if defined(_ASSERT_ENABLE_) && defined(TEST_SUITE_DEFINE_ASSERT_MACRO)\n  190: 	test_set_case(NULL);\n  191  #endif\n  192  \n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/common/utils/unit_test/suite.h:\n  105  	 		\"First test\");\n  106  	 DEFINE_TEST_CASE(test_2,\n  107: 	 		NULL,\n  108  	 		run_2,\n  109: 	 		NULL,\n  110  	 		\"Second test\");\n  111  \n  ...\n  127  	 	void *resource = allocate_test_resource();\n  128  \n  129: 	 	if (resource == NULL) {\n  130  	 		test_fail(test, TEST_ERROR,\n  131  	 			\"Could not allocate test resource\");\n  ...\n  242   *\n  243   * \\param _sym Variable name of the resulting struct\n  244:  * \\param _setup Function which sets up a test case environment. Can be NULL.\n  245   * \\param _run Test function\n  246:  * \\param _cleanup Function which cleans up what was set up. Can be NULL.\n  247   * \\param _name String describing the test case.\n  248   */\n  ...\n  441  #  define Assert(expr) \\\n  442   	{ \\\n  443:  		if (test_get_case() != NULL) { \\\n  444   			test_assert_true(test_get_case(), expr, \\\n  445   					\"Assertion failed: %s\", #expr); \\\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/adc/adc2.h:\n  680  static inline Pdc *adc_get_pdc_base(Adc *const adc)\n  681  {\n  682: 	Pdc *p_pdc_base = NULL;\n  683  \n  684  	if (adc == ADC) {\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/adcife/adcife.c:\n  164  		.size = cfg->wm == true ? (cfg->nb_channels)*2 : cfg->nb_channels,\n  165  		/* next memory address */\n  166: 		.r_addr = NULL,\n  167  		/* next transfer counter */\n  168  		.r_size = 0,\n  ...\n  178  		.size = cfg->nb_channels,\n  179  		/* next memory address */\n  180: 		.r_addr = NULL,\n  181  		/* next transfer counter */\n  182  		.r_size = 0,\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/adcife/adcife.h:\n  491  	cfg->wm                       = false;\n  492  	cfg->nb_channels              = 0;\n  493: 	cfg->buffer                   = NULL;\n  494  	cfg->pdc_rx_channel           = CONFIG_ADC_PDCA_RX_CHANNEL;\n  495  	cfg->pdc_rx_channel           = CONFIG_ADC_PDCA_TX_CHANNEL;\n  496  \n  497: 	cfg->cdma_cfg                 = NULL;\n  498  }\n  499  \n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/aes/aes.c:\n  328  		p_pdc_base = PDC_AES;\n  329  	} else {\n  330: 		p_pdc_base = NULL;\n  331  	}\n  332  \n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/afec/afec.h:\n  609  static inline Pdc *afec_get_pdc_base(Afec *const afec)\n  610  {\n  611: 	Pdc *p_pdc_base = NULL;\n  612  \n  613  #ifdef PDC_AFEC0\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/chipid/chipid.c:\n   93  uint32_t chipid_read(Chipid *p_chipid, chipid_data_t *p_chipid_data)\n   94  {\n   95: 	if (NULL == p_chipid_data) {\n   96  		return 0xFFFFFFFF;\n   97  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/efc/efc.c:\n  314  #endif\n  315  \n  316: 	if (p_ul_buf == NULL) {\n  317  		return EFC_RC_INVALID;\n  318  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/emac/emac.c:\n  242  		emac_dev_tx_cb_t* p_tx_cb)\n  243  {\n  244: 	if (p_dev_mm->us_rx_size <= 1 || p_dev_mm->us_tx_size <= 1 || p_tx_cb == NULL) {\n  245  		return EMAC_PARAM;\n  246  	}\n  ...\n  414  	int8_t c_is_frame = 0;\n  415  \n  416: 	if (p_frame == NULL)\n  417  		return EMAC_PARAM;\n  418  \n  ...\n  451  				} while (us_tmp_idx != p_emac_dev->us_rx_idx);\n  452  \n  453: 				return EMAC_RX_NULL;\n  454  			}\n  455  			/* Copy the buffer into the application frame */\n  ...\n  495  	}\n  496  \n  497: 	return EMAC_RX_NULL;\n  498  }\n  499  \n  ...\n  586   * frame.\n  587   *\n  588:  * When emac_dev_read() returns EMAC_RX_NULL, the application task calls\n  589   * emac_dev_set_rx_callback() to register func_rx_cb() callback and enters suspend state.\n  590   * The callback is in charge to resume the task once a new frame has been\n  591   * received. The next time emac_dev_read() is called, it will be successful.\n  592   *\n  593:  * This function is usually invoked from the RX callback itself with NULL\n  594   * callback, to unregister. Once the callback has resumed the application task,\n  595   * there is no need to invoke the callback again.\n  ...\n  603  	Emac *p_hw = p_emac_dev->p_hw;\n  604  \n  605: 	if (func_rx_cb == NULL) {\n  606  		emac_disable_interrupt(p_hw, EMAC_IDR_RCOMP);\n  607: 		p_emac_dev->func_rx_cb = NULL;\n  608  	} else {\n  609  		p_emac_dev->func_rx_cb = func_rx_cb;\n  ...\n  621   * it shall be successful.\n  622   *\n  623:  * This function is usually invoked with NULL callback from the TX wakeup\n  624   * callback itself, to unregister. Once the callback has resumed the\n  625   * application task, there is no need to invoke the callback again.\n  ...\n  634  		emac_dev_wakeup_cb_t func_wakeup_cb, uint8_t uc_threshold)\n  635  {\n  636: 	if (func_wakeup_cb == NULL) {\n  637: 		p_emac_dev->func_wakeup_cb = NULL;\n  638  	} else {\n  639  		if (uc_threshold <= p_emac_dev->us_tx_list_size) {\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/emac/emac.h:\n  128  	EMAC_TIMEOUT = 1,    /** EMAC operation timeout */\n  129  	EMAC_TX_BUSY,        /** TX in progress */\n  130: 	EMAC_RX_NULL,        /** No data received */\n  131  	EMAC_SIZE_TOO_SMALL, /** Buffer size not enough */\n  132  	EMAC_PARAM,          /** Parameter error, TX packet invalid or RX size too small */\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/gmac/gmac_raw.c:\n  144  #ifdef FREERTOS_USED\n  145  /* Notification semaphore for lwIP stack. */\n  146: xSemaphoreHandle netif_notification_semaphore = NULL;\n  147  #endif\n  148  \n  ...\n  236  		gmac_dev_tx_cb_t* p_tx_cb)\n  237  {\n  238: 	if (p_dev_mm->us_rx_size <= 1 || p_dev_mm->us_tx_size <= 1 || p_tx_cb == NULL) {\n  239  		return GMAC_PARAM;\n  240  	}\n  ...\n  394  	int8_t c_is_frame = 0;\n  395  \n  396: 	if (p_frame == NULL)\n  397  		return GMAC_PARAM;\n  398  \n  ...\n  648   * frame.\n  649   *\n  650:  * When gmac_dev_read() returns GMAC_RX_NULL, the application task calls\n  651   * gmac_dev_set_rx_callback() to register func_rx_cb() callback and enters suspend state.\n  652   * The callback is in charge to resume the task once a new frame has been\n  653   * received. The next time gmac_dev_read() is called, it will be successful.\n  654   *\n  655:  * This function is usually invoked from the RX callback itself with NULL\n  656   * callback, to unregister. Once the callback has resumed the application task,\n  657   * there is no need to invoke the callback again.\n  ...\n  665  	Gmac *p_hw = p_gmac_dev->p_hw;\n  666  \n  667: 	if (func_rx_cb == NULL) {\n  668  		gmac_disable_interrupt(p_hw, GMAC_IDR_RCOMP);\n  669: 		p_gmac_dev->func_rx_cb = NULL;\n  670  	} else {\n  671  		p_gmac_dev->func_rx_cb = func_rx_cb;\n  ...\n  683   * it shall be successful.\n  684   *\n  685:  * This function is usually invoked with NULL callback from the TX wakeup\n  686   * callback itself, to unregister. Once the callback has resumed the\n  687   * application task, there is no need to invoke the callback again.\n  ...\n  696  		gmac_dev_wakeup_cb_t func_wakeup_cb, uint8_t uc_threshold)\n  697  {\n  698: 	if (func_wakeup_cb == NULL) {\n  699: 		p_gmac_dev->func_wakeup_cb = NULL;\n  700  	} else {\n  701  		if (uc_threshold <= p_gmac_dev->us_tx_list_size) {\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/gpio/gpio.c:\n  134  		if ((ioport_pin_to_port_id(pin) == port_id) &&\n  135  				(ioport_pin_to_mask(pin) & int_flags)) {\n  136: 			if (gpio_int_sources[i].callback != NULL) {\n  137  				gpio_int_sources[i].callback();\n  138  			} else {\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/hsmci/hsmci.c:\n  641  			| DMAC_CTRLB_DST_INCR_INCREMENTING\n  642  			| DMAC_CTRLB_IEN;\n  643: 	desc.ul_descriptor_addr = (uint32_t)NULL;\n  644  	dmac_channel_single_buf_transfer_init(DMAC, CONF_HSMCI_DMA_CHANNEL,\n  645  			&desc);\n  ...\n  724  			| DMAC_CTRLB_DST_INCR_FIXED\n  725  			| DMAC_CTRLB_IEN;\n  726: 	desc.ul_descriptor_addr = (uint32_t)NULL;\n  727  	dmac_channel_single_buf_transfer_init(DMAC, CONF_HSMCI_DMA_CHANNEL,\n  728  			&desc);\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/i2sc/i2sc.c:\n  467  Pdc *i2s_get_pdc_base(struct i2s_dev_inst *const dev_inst)\n  468  {\n  469: 	Pdc *p_pdc_base = NULL;\n  470  #ifdef PDC_I2SC1\n  471  	 if (dev_inst->hw_dev == I2SC1) {\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/lcdca/lcdca.c:\n   50  \n   51  /** \\internal LCDCA callback function pointer. */\n   52: lcdca_callback_t lcdca_callback_pointer = NULL;\n   53  \n   54  /**\n   ..\n  397   * \\brief Send a sequence of ASCII bytes to the LCDCA via the digit decoder.\n  398   *\n  399:  * \\note If a NULL byte is encountered, or if the <i>width</i> count expires,\n  400   * data will no longer be sent via the digit decoder and the function returns.\n  401   *\n  ...\n  418  	while (width--) {\n  419  		if (*data == '\\0') {\n  420: 			break; /* Stop on NULL char */\n  421  		}\n  422  \n  ...\n  606  \n  607  	/* Interrupt handler */\n  608: 	if (lcdca_callback_pointer != NULL) {\n  609  		lcdca_callback_pointer();\n  610  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/mem2mem/mem2mem.c:\n  147  	/* Initialize for Jobs */\n  148  	for (i = 0; i < M2M_CALLBACK_N; i ++) {\n  149: 		m2m->callbacks[i] = NULL;\n  150  	}\n  151  	m2m->enabled_callbacks = 0;\n  ...\n  251  	Assert(m2m);\n  252  	if (type < M2M_CALLBACK_N) {\n  253: 		m2m->callbacks[type] = NULL;\n  254  	}\n  255  }\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/parc/parc.c:\n   74  #if PARC_CALLBACK_MODE == true\n   75  	for (uint8_t i = 0; i < PARC_CALLBACK_N; i++) {\n   76: 		module_inst->callback[i] = NULL;\n   77  	}\n   78  \n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/parc/parc_callback.c:\n  132  \n  133  	/* Unregister callback function */\n  134: 	module->callback[callback_type] = NULL;\n  135  \n  136  	/* Clear the bit corresponding to the callback_type */\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/pdc/pdc.c:\n   60   * \\param[out] p_pdc        Device structure pointer\n   61   * \\param[in] p_packet      Pointer to packet information for current buffer register\n   62:  *                          set, NULL to let them as is.\n   63   * \\param[in] p_next_packet Pointer to packet information for next buffer register\n   64:  *                          set, NULL to let them as is.\n   65   */\n   66  void pdc_tx_init(\n   ..\n   87   * \\param[out] p_pdc        Device structure pointer\n   88   * \\param[in] p_packet      Pointer to packet information for current buffer register\n   89:  *                          set, NULL to let them as is.\n   90   * \\param[in] p_next_packet Pointer to packet information for next buffer register\n   91:  *                          set, NULL to let them as is.\n   92   */\n   93  void pdc_rx_init(\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/pdm/pdm.c:\n  211  	/* Initialize for Jobs */\n  212  	for (uint32_t i = 0; i < PDM_CALLBACK_N; i++) {\n  213: 		dev_inst->callbacks[i] = NULL;\n  214  	}\n  215  \n  ...\n  292  	Assert(dev_inst);\n  293  	if (type < PDM_CALLBACK_N) {\n  294: 		dev_inst->callbacks[type] = NULL;\n  295  	}\n  296  }\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/pio/pio_handler.c:\n   77  #if (SAM3S || SAM4S || SAM4E)\n   78  /* PIO Capture handler */\n   79: static void (*pio_capture_handler)(Pio *) = NULL;\n   80  extern uint32_t pio_capture_enable_flag;\n   81  #endif\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/pmc/sleep.c:\n  278  static volatile bool b_is_sleep_clock_used = false;\n  279  /** Callback invoked once when clocks are restored */\n  280: static pmc_callback_wakeup_clocks_restored_t callback_clocks_restored = NULL;\n  281  \n  282  void pmc_sleep(int sleep_mode)\n  ...\n  349  		if (callback_clocks_restored) {\n  350  			callback_clocks_restored();\n  351: 			callback_clocks_restored = NULL;\n  352  		}\n  353  		cpu_irq_enable();\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/slcdc/slcdc.c:\n   59   * \\brief SLCDC callback function pointer.\n   60   */\n   61: slcdc_callback_t slcdc_callback_pointer = NULL;\n   62  \n   63  /** The actual frame rate value */\n   ..\n  187  {\n  188  	/* Interrupt handler */\n  189: 	if (slcdc_callback_pointer != NULL) {\n  190  		slcdc_callback_pointer();\n  191  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/ssc/ssc.c:\n  398  		data_frame_opt_t *p_rx_data_frame)\n  399  {\n  400: 	if (p_rx_clk_opt == NULL) {\n  401  		p_ssc->SSC_RCMR = 0;\n  402  	} else {\n  ...\n  409  	}\n  410  \n  411: 	if (p_rx_data_frame == NULL) {\n  412  		p_ssc->SSC_RFMR = 0;\n  413  	} else {\n  ...\n  432  		data_frame_opt_t *p_tx_data_frame)\n  433  {\n  434: 	if (p_tx_clk_opt == NULL) {\n  435  		p_ssc->SSC_TCMR = 0;\n  436  	} else {\n  ...\n  443  	}\n  444  \n  445: 	if (p_tx_data_frame == NULL) {\n  446  		p_ssc->SSC_TFMR = 0;\n  447  	} else {\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/tc/tc.h:\n  360   * -# Enable the capture channel interrupt:\n  361   * \\snippet tc_capture_waveform_example.c tc_capture_init_module_irq\n  362:  * -# In the \\ref TC_Handler_null \"TC_Handler()\" function, the load.\n  363   * RB interrupt can be checked by:\n  364   * \\snippet tc_capture_waveform_example.c tc_capture_irq_handler_status\n  365   * \\code } \\endcode\n  366:  * -# In the \\ref TC_Handler_null \"TC_Handler()\" function, the RA value.\n  367   * can be read by:\n  368   * \\code uint32_t gs_ul_captured_ra; \\endcode\n  369   * \\snippet tc_capture_waveform_example.c tc_capture_irq_handler_read_ra\n  370:  * -# In the \\ref TC_Handler_null \"TC_Handler()\" function, the RB value.\n  371   * can be read by:\n  372   * \\code uint32_t gs_ul_captured_rb; \\endcode\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/twi/twi.c:\n  599  Pdc *twi_get_pdc_base(Twi *p_twi)\n  600  {\n  601: 	Pdc *p_pdc_base = NULL;\n  602  #if !SAMG\n  603  	if (p_twi == TWI0) {\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/twihs/twihs.c:\n  583  Pdc *twihs_get_pdc_base(Twihs *p_twihs)\n  584  {\n  585: 	Pdc *p_pdc_base = NULL;\n  586  \n  587  	if (p_twihs == TWI0) {\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/twim/twim.c:\n   73  \n   74  /** \\internal Pointer to the application TWI transmit buffer. */\n   75: static const volatile uint8_t  *p_twim_tx_data[NUM_TWIM_CH] = {NULL};\n   76  /** \\internal Pointer to the application TWI receive buffer. */\n   77: static volatile uint8_t *p_twim_rx_data[NUM_TWIM_CH] = {NULL};\n   78  /** \\internal Status of the bus transfer */\n   79  static volatile twim_transfer_status_t transfer_status[NUM_TWIM_CH];\n   ..\n   87  static volatile bool twim_next_cmd_xfer_valid[NUM_TWIM_CH] = {false};\n   88  /** \\internal Pointer to the application TWI transmit buffer for next transfer. */\n   89: static const volatile uint8_t  *p_twim_next_tx_data[NUM_TWIM_CH] = {NULL};\n   90  /** \\internal Pointer to the application TWI receive buffer for next transfer. */\n   91: static volatile uint8_t *p_twim_next_rx_data[NUM_TWIM_CH] = {NULL};\n   92  /** \\internal Remaining number of bytes to transmit for next transfer. */\n   93  static volatile uint32_t twim_next_tx_nb_bytes[NUM_TWIM_CH] = {0};\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/udp/udp_device.c:\n  997  static void udd_ctrl_init(void)\n  998  {\n  999: 	udd_g_ctrlreq.callback = NULL;\n 1000: 	udd_g_ctrlreq.over_under_run = NULL;\n 1001  	udd_g_ctrlreq.payload_size = 0;\n 1002  	udd_ep_control_state = UDD_EPCTRL_SETUP;\n ....\n 1191  		// in case of data receive generate a stall\n 1192  		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;\n 1193: 		if (NULL != udd_g_ctrlreq.over_under_run) {\n 1194  			if (!udd_g_ctrlreq.over_under_run()) {\n 1195  				// Stall ZLP\n ....\n 1342  	}\n 1343  	ptr_job->busy = false;\n 1344: 	if (NULL == ptr_job->call_trans) {\n 1345  		return; // No callback linked to job\n 1346  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/udphs/udphs_device.c:\n  934  		if (!Is_udd_endpoint_mapped(i)) {\n  935  			dbg_print(\"ErrRealloc%d-JobE \", i);\n  936: 			if (NULL == ptr_job->call_trans) {\n  937  				return false;\n  938  			}\n  ...\n 1283  	udd_ack_out_received(0);\n 1284  \n 1285: 	udd_g_ctrlreq.callback = NULL;\n 1286: 	udd_g_ctrlreq.over_under_run = NULL;\n 1287  	udd_g_ctrlreq.payload_size = 0;\n 1288  	udd_ep_control_state = UDD_EPCTRL_SETUP;\n ....\n 1499  		// in case of data receive generate a stall\n 1500  		udd_g_ctrlreq.payload_size = udd_ctrl_payload_buf_cnt;\n 1501: 		if (NULL != udd_g_ctrlreq.over_under_run) {\n 1502  			if (!udd_g_ctrlreq.over_under_run()) {\n 1503  				// Stall ZLP\n ....\n 1730  	ptr_job->busy = false;\n 1731  	dbg_print(\"JobE%d \", b_abort);\n 1732: 	if (NULL == ptr_job->call_trans) {\n 1733  		return; // No callback linked to job\n 1734  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/uhdp/uhdp_device.c:\n  899  			if (!Is_udd_endpoint_configured(i)) {\n  900  				dbg_print(\"ErrRealloc%d \", i);\n  901: 				if (NULL == ptr_job->call_trans) {\n  902  					return false;\n  903  				}\n  ...\n 1170  	udd_ack_out_received(0);\n 1171  \n 1172: 	udd_g_ctrlreq.callback = NULL;\n 1173: 	udd_g_ctrlreq.over_under_run = NULL;\n 1174  	udd_g_ctrlreq.payload_size = 0;\n 1175  	udd_ep_control_state = UDD_EPCTRL_SETUP;\n ....\n 1367  		// in case of data receive generate a stall\n 1368  		udd_g_ctrlreq.payload_size = udd_ctrl_payload_buf_cnt;\n 1369: 		if (NULL != udd_g_ctrlreq.over_under_run) {\n 1370  			if (!udd_g_ctrlreq.over_under_run()) {\n 1371  				// Stall ZLP\n ....\n 1591  	dbg_print(\"(JobE%x:%d) \", (ptr_job-udd_ep_job)+1, b_abort);\n 1592  	ptr_job->busy = false;\n 1593: 	if (NULL == ptr_job->call_trans) {\n 1594  		return; // No callback linked to job\n 1595  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/uhdp/uhdp_host.c:\n  286  \n  287  //! Store the callback to be call at the end of reset signal\n  288: static uhd_callback_reset_t uhd_reset_callback = NULL;\n  289  \n  290  /**\n  ...\n  542  	otg_enable();\n  543  \n  544: 	uhd_ctrl_request_first = NULL;\n  545: 	uhd_ctrl_request_last = NULL;\n  546  	uhd_ctrl_request_timeout = 0;\n  547  	uhd_suspend_start = 0;\n  ...\n  855  \n  856  	request = malloc(sizeof(struct uhd_ctrl_request_t));\n  857: 	if (request == NULL) {\n  858  		Assert(false);\n  859  		return false;\n  ...\n  867  	request->callback_run = callback_run;\n  868  	request->callback_end = callback_end;\n  869: 	request->next_request = NULL;\n  870  \n  871  	// Add this request in the queue\n  872  	flags = cpu_irq_save();\n  873: 	if (uhd_ctrl_request_first == NULL) {\n  874  		uhd_ctrl_request_first = request;\n  875  		b_start_request = true;\n  ...\n  990  		uhd_ack_reset_sent();\n  991  		dbg_print(\"RST \");\n  992: 		if (uhd_reset_callback != NULL) {\n  993  			uhd_reset_callback();\n  994  		}\n  ...\n 1354  	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {\n 1355  		// payload buffer is full to store data remaining\n 1356: 		if (uhd_ctrl_request_first->callback_run == NULL\n 1357  				|| !uhd_ctrl_request_first->callback_run(\n 1358  				uhd_get_configured_address(0),\n ....\n 1416  	if (!uhd_ctrl_request_first->payload_size) {\n 1417  		// Buffer empty, then request a new buffer\n 1418: 		if (uhd_ctrl_request_first->callback_run==NULL\n 1419  				|| !uhd_ctrl_request_first->callback_run(\n 1420  				uhd_get_configured_address(0),\n ....\n 1478  	flags = cpu_irq_save();\n 1479  	uhd_ctrl_request_first = uhd_ctrl_request_first->next_request;\n 1480: 	b_new_request = (uhd_ctrl_request_first != NULL);\n 1481  	cpu_irq_restore(flags);\n 1482  	free(request_to_free);\n 1483  \n 1484  	// Call callback\n 1485: 	if (callback_end != NULL) {\n 1486  		callback_end(uhd_get_configured_address(0), status, uhd_ctrl_nb_trans);\n 1487  	}\n ....\n 1819  	}\n 1820  	ptr_job->busy = false;\n 1821: 	if (NULL == ptr_job->call_end) {\n 1822  		return; // No callback linked to job\n 1823  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/uhp/uhp_host.c:\n  153  \n  154  /** Store the callback to be call at the end of reset signal. */\n  155: static uhd_callback_reset_t uhd_reset_callback = NULL;\n  156  \n  157  /** Store the callback to be call at the end of setup request. */\n  ...\n  162  };\n  163  static struct uhd_callback_setup_end_parameter callback_setup_end_para;\n  164: static uhd_callback_setup_end_t callback_setup_end_func = NULL;\n  165  \n  166  /** Store the callback to be call at the end of one transaction. */\n  ...\n  198  	if (!(callback_type & 0x80000000)) {\n  199  		td_general_header = (struct ohci_td_general *)(callback_type & 0xFFFFFFF0);\n  200: 		while (td_general_header != NULL) {\n  201  			/* Check if there is free callback resource. */\n  202  			for (i = 0; i < 8; i++) {\n  ...\n  210  			}\n  211  \n  212: 			if (callback_trans_end_para[i].callback_trans_end_func != NULL) {\n  213  				current_buffer_point =\n  214  						(iram_size_t)td_general_header->pCurrentBufferPointer;\n  ...\n  238  		}\n  239  	} else if (callback_type & 0x80000000) {\n  240: 		if (callback_setup_end_func != NULL) {\n  241  			uhd_callback_setup_end_t callback_setup = callback_setup_end_func;\n  242: 			callback_setup_end_func = NULL;\n  243  \n  244  			callback_setup(callback_setup_end_para.add,\n  ...\n  305  		uhc_notify_connection(false);\n  306  	} else if (*bus_flag == BUS_RESET) {\n  307: 		if (uhd_reset_callback != NULL) {\n  308  			uhd_reset_callback();\n  309: 			uhd_reset_callback = NULL;\n  310  		}\n  311  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/uhp/ohci/ohci_hcd.c:\n  186  \n  187  	/* TDs in control endpoint. */\n  188: 	control_ed.p_td_head = NULL;\n  189: 	control_ed.p_td_tail = NULL; \n  190  \n  191  	/* TDs in Bulk endpoints. */\n  192  	ed_header = (struct ohci_ed *)OHCI->HcBulkHeadED;\n  193: 	while (ed_header != NULL) {\n  194  		if (ed_header->p_td_head != ed_header->p_td_tail) {\n  195  			td_general_free_header = (struct ohci_td_general *)ed_header->p_td_head;\n  196: 			while (td_general_free_header != NULL) {\n  197  				td_general_header = td_general_free_header->p_next_td;\n  198  				free(td_general_free_header);\n  ...\n  205  	for (i = 0; i < 32; i++) {\n  206  		ed_header = (struct ohci_ed *)hcca.InterruptTable[i];\n  207: 		while (ed_header != NULL) {\n  208  			if (ed_header->p_td_head != ed_header->p_td_tail) {\n  209  				td_general_free_header = (struct ohci_td_general *)ed_header->p_td_head;\n  210: 				while (td_general_free_header != NULL) {\n  211  					td_general_header = td_general_free_header->p_next_td;\n  212  					free(td_general_free_header);\n  ...\n  224  	/* Bulk endpoints. */\n  225  	ed_header = (struct ohci_ed *)OHCI->HcBulkHeadED;\n  226: 	while (ed_header != NULL) {\n  227  		ed_free_header = ed_header;\n  228  		ed_header = ed_header->p_next_ed;\n  ...\n  233  	for (i = 0; i < 32; i++) {\n  234  		ed_header = (struct ohci_ed *)hcca.InterruptTable[i];\n  235: 		while (ed_header != NULL) {\n  236  			ed_free_header = ed_header;\n  237  			ed_header = ed_header->p_next_ed;\n  ...\n  383  	bulk_ed_head = (struct ohci_ed *)OHCI->HcBulkHeadED;\n  384  \n  385: 	if (bulk_ed_head == NULL) {\n  386  		bulk_ed_add->ed_info.ul_ed_info = ed_info->ul_ed_info;\n  387  		OHCI->HcBulkHeadED = (uint32_t)bulk_ed_add;\n  388  	} else {\n  389  		/* Check if the endpoint has been allocated */\n  390: 		while (bulk_ed_head->p_next_ed != NULL) {\n  391  			if (bulk_ed_head->ed_info.ed_info_s.bEndpointNumber ==\n  392  					ed_info->ed_info_s.bEndpointNumber) {\n  ...\n  434  		for (i = 0; i < 32; i++) {\n  435  			period_ed_header = (struct ohci_ed *)hcca.InterruptTable[i];\n  436: 			if (period_ed_header == NULL) {\n  437  				hcca.InterruptTable[i] = (uint32_t)period_ed_add;\n  438  			} else {\n  ...\n  459  		for (i = 0; i < 8; i++) {\n  460  			period_ed_header = (struct ohci_ed *)hcca.InterruptTable[i];\n  461: 			if (period_ed_header == NULL) {\n  462  				period_ed_add->ed_info.ul_ed_info = ed_info->ul_ed_info;\n  463  				hcca.InterruptTable[i] = (uint32_t)period_ed_add;\n  ...\n  497  		/* Bulk endpoints. */\n  498  		ed_header = (struct ohci_ed *)OHCI->HcBulkHeadED;\n  499: 		if (ed_header != NULL) {\n  500  			if (ed_header->ed_info.ed_info_s.bEndpointNumber == ep_number) {\n  501  				OHCI->HcBulkHeadED = (uint32_t)ed_header->p_next_ed;\n  ...\n  503  			} else {\n  504  				/* Check the list */\n  505: 				while ((ed_header != NULL) && (ed_header->p_next_ed != NULL)) {\n  506  					if (ed_header->p_next_ed->ed_info.ed_info_s.bEndpointNumber\n  507  							==	ep_number) {\n  ...\n  518  		for (i = 0; i < 32; i++) {\n  519  			ed_header = (struct ohci_ed *)hcca.InterruptTable[i];\n  520: 			while (ed_header != NULL) {\n  521  				if (ed_header->ed_info.ed_info_s.bEndpointNumber == ep_number) {\n  522  					ed_free_header = ed_header;\n  ...\n  627  	control_td_head.td_info.bConditionCode = 0xf;\n  628  	control_td_head.pCurrentBufferPointer= buf;\n  629: 	control_td_head.p_next_td = NULL;\n  630  	control_td_head.pBufferEnd = buf + buf_size - 1;\n  631  \n  ...\n  636  \n  637  	control_ed.p_td_head = (void *)&control_td_head;\n  638: 	control_ed.p_td_tail = NULL;\n  639  \n  640  	OHCI->HcCommandStatus = HC_COMMANDSTATUS_CLF;\n  ...\n  676  	i = 0;\n  677  	ed_header = (struct ohci_ed *)OHCI->HcBulkHeadED;\n  678: 	while (ed_header != NULL) {\n  679  		if ((ed_header->ed_info.ed_info_s.bEndpointNumber == ep_number) &&\n  680  				(ed_header->ed_info.ed_info_s.bDirection == ep_dir)) {\n  ...\n  695  			bulk_td_head[i].td_info.bConditionCode = 0;\n  696  			bulk_td_head[i].pCurrentBufferPointer= buf;\n  697: 			bulk_td_head[i].p_next_td = NULL;\n  698  			bulk_td_head[i].pBufferEnd = buf + buf_size - 1;\n  699  \n  ...\n  711  \n  712  			ed_header->p_td_head = (void *)p_td_head;\n  713: 			ed_header->p_td_tail = NULL;\n  714  \n  715  			OHCI->HcCommandStatus = HC_COMMANDSTATUS_BLF;\n  ...\n  748  				interrupt_td_head[i].td_info.bConditionCode = 0;\n  749  				interrupt_td_head[i].pCurrentBufferPointer= buf;\n  750: 				interrupt_td_head[i].p_next_td = NULL;\n  751  				interrupt_td_head[i].pBufferEnd = buf + buf_size - 1;\n  752  \n  ...\n  763  				p_td_head |= p_td_tail;\n  764  				ed_header->p_td_head = (void *)p_td_head;\n  765: 				ed_header->p_td_tail = NULL;\n  766  \n  767  				OHCI->HcControl |= HC_CONTROL_PLE;\n  ...\n  788  				isochronous_td_head[i].td_info.bConditionCode = 0;\n  789  				isochronous_td_head[i].pBufferPage0= buf;\n  790: 				isochronous_td_head[i].p_next_td = NULL;\n  791  				isochronous_td_head[i].pBufferEnd = buf + buf_size - 1;\n  792  				isochronous_td_head[i].offset_psw[0] = 0;\n  ...\n  801  \n  802  				ed_header->p_td_head = (void *)&isochronous_td_head[i];\n  803: 				ed_header->p_td_tail = NULL;\n  804  \n  805  				// clear the skip\n  ...\n  830  	/* Control endpoints. */\n  831  	if (ep_number == 0) {\n  832: 		control_ed.p_td_head = NULL;\n  833: 		control_ed.p_td_tail = NULL; \n  834  		return;\n  835  	} \n  ...\n  837  	/* Bulk endpoints. */\n  838  	ed_header = (struct ohci_ed *)OHCI->HcBulkHeadED;\n  839: 	while (ed_header != NULL) {\n  840  		if (ed_header->ed_info.ed_info_s.bEndpointNumber ==	ep_number) {\n  841  			if (ed_header->p_td_head != ed_header->p_td_tail) {\n  842  				td_general_free_header = (struct ohci_td_general *)ed_header->p_td_head;\n  843: 				while (td_general_free_header != NULL) {\n  844  					td_general_header = td_general_free_header->p_next_td;\n  845  					free(td_general_free_header);\n  ...\n  854  	for (i = 0; i < 32; i++) {\n  855  		ed_header = (struct ohci_ed *)hcca.InterruptTable[i];\n  856: 		while (ed_header != NULL) {\n  857  			if (ed_header->ed_info.ed_info_s.bEndpointNumber == ep_number) {\n  858: 				ed_header->p_td_head = NULL;\n  859: 				ed_header->p_td_tail = NULL;\n  860  				return;\n  861  			}\n  ...\n  949  void ohci_unregister_callback(enum ohci_interrupt_source int_source)\n  950  {\n  951: 	ohci_callback_pointer[int_source] = NULL;\n  952  }\n  953  \n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/uotghs/uotghs_device.c:\n  964  			if (!Is_udd_endpoint_configured(i)) {\n  965  				dbg_print(\"ErrRealloc%d \", i);\n  966: 				if (NULL == ptr_job->call_trans) {\n  967  					return false;\n  968  				}\n  ...\n 1346  	udd_ack_out_received(0);\n 1347  \n 1348: 	udd_g_ctrlreq.callback = NULL;\n 1349: 	udd_g_ctrlreq.over_under_run = NULL;\n 1350  	udd_g_ctrlreq.payload_size = 0;\n 1351  	udd_ep_control_state = UDD_EPCTRL_SETUP;\n ....\n 1543  		// in case of data receiv generate a stall\n 1544  		udd_g_ctrlreq.payload_size = udd_ctrl_payload_buf_cnt;\n 1545: 		if (NULL != udd_g_ctrlreq.over_under_run) {\n 1546  			if (!udd_g_ctrlreq.over_under_run()) {\n 1547  				// Stall ZLP\n ....\n 1767  	dbg_print(\"(JobE%x:%d) \", (ptr_job-udd_ep_job)+1, b_abort);\n 1768  	ptr_job->busy = false;\n 1769: 	if (NULL == ptr_job->call_trans) {\n 1770  		return; // No callback linked to job\n 1771  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/uotghs/uotghs_host.c:\n  266  \n  267  //! Store the callback to be call at the end of reset signal\n  268: static uhd_callback_reset_t uhd_reset_callback = NULL;\n  269  \n  270  /**\n  ...\n  577  #endif\n  578  \n  579: 	uhd_ctrl_request_first = NULL;\n  580: 	uhd_ctrl_request_last = NULL;\n  581  	uhd_ctrl_request_timeout = 0;\n  582  	uhd_suspend_start = 0;\n  ...\n  912  \n  913  	request = malloc(sizeof(struct uhd_ctrl_request_t));\n  914: 	if (request == NULL) {\n  915  		Assert(false);\n  916  		return false;\n  ...\n  924  	request->callback_run = callback_run;\n  925  	request->callback_end = callback_end;\n  926: 	request->next_request = NULL;\n  927  \n  928  	// Add this request in the queue\n  929  	flags = cpu_irq_save();\n  930: 	if (uhd_ctrl_request_first == NULL) {\n  931  		uhd_ctrl_request_first = request;\n  932  		b_start_request = true;\n  ...\n 1097  	if (Is_uhd_reset_sent()) {\n 1098  		uhd_ack_reset_sent();\n 1099: 		if (uhd_reset_callback != NULL) {\n 1100  			uhd_reset_callback();\n 1101  		}\n ....\n 1520  	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {\n 1521  		// payload buffer is full to store data remaining\n 1522: 		if (uhd_ctrl_request_first->callback_run == NULL\n 1523  				|| !uhd_ctrl_request_first->callback_run(\n 1524  				uhd_get_configured_address(0),\n ....\n 1582  	if (!uhd_ctrl_request_first->payload_size) {\n 1583  		// Buffer empty, then request a new buffer\n 1584: 		if (uhd_ctrl_request_first->callback_run==NULL\n 1585  				|| !uhd_ctrl_request_first->callback_run(\n 1586  				uhd_get_configured_address(0),\n ....\n 1648  	flags = cpu_irq_save();\n 1649  	uhd_ctrl_request_first = uhd_ctrl_request_first->next_request;\n 1650: 	b_new_request = (uhd_ctrl_request_first != NULL);\n 1651  	cpu_irq_restore(flags);\n 1652  	free(request_to_free);\n 1653  \n 1654  	// Call callback\n 1655: 	if (callback_end != NULL) {\n 1656  		callback_end(uhd_get_configured_address(0), status, uhd_ctrl_nb_trans);\n 1657  	}\n ....\n 2145  	}\n 2146  	ptr_job->busy = false;\n 2147: 	if (NULL == ptr_job->call_end) {\n 2148  		return; // No callback linked to job\n 2149  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/usart/usart.c:\n 1557  	Pdc *p_pdc_base;\n 1558  \n 1559: 	p_pdc_base = (Pdc *)NULL;\n 1560  \n 1561  #ifdef PDC_USART\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/usbc/usbc_device.c:\n  951  	dbg_print(\"abort%x \", ep);\n  952  	ptr_job->busy = false;\n  953: 	if (NULL != ptr_job->call_trans) {\n  954  		if (Is_udd_endpoint_in(ep)) {\n  955  			ep |= USB_EP_DIR_IN;\n  ...\n 1098  	udd_ack_out_received(0);\n 1099  \n 1100: 	udd_g_ctrlreq.callback = NULL;\n 1101: 	udd_g_ctrlreq.over_under_run = NULL;\n 1102  	udd_g_ctrlreq.payload_size = 0;\n 1103  	udd_ep_control_state = UDD_EPCTRL_SETUP;\n ....\n 1289  		// in case of data receive generate a stall\n 1290  		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;\n 1291: 		if (NULL != udd_g_ctrlreq.over_under_run) {\n 1292  			if (!udd_g_ctrlreq.over_under_run()) {\n 1293  				// Stall ZLP\n ....\n 1628  	dbg_print(\"done%x \", ep);\n 1629  	ptr_job->busy = false;\n 1630: 	if (NULL != ptr_job->call_trans) {\n 1631  		ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);\n 1632  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/drivers/usbc/usbc_host.c:\n  300  \n  301  //! Store the callback to be call at the end of reset signal\n  302: static uhd_callback_reset_t uhd_reset_callback = NULL;\n  303  \n  304  /**\n  ...\n  564  	otg_register_desc_tab(uhd_g_pipe_table);\n  565  \n  566: 	uhd_ctrl_request_first = NULL;\n  567: 	uhd_ctrl_request_last = NULL;\n  568  	uhd_ctrl_request_timeout = 0;\n  569  	uhd_suspend_start = 0;\n  ...\n  877  \n  878  	request = malloc(sizeof(struct uhd_ctrl_request_t));\n  879: 	if (request == NULL) {\n  880  		Assert(false);\n  881  		return false;\n  ...\n  889  	request->callback_run = callback_run;\n  890  	request->callback_end = callback_end;\n  891: 	request->next_request = NULL;\n  892  \n  893  	// Add this request in the queue\n  894  	flags = cpu_irq_save();\n  895: 	if (uhd_ctrl_request_first == NULL) {\n  896  		uhd_ctrl_request_first = request;\n  897  		b_start_request = true;\n  ...\n 1006  		uhd_ack_reset_sent();\n 1007  		dbg_print(\"RST \");\n 1008: 		if (uhd_reset_callback != NULL) {\n 1009  			uhd_reset_callback();\n 1010  		}\n ....\n 1416  	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {\n 1417  		// payload buffer is full to store data remaining\n 1418: 		if (uhd_ctrl_request_first->callback_run == NULL\n 1419  				|| !uhd_ctrl_request_first->callback_run(\n 1420  				uhd_udesc_get_uhaddr(0),\n ....\n 1485  	if (!uhd_ctrl_request_first->payload_size) {\n 1486  		// Buffer empty, then request a new buffer\n 1487: 		if (uhd_ctrl_request_first->callback_run==NULL\n 1488  				|| !uhd_ctrl_request_first->callback_run(\n 1489  				uhd_udesc_get_uhaddr(0),\n ....\n 1553  	bool b_new_request;\n 1554  \n 1555: 	Assert (uhd_ctrl_request_first != NULL);\n 1556  \n 1557  	dbgp_ctrl(\"reqE%d\", status);\n ....\n 1566  	flags = cpu_irq_save();\n 1567  	uhd_ctrl_request_first = uhd_ctrl_request_first->next_request;\n 1568: 	b_new_request = (uhd_ctrl_request_first != NULL);\n 1569  	cpu_irq_restore(flags);\n 1570  	free(request_to_free);\n 1571  \n 1572  	// Call callback\n 1573: 	if (callback_end != NULL) {\n 1574  		callback_end(uhd_udesc_get_uhaddr(0), status, uhd_ctrl_nb_trans);\n 1575  	}\n ....\n 1718  \n 1719  		// May be required to copy received data from cache buffer to user buffer\n 1720: 		if (ptr_job->buf_internal != NULL) {\n 1721  			memcpy(&ptr_job->buf[ptr_job->nb_trans],\n 1722  					ptr_job->buf_internal,\n 1723  					ptr_job->buf_size % pipe_size);\n 1724  			free(ptr_job->buf_internal);\n 1725: 			ptr_job->buf_internal = NULL;\n 1726  		}\n 1727  \n ....\n 1757  				uhd_in_request_number(pipe, 1);\n 1758  				ptr_job->buf_internal = malloc(pipe_size);\n 1759: 				if (ptr_job->buf_internal == NULL) {\n 1760: 					Assert(ptr_job->buf_internal != NULL);\n 1761  					goto uhd_pipe_trans_complet_end;\n 1762  				}\n ....\n 1911  	uhd_pipes_error &= ~(1 << pipe);\n 1912  	// In case of abort, free the internal buffer\n 1913: 	if (ptr_job->buf_internal != NULL) {\n 1914  		free(ptr_job->buf_internal);\n 1915: 		ptr_job->buf_internal = NULL;\n 1916  	}\n 1917  	ptr_job->busy = false;\n 1918: 	if (NULL == ptr_job->call_end) {\n 1919  		return; // No callback linked to job\n 1920  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/services/flash_efc/flash_efc.c:\n  147  /**\n  148   * \\brief Translate the given flash address to page and offset values.\n  149:  * \\note pus_page and pus_offset must not be null in order to store the\n  150   * corresponding values.\n  151   *\n  ...\n  265  \n  266  	/* Store result */\n  267: 	if (pul_addr != NULL) {\n  268  		*pul_addr = ul_addr;\n  269  	}\n  ...\n  327  	Efc *p_efc;\n  328  \n  329: 	translate_address(&p_efc, ul_address, NULL, NULL);\n  330  	efc_set_wait_state(p_efc, ul_fws);\n  331  \n  ...\n  346  	uint32_t clock = sysclk_get_cpu_hz();\n  347  \n  348: 	translate_address(&p_efc, ul_address, NULL, NULL);\n  349  \n  350  	/* Set FWS for embedded Flash access according to operating frequency */\n  ...\n  389  	Efc *p_efc;\n  390  \n  391: 	translate_address(&p_efc, ul_address, NULL, NULL);\n  392  	return efc_get_wait_state(p_efc);\n  393  }\n  ...\n  409  	uint32_t ul_cnt;\n  410  \n  411: 	translate_address(&p_efc, ul_address, NULL, NULL);\n  412  \n  413  	/* Command fails */\n  ...\n  489  	Efc *p_efc;\n  490  \n  491: 	translate_address(&p_efc, ul_address, NULL, NULL);\n  492  \n  493  	if (EFC_RC_OK != efc_perform_command(p_efc, EFC_FCMD_EA, 0)) {\n  ...\n  514  	uint16_t us_page;\n  515  \n  516: 	translate_address(&p_efc, ul_address, &us_page, NULL);\n  517  \n  518  	if (EFC_RC_OK != efc_perform_command(p_efc, EFC_FCMD_EPL, us_page)) {\n  ...\n  545  	}\n  546  \n  547: 	translate_address(&p_efc, ul_address, &us_page, NULL);\n  548  \n  549  	if (EFC_RC_OK != efc_perform_command(p_efc, EFC_FCMD_EPA,\n  ...\n  570  	uint16_t us_page;\n  571  \n  572: 	translate_address(&p_efc, ul_address, &us_page, NULL);\n  573  \n  574  	if (EFC_RC_OK != efc_perform_command(p_efc, EFC_FCMD_ES, us_page)) {\n  ...\n  702  	compute_lock_range(ul_start, ul_end, &ul_actual_start, &ul_actual_end);\n  703  \n  704: 	if (pul_actual_start != NULL) {\n  705  		*pul_actual_start = ul_actual_start;\n  706  	}\n  707  \n  708: 	if (pul_actual_end != NULL) {\n  709  		*pul_actual_end = ul_actual_end;\n  710  	}\n  ...\n  750  	/* Compute actual unlock range and store it */\n  751  	compute_lock_range(ul_start, ul_end, &ul_actual_start, &ul_actual_end);\n  752: 	if (pul_actual_start != NULL) {\n  753  		*pul_actual_start = ul_actual_start;\n  754  	}\n  755: 	if (pul_actual_end != NULL) {\n  756  		*pul_actual_end = ul_actual_end;\n  757  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/services/network/lin/lin.c:\n  142  	g_st_packet[uc_node].ul_addr = (uint32_t)lin_tx_buffer_node[uc_node];\n  143  	g_st_packet[uc_node].ul_size = (uc_len + 1);\n  144: 	pdc_tx_init(g_p_pdc[uc_node], &g_st_packet[uc_node], NULL);\n  145  	usart_enable_interrupt(USART0, US_IER_LINSNRE);\n  146  	pdc_enable_transfer(g_p_pdc[uc_node], PERIPH_PTCR_TXTEN);\n  ...\n  169  	g_st_packet[uc_node].ul_addr = (uint32_t)lin_tx_buffer_node[uc_node];\n  170  	g_st_packet[uc_node].ul_size = uc_len;\n  171: 	pdc_tx_init(g_p_pdc[uc_node], &g_st_packet[uc_node], NULL);\n  172  	pdc_enable_transfer(g_p_pdc[uc_node], PERIPH_PTCR_TXTEN);\n  173  \n  ...\n  191  	g_st_packet[uc_node].ul_addr = (uint32_t)&lin_rx_buffer_node;\n  192  	g_st_packet[uc_node].ul_size = uc_len;\n  193: 	pdc_rx_init(g_p_pdc[uc_node], &g_st_packet[uc_node], NULL);\n  194  \n  195  	usart_enable_interrupt(USART0, US_IER_ENDRX);\n  ...\n  253  			/* Start of the associated task */\n  254  \n  255: 			if (lin_descript_list_node[uc_node][uc_handle].pt_function != NULL) {\n  256  				lin_descript_list_node[uc_node][uc_handle].pt_function(\n  257  						lin_descript_list_node[uc_node][uc_handle].uc_pt_data);\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/services/resistive_touch/rtouch.h:\n  194   * screen changes. The handler is called from the rtouch_process() function.\n  195   *\n  196:  * \\param handler Pointer to the touch event handler, or NULL to disable\n  197   * the handler.\n  198   */\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/services/smart_card/iso7816.c:\n   78  #define USART_RCV       1\n   79  \n   80: /** NULL byte to restart byte procedure. */\n   81: #define ISO_NULL_VAL    0x60\n   82  \n   83  /** Receive timeout. */\n   ..\n  270  		iso7816_get_char(&uc_proc_byte);\n  271  		uint8_t uc_proc_byte_x = (uc_proc_byte ^ 0xff);\n  272: 		/* Handle NULL. */\n  273: 		if (ISO_NULL_VAL == uc_proc_byte) {\n  274  			continue;\n  275  		}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/utils/syscalls/gcc/syscalls.c:\n   75  extern caddr_t _sbrk(int incr)\n   76  {\n   77: 	static unsigned char *heap = NULL;\n   78  	unsigned char *prev_heap;\n   79  	int ramend = (int)&__ram_end__;\n   80  \n   81: 	if (heap == NULL) {\n   82  		heap = (unsigned char *)&_end;\n   83  	}\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/wlan_bus_driver/wlan_bus_sdio.c:\n   60  typedef struct\n   61  {\n   62:     /*@shared@*/ /*@null@*/ uint8_t* data;\n   63      uint16_t length;\n   64  } sdio_dma_segment_t;\n   ..\n  155  \n  156  void dma_irq ( void );\n  157: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response );\n  158  extern void wiced_platform_notify_irq( void );\n  159  \n  ...\n  378      {\n  379          /* Send CMD0 to set it to idle state */\n  380:         host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_0, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  381  \n  382          /* CMD5. */\n  383:         host_platform_sdio_transfer( BUS_READ, SDIO_CMD_5, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  384  \n  385          /* Send CMD3 to get RCA. */\n  ...\n  394  \n  395      /* Send CMD7 with the returned RCA to select the card */\n  396:     host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_7, SDIO_BYTE_MODE, SDIO_1B_BLOCK, data, 0, 0, RESPONSE_NEEDED, NULL );\n  397  \n  398      return kNoErr;\n  ...\n  439  }\n  440  \n  441: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response )\n  442  {\n  443      uint32_t loop_count = 0;\n  ...\n  445      uint16_t attempts = 0;\n  446  \n  447:     check_string(!((command == SDIO_CMD_53) && (data == NULL)), \"Bad args\" );\n  448  \n  449:     if ( response != NULL )\n  450      {\n  451          *response = 0;\n  ...\n  549      }\n  550  \n  551:     if ( response != NULL )\n  552      {\n  553          *response = SDIO->RESP1;\n\n/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/wlan_bus_driver/wlan_bus_spi.c:\n  154    pdc_spi_packet.ul_addr = 0;\n  155    pdc_spi_packet.ul_size = 1;\n  156:   pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL );\n  157:   pdc_rx_init( spi_pdc, &pdc_spi_packet, NULL );\n  158    \n  159    spi_disable_interrupt(wifi_spi.port, 0xffffffff );\n  ...\n  226    platform_gpio_output_low( &wifi_spi_pins[WIFI_PIN_SPI_CS] );\n  227    \n  228:   pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL);\n  229    \n  230    if ( dir == BUS_READ ) {\n  231:     pdc_rx_init( spi_pdc, &pdc_spi_packet, NULL);\n  232      \n  233      spi_enable_interrupt(wifi_spi.port, SPI_IER_RXBUFF );\n  ...\n  263    {\n  264      pdc_disable_transfer( spi_pdc, PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS );\n  265:     pdc_rx_init( spi_pdc, &pdc_spi_packet, NULL );\n  266:     pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL );\n  267      spi_disable_interrupt( wifi_spi.port, SPI_IER_RXBUFF );\n  268    }\n  ...\n  271    {\n  272      pdc_disable_transfer( spi_pdc, PERIPH_PTCR_TXTDIS );\n  273:     pdc_tx_init( spi_pdc, &pdc_spi_packet, NULL );\n  274      spi_disable_interrupt( wifi_spi.port, SPI_IER_ENDTX );\n  275      /* Clear SPI RX data in a SPI send sequence */\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/FileSystem/presearch.c:\n  302  	Fs_Context = gFSContextBufferManager.pfnAllocFSContextBuffer(&gFSContextBufferManager.FSContextBuffer, DeviceID);\n  303  \n  304: 	if(Fs_Context == NULL)\n  305  	{\n  306  		return FALSE;\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/FileSystem/inc/fat_file.h:\n  115  //TRUEFile\n  116  //FALSE\n  117: //Folder == NULL: FileNum\n  118: //Folder != NULL: FolderFileNum\n  119  bool FileOpenByNum(FAT_FILE* File, FOLDER* Folder, uint16_t FileNum);\n  120  \n  ...\n  219  //ModifyTime: 2\n  220  //AccessTime: \n  221: //NULL\n  222  //:TRUE :FALSE\n  223  bool FileSetTime(FAT_FILE* File, FILE_TIME* CreateTime, FILE_TIME* ModifyTime, FILE_TIME* AccessTime);\n  ...\n  227  //ModifyTime: 2\n  228  //AccessTime: \n  229: //NULL\n  230  //:TRUE :FALSE\n  231  bool FileGetTime(FAT_FILE* File, FILE_TIME* CreateTime, FILE_TIME* ModifyTime, FILE_TIME* AccessTime);\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/FileSystem/inc/folder.h:\n   39  //TRUEFolder\n   40  //FALSE\n   41: //ParentFolder == NULL: FolderNum\n   42: //ParentFolder != NULL: ParentFolderFolderNum\n   43  bool FolderOpenByNum(FOLDER* Folder, FOLDER* ParentFolder, uint16_t FolderNum);\n   44  \n   ..\n   50  //TRUEFolder\n   51  //FALSE\n   52: //ParentFolder == NULL: FolderName\n   53: //ParentFolder != NULL: ParentFolderFolderName\n   54  //FolderName[]8\"\\\\\"\n   55  bool FolderOpenByName(FOLDER* Folder, FOLDER* ParentFolder, uint8_t* FolderName);\n   ..\n   69  //\n   70  //ParentFolderFolderName[]\n   71: //ParentFolderNULL\n   72  //TRUEFolder\n   73  //FALSE\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/peripherals/platform_flash.c:\n  404    OSStatus err = kNoErr;\n  405  \n  406:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  407  \n  408    if( peripheral->flash_type == FLASH_TYPE_SPI ){\n  ...\n  430    int erase_len = MAX_OPERATE_LEN, total_len = EndAddress - StartAddress +1;\n  431  \n  432:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  433    require_action( StartAddress >= peripheral->flash_start_addr \n  434                 && EndAddress   < peripheral->flash_start_addr + peripheral->flash_length, exit, err = kParamErr);\n  ...\n  467  \n  468  \n  469:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  470    require_action( *FlashAddress >= peripheral->flash_start_addr \n  471                 && *FlashAddress + DataLength <= peripheral->flash_start_addr + peripheral->flash_length, exit, err = kParamErr);\n  ...\n  503  \n  504  \n  505:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  506    require_action_quiet( DataLength != 0, exit, err = kNoErr);\n  507    require_action( *FlashAddress >= peripheral->flash_start_addr \n  ...\n  550    //platform_log(\"protect %d, %x, %x\", peripheral->flash_type, start_address, end_address);\n  551  \n  552:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  553  \n  554    if( ( 0x5 == ( status & BP_Msk ) >> BP_Pos ) && ( status&CMP_Msk ) )\n  ...\n  573    UNUSED_PARAMETER( end_address );\n  574  \n  575:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  576  \n  577    if( ( 0x0 == ( status & BP_Msk ) >> BP_Pos ) && !( status&CMP_Msk ) )\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/peripherals/platform_gpio.c:\n   78  \n   79    platform_mcu_powersave_disable();\n   80:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n   81  \n   82    GpioClrRegOneBit(GPIO_A_OUTDS + gpio->port , ((uint32_t)1 << gpio->pin) );\n   ..\n  119  \n  120    platform_mcu_powersave_disable();\n  121:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  122    \n  123    GpioClrRegOneBit(GPIO_A_OE + gpio->port , ((uint32_t)1 << gpio->pin) );\n  ...\n  135    platform_mcu_powersave_disable();\n  136  \n  137:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  138  \n  139    GpioSetRegOneBit(GPIO_A_OUT + gpio->port , ((uint32_t)1 << gpio->pin) );\n  ...\n  148    OSStatus err = kNoErr;\n  149  \n  150:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  151  \n  152    platform_mcu_powersave_disable();\n  ...\n  167    platform_mcu_powersave_disable();\n  168  \n  169:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  170  \n  171    regValue = GpioGetReg( GPIO_A_OUT + gpio->port );\n  ...\n  186    platform_mcu_powersave_disable();\n  187  \n  188:   require_quiet( gpio != NULL, exit);\n  189  \n  190    regValue = GpioGetReg( GPIO_A_IN + gpio->port );\n  ...\n  204  \n  205    platform_mcu_powersave_disable();\n  206:   require_action_quiet( gpio != NULL && trigger != IRQ_TRIGGER_BOTH_EDGES, exit, err = kParamErr);\n  207    \n  208    switch( gpio->port ){\n  ...\n  233      /* GPIO IRQ not exist */\n  234      for( i = 0; i < NUMBER_OF_GPIO_IRQ_LINES; i++ ){\n  235:       if ( gpio_irq_data[i].handler == NULL ){\n  236          gpio_irq_data[ i ].port       = gpio->port;\n  237          gpio_irq_data[ i ].pin        = gpio->pin;\n  ...\n  265  \n  266    platform_mcu_powersave_disable();\n  267:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  268  \n  269    switch( gpio->port ){\n  ...\n  288        gpio_irq_data[ i ].port       = 0;\n  289        gpio_irq_data[ i ].pin        = 0;\n  290:       gpio_irq_data[ i ].handler    = NULL;\n  291:       gpio_irq_data[ i ].arg        = NULL;\n  292        break;\n  293      }\n  ...\n  319  \n  320    for( i = 0; i < NUMBER_OF_GPIO_IRQ_LINES; i++ ){\n  321:     if ( gpio_irq_data[i].handler != NULL ){\n  322        port = gpio_irq_data[i].port;\n  323        pin = gpio_irq_data[i].pin;\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/peripherals/platform_rng.c:\n   67      uint32_t *pWord = inBuffer;\n   68      uint32_t tempRDM;\n   69:     uint8_t *pByte = NULL;\n   70      int inWordCount;\n   71      int remainByteCount;\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/peripherals/platform_uart.c:\n   77    platform_mcu_powersave_disable();\n   78  \n   79:   require_action_quiet( ( driver != NULL ) && ( peripheral != NULL ) && ( config != NULL ), exit, err = kParamErr);\n   80  \n   81    driver->rx_size              = 0;\n   ..\n  122      FuartIOctl(UART_IOCTL_RXINT_SET, 1);\n  123      \n  124:     if (optional_ring_buffer != NULL){\n  125        /* Note that the ring_buffer should've been initialised first */\n  126        driver->rx_buffer = optional_ring_buffer;\n  ...\n  210  {\n  211  \n  212:   if ( driver->rx_buffer != NULL )\n  213    {\n  214      while (size != 0)\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/peripherals/Libraries/dev_detect/dev_state_machine.c:\n   75  	\n   76  #ifdef FUNC_RTC_EN\n   77: 	{MODULE_ID_RTC, 			MSG_NONE,				MSG_NONE,				NULL},\n   78  #endif\n   79  };\n   ..\n  106  		if(ModeId == DevAppModeMap[i].ModeId)\n  107  		{\n  108: 			if(DevAppModeMap[i].IsDevLink == NULL)\n  109  			{\n  110  				return TRUE;\n  ...\n  133  	for(j = 0; j < MODE_CNT; j++)\n  134  	{\n  135: 		if((DevAppModeMap[(i + j) % MODE_CNT].IsDevLink == NULL) || DevAppModeMap[(i + j) % MODE_CNT].IsDevLink())\n  136  		{\n  137  			return DevAppModeMap[(i + j) % MODE_CNT].ModeId;\n  ...\n  153  		}\n  154  \n  155: 		if((DevAppModeMap[i].IsDevLink == NULL) || DevAppModeMap[i].IsDevLink())\n  156  		{\n  157  			return DevAppModeMap[i].ModeId;\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/peripherals/Libraries/fs/presearch.c:\n  299  	Fs_Context = gFSContextBufferManager.pfnAllocFSContextBuffer(&gFSContextBufferManager.FSContextBuffer, DeviceID);\n  300  \n  301: 	if(Fs_Context == NULL)\n  302  	{\n  303  		return FALSE;\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/peripherals/Libraries/inc/lrc.h:\n   42  * @param input FileNameLen \n   43  * @param input ReadBuffer  Lrc Parser\n   44: *                          NULLParser\n   45: * @param input ReadBufSize Lrc ParserReadBuffer != NULL\n   46  *                           >= 128 >= 128\n   47  *                          0Lrc Parser512Bytes\n   ..\n   54  * @brief                   IDLrc Parser, Lrc Parser\n   55  * @param input CurFolder   \n   56: * @param input FileId      IDCurFolder != NULLIDID\n   57  * @param input ReadBuffer  Lrc Parser\n   58: *                          NULLParser\n   59: * @param input ReadBufSize Lrc ParserReadBuffer != NULL\n   60  *                           >= 128 >= 128\n   61  *                          0Lrc Parser512Bytes\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/peripherals/Libraries/inc/pcm_play.h:\n   28   *     @arg  0: means using internal DAC\n   29   *     @arg  1: means using external DAC\n   30:  * @return NULL\n   31   *\n   32   * @note if use external DAC, GPIO_A.Pin14 ~ GPIO_A.Pin17 used for SampleRate control\n   ..\n   39   *                   when Channels is 2(stereo), the PcmData must be interleaving & lcontinus\n   40   * @param PcmDataLen Pcm data size in byte unit.\n   41:  * @return NULL\n   42   */\n   43  void PcmPlay(void* PcmData, uint32_t PcmDataLen);\n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/peripherals/Libraries/inc/type.h:\n   21  #include \"Common.h\"\n   22  \n   23: #ifndef NULL	\n   24: #define	NULL			((void*)0)\n   25  #endif\n   26  \n\n/Users/William/Develop/MiCO/Platform/MCU/MX1101/wlan_bus_driver/wlan_bus_sdio.c:\n  138  typedef struct\n  139  {\n  140:     /*@shared@*/ /*@null@*/ uint8_t* data;\n  141      uint16_t length;\n  142  } sdio_dma_segment_t;\n  ...\n  152   *             Function declarations\n  153   ******************************************************/\n  154: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response );\n  155  extern void wiced_platform_notify_irq( void );\n  156  \n  ...\n  265     {\n  266         /* Send CMD0 to set it to idle state */\n  267:        host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_0, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  268  \n  269         /* CMD5. */\n  270:        host_platform_sdio_transfer( BUS_READ, SDIO_CMD_5, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  271  \n  272         /* Send CMD3 to get RCA. */\n  ...\n  281  \n  282     /* Send CMD7 with the returned RCA to select the card */\n  283:    host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_7, SDIO_BYTE_MODE, SDIO_1B_BLOCK, data, 0, 0, RESPONSE_NEEDED, NULL );\n  284  \n  285      return kNoErr;\n  ...\n  291  }\n  292  \n  293: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response )\n  294  {\n  295    UNUSED_PARAMETER(mode);\n  ...\n  300    bool status;\n  301  \n  302:    check_string(!((command == SDIO_CMD_53) && (data == NULL)), \"Bad args\" );\n  303  \n  304:    if ( response != NULL )\n  305     {\n  306         *response = 0;\n  ...\n  423      }\n  424  \n  425:     if ( response != NULL )\n  426      {\n  427        SdioGetCmdResp(response_full, 6);\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_adc.c:\n   86      platform_mcu_powersave_disable();\n   87  \n   88:     require_action_quiet( adc != NULL, exit, err = kParamErr);\n   89      \n   90      /* Enable peripheral clock for this port */\n   ..\n  140      platform_mcu_powersave_disable();\n  141  \n  142:     require_action_quiet( adc != NULL, exit, err = kParamErr);\n  143  \n  144      /* Start conversion */\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_flash.c:\n   85    OSStatus err = kNoErr;\n   86  \n   87:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n   88  \n   89    if( peripheral->flash_type == FLASH_TYPE_EMBEDDED ){\n   ..\n  109    OSStatus err = kNoErr;\n  110  \n  111:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  112    require_action( start_address >= peripheral->flash_start_addr \n  113                 && end_address   <= peripheral->flash_start_addr + peripheral->flash_length - 1, exit, err = kParamErr);\n  ...\n  136    OSStatus err = kNoErr;\n  137  \n  138:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  139    require_action( *start_address >= peripheral->flash_start_addr \n  140                 && *start_address + length <= peripheral->flash_start_addr + peripheral->flash_length, exit, err = kParamErr);\n  ...\n  164    OSStatus err = kNoErr;\n  165  \n  166:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  167    require_action( (*start_address >= peripheral->flash_start_addr) \n  168                 && (*start_address + length) <= ( peripheral->flash_start_addr + peripheral->flash_length), exit, err = kParamErr);\n  ...\n  192    OSStatus err = kNoErr;\n  193  \n  194:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  195    require_action( start_address >= peripheral->flash_start_addr \n  196                 && end_address   <= peripheral->flash_start_addr + peripheral->flash_length - 1, exit, err = kParamErr);\n  ...\n  221    OSStatus err = kNoErr;\n  222  \n  223:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  224    require_action( start_address >= peripheral->flash_start_addr \n  225                 && end_address   <= peripheral->flash_start_addr + peripheral->flash_length - 1, exit, err = kParamErr);\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_gpio.c:\n   93  \n   94    platform_mcu_powersave_disable();\n   95:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n   96    \n   97    port_number = platform_gpio_get_port_number( gpio->port );\n   ..\n  132  \n  133    platform_mcu_powersave_disable();\n  134:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  135  \n  136    /* Set to Input high-impedance */\n  ...\n  154    platform_mcu_powersave_disable();\n  155  \n  156:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  157  \n  158    gpio->port->BSRRL = (uint16_t) ( 1 << gpio->pin_number );\n  ...\n  167    OSStatus err = kNoErr;\n  168  \n  169:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  170  \n  171    platform_mcu_powersave_disable();\n  ...\n  184    platform_mcu_powersave_disable();\n  185  \n  186:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  187  \n  188    gpio->port->ODR ^= (uint16_t) ( 1 << gpio->pin_number );\n  ...\n  199    platform_mcu_powersave_disable();\n  200  \n  201:   require_quiet( gpio != NULL, exit);\n  202  \n  203    result = ( ( gpio->port->IDR & (uint32_t) ( 1 << gpio->pin_number ) ) != 0 ) ? true : false;\n  ...\n  215  \n  216    platform_mcu_powersave_disable();\n  217:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  218  \n  219    switch ( trigger )\n  ...\n  318  \n  319    platform_mcu_powersave_disable();\n  320:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  321  \n  322    interrupt_line = (uint16_t) ( 1 << gpio->pin_number );\n  ...\n  419    OSStatus    err = kNoErr;\n  420  \n  421:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  422    \n  423    /* Enable peripheral clock for this port */\n  ...\n  512  \n  513      /* Call the respective GPIO interrupt handler/callback */\n  514:     if ( gpio_irq_data[gpio_number].handler != NULL )\n  515      {\n  516          void * arg = gpio_irq_data[gpio_number].arg; /* Avoids undefined order of access to volatiles */\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_i2c.c:\n   88  \n   89    platform_mcu_powersave_disable( );\n   90:   require_action_quiet( i2c != NULL, exit, err = kParamErr);\n   91    \n   92    // Init I2C GPIO clocks\n   ..\n  201    platform_mcu_powersave_disable();\n  202  \n  203:   require_action_quiet( i2c != NULL, exit, err = kParamErr);\n  204  \n  205    err = i2c_address_device( i2c, config, retries, I2C_Direction_Transmitter );\n  ...\n  508      OSStatus err;\n  509  \n  510:     if ( message->tx_buffer != NULL )\n  511      {\n  512          err = i2c_tx_no_dma( i2c, config, message );\n  ...\n  517      }\n  518  \n  519:     if ( message->rx_buffer != NULL )\n  520      {\n  521          err = i2c_rx_no_dma( i2c, config, message );\n  ...\n  538    OSStatus err = kNoErr;\n  539  \n  540:   require_action_quiet( ( message != NULL ) && ( tx_buffer != NULL ) && ( tx_buffer_length != 0 ), exit, err = kParamErr);\n  541  \n  542    memset(message, 0x00, sizeof(platform_i2c_message_t));\n  ...\n  553    OSStatus err = kNoErr;\n  554  \n  555:   require_action_quiet( ( message != NULL ) && ( rx_buffer != NULL ) && ( rx_buffer_length != 0 ), exit, err = kParamErr);\n  556  \n  557    memset(message, 0x00, sizeof(platform_i2c_message_t));\n  ...\n  568    OSStatus err = kNoErr;\n  569  \n  570:   require_action_quiet( ( message != NULL ) && ( tx_buffer != NULL ) && ( tx_buffer_length != 0 ) && ( rx_buffer != NULL ) && ( rx_buffer_length != 0 ), exit, err = kParamErr);\n  571  \n  572    memset(message, 0x00, sizeof(platform_i2c_message_t));\n  ...\n  588    platform_mcu_powersave_disable();\n  589    \n  590:   require_action_quiet( i2c != NULL, exit, err = kParamErr);\n  591    \n  592    for( i=0; i < number_of_messages; i++ )\n  ...\n  613    platform_mcu_powersave_disable();\n  614  \n  615:   require_action_quiet( i2c != NULL, exit, err = kParamErr);\n  616  \n  617    /* Disable I2C peripheral clocks */\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_pwm.c:\n   71    OSStatus                err                 = kNoErr;\n   72    \n   73:   require_action_quiet( pwm != NULL, exit, err = kParamErr);\n   74  \n   75    platform_mcu_powersave_disable();\n   ..\n  152    platform_mcu_powersave_disable();\n  153  \n  154:   require_action_quiet( pwm != NULL, exit, err = kParamErr);\n  155    \n  156    TIM_Cmd( pwm->tim, ENABLE );\n  ...\n  168    platform_mcu_powersave_disable();\n  169  \n  170:   require_action_quiet( pwm != NULL, exit, err = kParamErr);\n  171    \n  172    TIM_CtrlPWMOutputs( pwm->tim, DISABLE );\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_rng.c:\n   66      uint32_t *pWord = inBuffer;\n   67      uint32_t tempRDM;\n   68:     uint8_t *pByte = NULL;\n   69      int inWordCount;\n   70      int remainByteCount;\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_spi.c:\n  131    platform_mcu_powersave_disable();\n  132    \n  133:   require_action_quiet( ( driver != NULL ) && ( peripheral != NULL ) && ( config != NULL ), exit, err = kParamErr);\n  134  \n  135  /* Calculate prescaler */\n  ...\n  262    platform_mcu_powersave_disable();\n  263    \n  264:   require_action_quiet( ( driver != NULL ) && ( config != NULL ) && ( segments != NULL ) && ( number_of_segments != 0 ), exit, err = kParamErr);\n  265    \n  266    /* Activate chip select */\n  ...\n  295            uint16_t data = 0xFF;\n  296            \n  297:           if ( send_ptr != NULL )\n  298            {\n  299              data = *send_ptr++;\n  ...\n  302            data = spi_transfer( driver->peripheral, data );\n  303            \n  304:           if ( rcv_ptr != NULL )\n  305            {\n  306              *rcv_ptr++ = (uint8_t)data;\n  ...\n  322            uint16_t data = 0xFFFF;\n  323            \n  324:           if ( send_ptr != NULL )\n  325            {\n  326              data = *send_ptr++;\n  ...\n  329            data = spi_transfer( driver->peripheral, data );\n  330            \n  331:           if ( rcv_ptr != NULL )\n  332            {\n  333              *rcv_ptr++ = data;\n  ...\n  374    OSStatus err = kNoErr;\n  375    \n  376:   require_action_quiet( prescaler != NULL, exit, err = kParamErr);\n  377    \n  378    for( i = 0 ; i < MAX_NUM_SPI_PRESCALERS ; i++ )\n  ...\n  427    dma_init.DMA_PeripheralBurst    = DMA_PeripheralBurst_Single;\n  428    \n  429:   if ( message->tx_buffer != NULL )\n  430    {\n  431      dma_init.DMA_Memory0BaseAddr = ( uint32_t )message->tx_buffer;\n  ...\n  460    dma_init.DMA_MemoryBurst        = DMA_MemoryBurst_Single;\n  461    dma_init.DMA_PeripheralBurst    = DMA_PeripheralBurst_Single;\n  462:   if ( message->rx_buffer != NULL )\n  463    {\n  464      dma_init.DMA_Memory0BaseAddr = (uint32_t)message->rx_buffer;\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_uart.c:\n  126    platform_mcu_powersave_disable();\n  127  \n  128:   require_action_quiet( ( driver != NULL ) && ( peripheral != NULL ) && ( config != NULL ), exit, err = kParamErr);\n  129:   require_action_quiet( (optional_ring_buffer == NULL) || ((optional_ring_buffer->buffer != NULL ) && (optional_ring_buffer->size != 0)), exit, err = kParamErr);\n  130    \n  131    uart_number = platform_uart_get_port_number( peripheral->port );\n  ...\n  150    platform_gpio_set_alternate_function( peripheral->pin_rx->port, peripheral->pin_rx->pin_number, GPIO_OType_PP, GPIO_PuPd_NOPULL, uart_alternate_functions[ uart_number ] );\n  151  \n  152:   if ( ( peripheral->pin_cts != NULL ) && ( config->flow_control == FLOW_CONTROL_CTS || config->flow_control == FLOW_CONTROL_CTS_RTS ) )\n  153    {\n  154        platform_gpio_set_alternate_function( peripheral->pin_cts->port, peripheral->pin_cts->pin_number, GPIO_OType_PP, GPIO_PuPd_NOPULL, uart_alternate_functions[ uart_number ] );\n  155    }\n  156  \n  157:   if ( ( peripheral->pin_rts != NULL ) && ( config->flow_control == FLOW_CONTROL_RTS || config->flow_control == FLOW_CONTROL_CTS_RTS ) )\n  158    {\n  159        platform_gpio_set_alternate_function( peripheral->pin_rts->port, peripheral->pin_rts->pin_number, GPIO_OType_PP, GPIO_PuPd_NOPULL, uart_alternate_functions[ uart_number ] );\n  ...\n  163    if(config->flags & UART_WAKEUP_ENABLE){\n  164      mico_rtos_init_semaphore( driver->sem_wakeup, 1 );\n  165:     mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"UART_WAKEUP\", thread_wakeup, 0x100, driver);\n  166    }\n  167  #endif\n  ...\n  299  \n  300    /* Setup ring buffer */\n  301:   if ( optional_ring_buffer != NULL )\n  302    {\n  303      /* Note that the ring_buffer should've been initialised first */\n  ...\n  328    platform_mcu_powersave_disable();\n  329  \n  330:   require_action_quiet( ( driver != NULL ), exit, err = kParamErr);\n  331  \n  332    uart_number = platform_uart_get_port_number( driver->peripheral->port );\n  ...\n  393  #endif\n  394  \n  395:   require_action_quiet( ( driver != NULL ) && ( data_out != NULL ) && ( size != 0 ), exit, err = kParamErr);\n  396  \n  397    /* Clear interrupt status before enabling DMA otherwise error occurs immediately */\n  ...\n  440    //platform_mcu_powersave_disable();\n  441  \n  442:   require_action_quiet( ( driver != NULL ) && ( data_in != NULL ) && ( expected_data_size != 0 ), exit, err = kParamErr);\n  443  \n  444:   if ( driver->rx_buffer != NULL)\n  445    {\n  446      while ( expected_data_size != 0 )\n  ...\n  507    OSStatus err = kNoErr;\n  508  \n  509:   if ( driver->rx_buffer != NULL )\n  510    {\n  511      driver->peripheral->rx_dma_config.stream->CR |= DMA_SxCR_CIRC;\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_watchdog.c:\n   59  static __IO uint32_t CaptureNumber = 0, PeriodValue = 0;\n   60  #ifndef NO_MICO_RTOS\n   61: static mico_semaphore_t  _measureLSIComplete_SEM = NULL;\n   62  #else\n   63  volatile static bool _measureLSIComplete_SEM = false;\n   ..\n  199    mico_rtos_get_semaphore(&_measureLSIComplete_SEM, MICO_WAIT_FOREVER);\n  200    mico_rtos_deinit_semaphore( &_measureLSIComplete_SEM );\n  201:   _measureLSIComplete_SEM = NULL;\n  202  #else\n  203    while( _measureLSIComplete_SEM == false);\n  ...\n  264        /* Compute the period length */\n  265        PeriodValue = (uint16_t)(0xFFFF - tmpCC4[0] + tmpCC4[1] + 1);\n  266:       if(_measureLSIComplete_SEM != NULL){\n  267  #ifndef NO_MICO_RTOS\n  268          mico_rtos_set_semaphore(&_measureLSIComplete_SEM);\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/Libraries/STM32F2xx_HAL_Driver/Inc/stm32f2xx_hal_def.h:\n   71  \n   72  /* Exported macro ------------------------------------------------------------*/\n   73: #ifndef NULL\n   74:   #define NULL      (void *) 0\n   75  #endif\n   76  \n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/Libraries/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_hcd.c:\n  120  { \n  121    /* Check the HCD handle allocation */\n  122:   if(hhcd == NULL)\n  123    {\n  124      return HAL_ERROR;\n  ...\n  234  {\n  235    /* Check the HCD handle allocation */\n  236:   if(hhcd == NULL)\n  237    {\n  238      return HAL_ERROR;\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/wlan_bus_driver/wlan_bus_sdio.c:\n   58  typedef struct\n   59  {\n   60:     /*@shared@*/ /*@null@*/ uint8_t* data;\n   61      uint16_t length;\n   62  } sdio_dma_segment_t;\n   ..\n  153  \n  154  void dma_irq ( void );\n  155: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response );\n  156  extern void wiced_platform_notify_irq( void );\n  157  \n  ...\n  376      {\n  377          /* Send CMD0 to set it to idle state */\n  378:         host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_0, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  379  \n  380          /* CMD5. */\n  381:         host_platform_sdio_transfer( BUS_READ, SDIO_CMD_5, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  382  \n  383          /* Send CMD3 to get RCA. */\n  ...\n  392  \n  393      /* Send CMD7 with the returned RCA to select the card */\n  394:     host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_7, SDIO_BYTE_MODE, SDIO_1B_BLOCK, data, 0, 0, RESPONSE_NEEDED, NULL );\n  395  \n  396      return kNoErr;\n  ...\n  437  }\n  438  \n  439: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response )\n  440  {\n  441      uint32_t loop_count = 0;\n  ...\n  443      uint16_t attempts = 0;\n  444  \n  445:     check_string(!((command == SDIO_CMD_53) && (data == NULL)), \"Bad args\" );\n  446  \n  447:     if ( response != NULL )\n  448      {\n  449          *response = 0;\n  ...\n  547      }\n  548  \n  549:     if ( response != NULL )\n  550      {\n  551          *response = SDIO->RESP1;\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/peripherals/platform_adc.c:\n   85      platform_mcu_powersave_disable();\n   86  \n   87:     require_action_quiet( adc != NULL, exit, err = kParamErr);\n   88      \n   89      /* Enable peripheral clock for this port */\n   ..\n  139      platform_mcu_powersave_disable();\n  140  \n  141:     require_action_quiet( adc != NULL, exit, err = kParamErr);\n  142  \n  143      /* Start conversion */\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/peripherals/platform_flash.c:\n   86    OSStatus err = kNoErr;\n   87  \n   88:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n   89  \n   90    if( peripheral->flash_type == FLASH_TYPE_EMBEDDED ){\n   ..\n  110    OSStatus err = kNoErr;\n  111  \n  112:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  113    require_action( start_address >= peripheral->flash_start_addr \n  114                 && end_address   <= peripheral->flash_start_addr + peripheral->flash_length - 1, exit, err = kParamErr);\n  ...\n  137    OSStatus err = kNoErr;\n  138  \n  139:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  140    require_action( *start_address >= peripheral->flash_start_addr \n  141                 && *start_address + length <= peripheral->flash_start_addr + peripheral->flash_length, exit, err = kParamErr);\n  ...\n  165    OSStatus err = kNoErr;\n  166  \n  167:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  168    require_action( (*start_address >= peripheral->flash_start_addr) \n  169                 && (*start_address + length) <= ( peripheral->flash_start_addr + peripheral->flash_length), exit, err = kParamErr);\n  ...\n  193    OSStatus err = kNoErr;\n  194  \n  195:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  196    require_action( start_address >= peripheral->flash_start_addr \n  197                 && end_address   <= peripheral->flash_start_addr + peripheral->flash_length - 1, exit, err = kParamErr);\n  ...\n  222    OSStatus err = kNoErr;\n  223  \n  224:   require_action_quiet( peripheral != NULL, exit, err = kParamErr);\n  225    require_action( start_address >= peripheral->flash_start_addr \n  226                 && end_address   <= peripheral->flash_start_addr + peripheral->flash_length - 1, exit, err = kParamErr);\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/peripherals/platform_gpio.c:\n   93  \n   94    platform_mcu_powersave_disable();\n   95:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n   96    \n   97    port_number = platform_gpio_get_port_number( gpio->port );\n   ..\n  132  \n  133    platform_mcu_powersave_disable();\n  134:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  135  \n  136    /* Set to Input high-impedance */\n  ...\n  154    platform_mcu_powersave_disable();\n  155  \n  156:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  157  \n  158    gpio->port->BSRRL = (uint16_t) ( 1 << gpio->pin_number );\n  ...\n  167    OSStatus err = kNoErr;\n  168  \n  169:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  170  \n  171    platform_mcu_powersave_disable();\n  ...\n  184    platform_mcu_powersave_disable();\n  185  \n  186:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  187  \n  188    gpio->port->ODR ^= (uint16_t) ( 1 << gpio->pin_number );\n  ...\n  199    platform_mcu_powersave_disable();\n  200  \n  201:   require_quiet( gpio != NULL, exit);\n  202  \n  203    result = ( ( gpio->port->IDR & (uint32_t) ( 1 << gpio->pin_number ) ) != 0 ) ? true : false;\n  ...\n  224  \n  225    platform_mcu_powersave_disable();\n  226:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  227  \n  228    switch ( trigger )\n  ...\n  321  \n  322    platform_mcu_powersave_disable();\n  323:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  324  \n  325    interrupt_line = (uint16_t) ( 1 << gpio->pin_number );\n  ...\n  422    OSStatus    err = kNoErr;\n  423  \n  424:   require_action_quiet( gpio != NULL, exit, err = kParamErr);\n  425    \n  426    /* Enable peripheral clock for this port */\n  ...\n  515  \n  516      /* Call the respective GPIO interrupt handler/callback */\n  517:     if ( gpio_irq_data[gpio_number].handler != NULL )\n  518      {\n  519          void * arg = gpio_irq_data[gpio_number].arg; /* Avoids undefined order of access to volatiles */\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/peripherals/platform_i2c.c:\n   87  \n   88    platform_mcu_powersave_disable( );\n   89:   require_action_quiet( i2c != NULL, exit, err = kParamErr);\n   90    \n   91    // Init I2C GPIO clocks\n   ..\n  200    platform_mcu_powersave_disable();\n  201  \n  202:   require_action_quiet( i2c != NULL, exit, err = kParamErr);\n  203  \n  204    err = i2c_address_device( i2c, config, retries, I2C_Direction_Transmitter );\n  ...\n  507      OSStatus err;\n  508  \n  509:     if ( message->tx_buffer != NULL )\n  510      {\n  511          err = i2c_tx_no_dma( i2c, config, message );\n  ...\n  516      }\n  517  \n  518:     if ( message->rx_buffer != NULL )\n  519      {\n  520          err = i2c_rx_no_dma( i2c, config, message );\n  ...\n  537    OSStatus err = kNoErr;\n  538  \n  539:   require_action_quiet( ( message != NULL ) && ( tx_buffer != NULL ) && ( tx_buffer_length != 0 ), exit, err = kParamErr);\n  540  \n  541    memset(message, 0x00, sizeof(platform_i2c_message_t));\n  ...\n  552    OSStatus err = kNoErr;\n  553  \n  554:   require_action_quiet( ( message != NULL ) && ( rx_buffer != NULL ) && ( rx_buffer_length != 0 ), exit, err = kParamErr);\n  555  \n  556    memset(message, 0x00, sizeof(platform_i2c_message_t));\n  ...\n  567    OSStatus err = kNoErr;\n  568  \n  569:   require_action_quiet( ( message != NULL ) && ( tx_buffer != NULL ) && ( tx_buffer_length != 0 ) && ( rx_buffer != NULL ) && ( rx_buffer_length != 0 ), exit, err = kParamErr);\n  570  \n  571    memset(message, 0x00, sizeof(platform_i2c_message_t));\n  ...\n  587    platform_mcu_powersave_disable();\n  588    \n  589:   require_action_quiet( i2c != NULL, exit, err = kParamErr);\n  590    \n  591    for( i=0; i < number_of_messages; i++ )\n  ...\n  612    platform_mcu_powersave_disable();\n  613  \n  614:   require_action_quiet( i2c != NULL, exit, err = kParamErr);\n  615  \n  616    /* Disable I2C peripheral clocks */\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/peripherals/platform_pwm.c:\n   69    OSStatus                err                 = kNoErr;\n   70    \n   71:   require_action_quiet( pwm != NULL, exit, err = kParamErr);\n   72  \n   73    platform_mcu_powersave_disable();\n   ..\n  150    platform_mcu_powersave_disable();\n  151  \n  152:   require_action_quiet( pwm != NULL, exit, err = kParamErr);\n  153    \n  154    TIM_Cmd( pwm->tim, ENABLE );\n  ...\n  166    platform_mcu_powersave_disable();\n  167  \n  168:   require_action_quiet( pwm != NULL, exit, err = kParamErr);\n  169    \n  170    TIM_CtrlPWMOutputs( pwm->tim, DISABLE );\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/peripherals/platform_rng.c:\n   66      uint32_t *pWord = inBuffer;\n   67      uint32_t tempRDM;\n   68:     uint8_t *pByte = NULL;\n   69      int inWordCount;\n   70      int remainByteCount;\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/peripherals/platform_spi.c:\n  130    platform_mcu_powersave_disable();\n  131    \n  132:   require_action_quiet( ( driver != NULL ) && ( peripheral != NULL ) && ( config != NULL ), exit, err = kParamErr);\n  133  \n  134  /* Calculate prescaler */\n  ...\n  261    platform_mcu_powersave_disable();\n  262    \n  263:   require_action_quiet( ( driver != NULL ) && ( config != NULL ) && ( segments != NULL ) && ( number_of_segments != 0 ), exit, err = kParamErr);\n  264    \n  265    /* Activate chip select */\n  ...\n  294            uint16_t data = 0xFF;\n  295            \n  296:           if ( send_ptr != NULL )\n  297            {\n  298              data = *send_ptr++;\n  ...\n  301            data = spi_transfer( driver->peripheral, data );\n  302            \n  303:           if ( rcv_ptr != NULL )\n  304            {\n  305              *rcv_ptr++ = (uint8_t)data;\n  ...\n  321            uint16_t data = 0xFFFF;\n  322            \n  323:           if ( send_ptr != NULL )\n  324            {\n  325              data = *send_ptr++;\n  ...\n  328            data = spi_transfer( driver->peripheral, data );\n  329            \n  330:           if ( rcv_ptr != NULL )\n  331            {\n  332              *rcv_ptr++ = data;\n  ...\n  373    OSStatus err = kNoErr;\n  374    \n  375:   require_action_quiet( prescaler != NULL, exit, err = kParamErr);\n  376    \n  377    for( i = 0 ; i < MAX_NUM_SPI_PRESCALERS ; i++ )\n  ...\n  426    dma_init.DMA_PeripheralBurst    = DMA_PeripheralBurst_Single;\n  427    \n  428:   if ( message->tx_buffer != NULL )\n  429    {\n  430      dma_init.DMA_Memory0BaseAddr = ( uint32_t )message->tx_buffer;\n  ...\n  459    dma_init.DMA_MemoryBurst        = DMA_MemoryBurst_Single;\n  460    dma_init.DMA_PeripheralBurst    = DMA_PeripheralBurst_Single;\n  461:   if ( message->rx_buffer != NULL )\n  462    {\n  463      dma_init.DMA_Memory0BaseAddr = (uint32_t)message->rx_buffer;\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/peripherals/platform_uart.c:\n  136    platform_mcu_powersave_disable();\n  137  \n  138:   require_action_quiet( ( driver != NULL ) && ( peripheral != NULL ) && ( config != NULL ), exit, err = kParamErr);\n  139:   require_action_quiet( (optional_ring_buffer == NULL) || ((optional_ring_buffer->buffer != NULL ) && (optional_ring_buffer->size != 0)), exit, err = kParamErr);\n  140    \n  141    uart_number = platform_uart_get_port_number( peripheral->port );\n  ...\n  160    platform_gpio_set_alternate_function( peripheral->pin_rx->port, peripheral->pin_rx->pin_number, GPIO_OType_PP, GPIO_PuPd_UP, uart_alternate_functions[ uart_number ] );\n  161  \n  162:   if ( ( peripheral->pin_cts != NULL ) && ( config->flow_control == FLOW_CONTROL_CTS || config->flow_control == FLOW_CONTROL_CTS_RTS ) )\n  163    {\n  164        platform_gpio_set_alternate_function( peripheral->pin_cts->port, peripheral->pin_cts->pin_number, GPIO_OType_PP, GPIO_PuPd_NOPULL, uart_alternate_functions[ uart_number ] );\n  165    }\n  166  \n  167:   if ( ( peripheral->pin_rts != NULL ) && ( config->flow_control == FLOW_CONTROL_RTS || config->flow_control == FLOW_CONTROL_CTS_RTS ) )\n  168    {\n  169        platform_gpio_set_alternate_function( peripheral->pin_rts->port, peripheral->pin_rts->pin_number, GPIO_OType_PP, GPIO_PuPd_NOPULL, uart_alternate_functions[ uart_number ] );\n  ...\n  173    if(config->flags & UART_WAKEUP_ENABLE){\n  174      mico_rtos_init_semaphore( driver->sem_wakeup, 1 );\n  175:     mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"UART_WAKEUP\", thread_wakeup, 0x100, driver);\n  176    }\n  177  #endif\n  ...\n  309  \n  310    /* Setup ring buffer */\n  311:   if ( optional_ring_buffer != NULL )\n  312    {\n  313      /* Note that the ring_buffer should've been initialised first */\n  ...\n  338    platform_mcu_powersave_disable();\n  339  \n  340:   require_action_quiet( ( driver != NULL ), exit, err = kParamErr);\n  341  \n  342    uart_number = platform_uart_get_port_number( driver->peripheral->port );\n  ...\n  403  #endif\n  404  \n  405:   require_action_quiet( ( driver != NULL ) && ( data_out != NULL ) && ( size != 0 ), exit, err = kParamErr);\n  406  \n  407    /* Clear interrupt status before enabling DMA otherwise error occurs immediately */\n  ...\n  450    //platform_mcu_powersave_disable();\n  451  \n  452:   require_action_quiet( ( driver != NULL ) && ( data_in != NULL ) && ( expected_data_size != 0 ), exit, err = kParamErr);\n  453  \n  454:   if ( driver->rx_buffer != NULL)\n  455    {\n  456      while ( expected_data_size != 0 )\n  ...\n  517    OSStatus err = kNoErr;\n  518  \n  519:   if ( driver->rx_buffer != NULL )\n  520    {\n  521      driver->peripheral->rx_dma_config.stream->CR |= DMA_SxCR_CIRC;\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/peripherals/platform_watchdog.c:\n   57  static __IO uint32_t CaptureNumber = 0, PeriodValue = 0;\n   58  #ifndef NO_MICO_RTOS\n   59: static mico_semaphore_t  _measureLSIComplete_SEM = NULL;\n   60  #else\n   61  volatile static bool _measureLSIComplete_SEM = false;\n   ..\n  197    mico_rtos_get_semaphore(&_measureLSIComplete_SEM, MICO_WAIT_FOREVER);\n  198    mico_rtos_deinit_semaphore( &_measureLSIComplete_SEM );\n  199:   _measureLSIComplete_SEM = NULL;\n  200  #else\n  201    while( _measureLSIComplete_SEM == false);\n  ...\n  262        /* Compute the period length */\n  263        PeriodValue = (uint16_t)(0xFFFF - tmpCC4[0] + tmpCC4[1] + 1);\n  264:       if(_measureLSIComplete_SEM != NULL){\n  265  #ifndef NO_MICO_RTOS\n  266          mico_rtos_set_semaphore(&_measureLSIComplete_SEM);\n\n/Users/William/Develop/MiCO/Platform/MCU/STM32F4xx/wlan_bus_driver/wlan_bus_sdio.c:\n   58  typedef struct\n   59  {\n   60:     /*@shared@*/ /*@null@*/ uint8_t* data;\n   61      uint16_t length;\n   62  } sdio_dma_segment_t;\n   ..\n  153  \n  154  void dma_irq ( void );\n  155: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response );\n  156  extern void wiced_platform_notify_irq( void );\n  157  \n  ...\n  376      {\n  377          /* Send CMD0 to set it to idle state */\n  378:         host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_0, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  379  \n  380          /* CMD5. */\n  381:         host_platform_sdio_transfer( BUS_READ, SDIO_CMD_5, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  382  \n  383          /* Send CMD3 to get RCA. */\n  ...\n  392  \n  393      /* Send CMD7 with the returned RCA to select the card */\n  394:     host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_7, SDIO_BYTE_MODE, SDIO_1B_BLOCK, data, 0, 0, RESPONSE_NEEDED, NULL );\n  395  \n  396      return kNoErr;\n  ...\n  437  }\n  438  \n  439: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response )\n  440  {\n  441      uint32_t loop_count = 0;\n  ...\n  443      uint16_t attempts = 0;\n  444  \n  445:     check_string(!((command == SDIO_CMD_53) && (data == NULL)), \"Bad args\" );\n  446  \n  447:     if ( response != NULL )\n  448      {\n  449          *response = 0;\n  ...\n  547      }\n  548  \n  549:     if ( response != NULL )\n  550      {\n  551          *response = SDIO->RESP1;\n\n/Users/William/Develop/MiCO/Platform/RVMDK/Retarget.c:\n   82              s1++;  \n   83          }  \n   84:         return NULL;  \n   85      }  \n   86      else  \n   ..\n  109      return strchr (s, '\\0');\n  110  \n  111:   found = NULL;\n  112:   while ((p = strchr (s, c)) != NULL)\n  113      {\n  114        found = p;\n  ...\n  137        return (void *) char_ptr;\n  138      else if (*char_ptr == '\\0')\n  139:       return NULL;\n  140  \n  141    /* All these elucidatory comments refer to 4-byte longwords,\n  ...\n  233  	    return (char *) cp;\n  234  	  else if (*cp == '\\0')\n  235: 	    return NULL;\n  236  	  if (*++cp == c)\n  237  	    return (char *) cp;\n  238  	  else if (*cp == '\\0')\n  239: 	    return NULL;\n  240  	  if (*++cp == c)\n  241  	    return (char *) cp;\n  242  	  else if (*cp == '\\0')\n  243: 	    return NULL;\n  244  	  if (*++cp == c)\n  245  	    return (char *) cp;\n  246  	  else if (*cp == '\\0')\n  247: 	    return NULL;\n  248  	  if (sizeof (longword) > 4)\n  249  	    {\n  ...\n  251  		return (char *) cp;\n  252  	      else if (*cp == '\\0')\n  253: 		return NULL;\n  254  	      if (*++cp == c)\n  255  		return (char *) cp;\n  256  	      else if (*cp == '\\0')\n  257: 		return NULL;\n  258  	      if (*++cp == c)\n  259  		return (char *) cp;\n  260  	      else if (*cp == '\\0')\n  261: 		return NULL;\n  262  	      if (*++cp == c)\n  263  		return (char *) cp;\n  264  	      else if (*cp == '\\0')\n  265: 		return NULL;\n  266  	    }\n  267  	}\n  ...\n  380      }\n  381  \n  382:   return NULL;\n  383  }\n  384  //mxchipWNET.o\n  ...\n  389  __weak void *__iar_dlmallinfo(void)\n  390  {\n  391:     return NULL;\n  392  }\n  393  \n  ...\n  418    char *dst;\n  419    \n  420:   if (src == NULL)\n  421:     return NULL;\n  422    \n  423    if (src[0] == 0)\n  424:     return NULL;\n  425    \n  426    len = strlen(src) + 1;\n\n/Users/William/Develop/MiCO/Platform/vendor/Freescale/MK64FxxL12/k64_gpio.c:\n  298              for ( line = 0; line < GPIO_LINES_PER_PORT; line++, status >>= 1 )\n  299              {\n  300:                 if ( ( status & 0x1 ) != 0 && ( gpio_irq_data[gpio].data[line].callback != NULL ) )\n  301                  {\n  302                      gpio_irq_data[gpio].data[line].callback( gpio_irq_data[gpio].data[line].arg );\n\n/Users/William/Develop/MiCO/Platform/vendor/Freescale/MK64FxxL12/ksdk_platform.c:\n  172  #endif\n  173     dbg_uart_init(); \n  174:   // MicoStdioUartInitialize(&stdio_uart_config,NULL);\n  175  #endif\n  176  }\n\n/Users/William/Develop/MiCO/Platform/vendor/Freescale/MK64FxxL12/MicoDriverUart.c:\n  172      current_uart = uart;\n  173      mico_rtos_init_semaphore( &uart_interfaces[uart].sem_wakeup, 1 );\n  174:     mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"UART_WAKEUP\", thread_wakeup, 0x100, &current_uart);\n  175    }\n  176  #endif \n  ...\n  197  #endif\n  198  #if RING_BUFF_ON \n  199:   if (optional_rx_buffer != NULL)\n  200    {\n  201       //  Note that the ring_buffer should've been initialised first\n  ...\n  345  {\n  346  #if RING_BUFF_ON\n  347:   if (uart_interfaces[uart].rx_buffer != NULL)\n  348    {\n  349      while (size != 0)\n\n/Users/William/Develop/MiCO/Platform/vendor/Freescale/MK64FxxL12/SSD_FTFx_Common.h:\n  195  /*--------------------- CallBack function period -----------------------*/\n  196  #define FLASH_CALLBACK_CS               10          /* Check Sum */\n  197: /*--------------------Null Callback function defination ----------------*/\n  198: #define NULL_CALLBACK                   ((PCALLBACK)0xFFFFFFFF)\n  199: #define NULL_SWAP_CALLBACK              ((PFLASH_SWAP_CALLBACK)0xFFFFFFFF)       \n  200  \n  201  /*------------------- Setting flash interrupt macro --------------------*/\n\n/Users/William/Develop/MiCO/Platform/vendor/Freescale/MK64FxxL12/SSD_FTFx_Internal.h:\n   59  0.2.4       12.23.2011      FPT Team      Update to support more Kinetis derivatives.  \n   60  0.2.5       04.26.2012      FPT Team      Update to support swap in FTFx_KX_512K_0K_0K_2K_0K derivative     \n   61:                                           Add definition of NULL_SWAP_CALLBACK to \n   62:                                           fix incompatible function type of null pointer bug in IAR compiler\n   63  0.3.1        05.16.2012     FPT Team      Update to support \n   64                                            FTFx_NX_256K_32K_2K_2K_1K\n\n/Users/William/Develop/MiCO/Platform/vendor/Freescale/MK64FxxL12/EMW1062_Driver/SDIO/wlan_bus.c:\n  143  typedef struct\n  144  {\n  145:     /*@shared@*/ /*@null@*/ uint8_t* data;\n  146      uint16_t length;\n  147  } sdio_dma_segment_t;\n  ...\n  172  \n  173  void dma_irq ( void );\n  174: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response );\n  175  extern void wiced_platform_notify_irq( void );\n  176  \n  ...\n  394      {\n  395          /* Send CMD0 to set it to idle state */\n  396:         host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_0, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  397  \n  398          /* CMD5. */\n  399:         host_platform_sdio_transfer( BUS_READ, SDIO_CMD_5, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  400  \n  401          /* Send CMD3 to get RCA. */\n  ...\n  410  \n  411      /* Send CMD7 with the returned RCA to select the card */\n  412:     host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_7, SDIO_BYTE_MODE, SDIO_1B_BLOCK, data, 0, 0, RESPONSE_NEEDED, NULL );\n  413  \n  414      return kNoErr;\n  ...\n  462  }\n  463  \n  464: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response )\n  465  {\n  466      uint32_t loop_count = 0;\n  ...\n  468      uint16_t attempts = 0;\n  469  \n  470:     check_string(!((command == SDIO_CMD_53) && (data == NULL)), \"Bad args\" );\n  471  \n  472:     if ( response != NULL )\n  473      {\n  474          *response = 0;\n  ...\n  572      }\n  573  \n  574:     if ( response != NULL )\n  575      {\n  576          *response = SDIO->RESP1;\n\n/Users/William/Develop/MiCO/Platform/vendor/Freescale/MK64FxxL12/EMW1062_Driver/SPI/wwd_bus.c:\n  104      /* Allocate more than enough memory. */\n  105      char *temp = (char *)OSA_MemAlloc(ptrSize + (alignment - 1));\n  106:     if(temp == NULL)\n  107      {\n  108:         return NULL;  /* Return NULL if not enough space for allocation request. */\n  109      }\n  110  \n  ...\n  134      char count;\n  135  \n  136:     if(ptr != NULL)\n  137      {\n  138          char *temp = ptr;\n  ...\n  147          }\n  148          OSA_MemFree(temp);\n  149:         temp = NULL;\n  150      }\n  151  \n  ...\n  171                       loopSetup->watermark, loopSetup->length, loopSetup->period);\n  172  \n  173:     if(loopSetup->dmaCallBack != NULL)\n  174      {\n  175          EDMA_DRV_InstallCallback(loopSetup->dmaCh, loopSetup->dmaCallBack, loopSetup->dmaCh);\n  ...\n  246      dmaSPITX.type = kEDMAMemoryToPeripheral;\n  247      dmaSPITX.chSource = kDmaRequestMux0SPI0Tx;\n  248:     dmaSPITX.srcAddr = (uint32_t)NULL;\n  249      dmaSPITX.destAddr = (uint32_t)&SPI0->PUSHR;\n  250      dmaSPITX.length = 0;\n  ...\n  260      dmaSPIRX.chSource = kDmaRequestMux0SPI0Rx;\n  261      dmaSPIRX.srcAddr = (uint32_t)&SPI0->POPR;\n  262:     dmaSPIRX.destAddr = (uint32_t)NULL;\n  263      dmaSPIRX.length = 0;\n  264      dmaSPIRX.size = 1;\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/lpc1800_freertos.c:\n  567  		// SPI_TXCTL_EOT |			/* Enable this to assert and deassert SSEL for each individual byte/word, current slave functions for this example do not support this */\n  568  		// SPI_TXCTL_EOF |			/* Insert a delay between bytes/words as defined by frame delay time */\n  569: 		// SPI_TXCTL_RXIGNORE |		/* Enable this to ignore incoming data, or set spiMasterXfer.pRXData16 to NULL to ignore RX data  */\n  570  		0;\n  571  \n  ...\n  713            // SPI_TXCTL_EOT |			/* Enable this to assert and deassert SSEL for each individual byte/word, current slave functions for this example do not support this */\n  714            // SPI_TXCTL_EOF |			/* Insert a delay between bytes/words as defined by frame delay time */\n  715:           // SPI_TXCTL_RXIGNORE |		/* Enable this to ignore incoming data, or set spiMasterXfer.pRXData16 to NULL to ignore RX data  */\n  716            0;\n  717  \n  ...\n  749    \n  750  #ifndef ATH_SPI_DMA\n  751:   spiMasterXfer.pTXData8 = NULL;\n  752    spiMasterXfer.txCount = length;/* Count is in transfer size */	\n  753    spiMasterXfer.pRXData8 = pBuffer;\n  ...\n  872  \n  873  #ifndef ATH_SPI_DMA\n  874:   spiMasterXfer.pTXData8 = NULL;\n  875    spiMasterXfer.txCount = length;/* Count is in transfer size */	\n  876    spiMasterXfer.pRXData8 = pBuffer;\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/lpc_mico.c:\n  501  		// SPI_TXCTL_EOT |			/* Enable this to assert and deassert SSEL for each individual byte/word, current slave functions for this example do not support this */\n  502  		// SPI_TXCTL_EOF |			/* Insert a delay between bytes/words as defined by frame delay time */\n  503: 		// SPI_TXCTL_RXIGNORE |		/* Enable this to ignore incoming data, or set spiMasterXfer.pRXData16 to NULL to ignore RX data  */\n  504  		0;\n  505  \n  ...\n  647            // SPI_TXCTL_EOT |			/* Enable this to assert and deassert SSEL for each individual byte/word, current slave functions for this example do not support this */\n  648            // SPI_TXCTL_EOF |			/* Insert a delay between bytes/words as defined by frame delay time */\n  649:           // SPI_TXCTL_RXIGNORE |		/* Enable this to ignore incoming data, or set spiMasterXfer.pRXData16 to NULL to ignore RX data  */\n  650            0;\n  651  \n  ...\n  683    \n  684  #ifndef ATH_SPI_DMA\n  685:   spiMasterXfer.pTXData8 = NULL;\n  686    spiMasterXfer.txCount = length;/* Count is in transfer size */	\n  687    spiMasterXfer.pRXData8 = pBuffer;\n  ...\n  806  \n  807  #ifndef ATH_SPI_DMA\n  808:   spiMasterXfer.pTXData8 = NULL;\n  809    spiMasterXfer.txCount = length;/* Count is in transfer size */	\n  810    spiMasterXfer.pRXData8 = pBuffer;\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/MicoDriverUart.c:\n  236      current_uart = uart;\n  237      mico_rtos_init_semaphore( &uart_interfaces[uart].sem_wakeup, 1 );\n  238:     mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"UART_WAKEUP\", thread_wakeup, 0x100, &current_uart);\n  239    }\n  240  #endif\n  ...\n  282  /*\n  283    Chip_DMA_InitChannel( DMAREQ_UART0_RX, DMA_ADDR(&LPC_USART0->RXDATA), DMA_XFERCFG_SRCINC_0, \n  284:                         DMA_ADDR(NULL), DMA_XFERCFG_DSTINC_1, WIDTH_8_BITS,\n  285                          0, (DMA_CFG_PERIPHREQEN | DMA_CFG_BURSTPOWER_1 | DMA_CFG_CHPRIORITY(3)));\n  286    Chip_DMA_StartTransfer(DMAREQ_UART0_RX, DMA_XFERCFG_SRCINC_0, DMA_XFERCFG_DSTINC_1, DMA_XFERCFG_WIDTH_8, 0);\n  ...\n  288    Chip_UART_ClearStatus(LPC_USART0, UART_STAT_OVERRUNINT|UART_STAT_DELTARXBRK|UART_STAT_FRM_ERRINT|UART_STAT_PAR_ERRINT|UART_STAT_RXNOISEINT);\n  289    \n  290:   Chip_DMA_InitChannel( DMAREQ_UART0_TX, DMA_ADDR(NULL), DMA_XFERCFG_SRCINC_1,\n  291                          DMA_ADDR(&LPC_USART0->TXDATA), DMA_XFERCFG_DSTINC_0, WIDTH_8_BITS,\n  292                          0, (DMA_CFG_PERIPHREQEN | DMA_CFG_BURSTPOWER_1 | DMA_CFG_CHPRIORITY(3)));\n  293    Chip_DMA_StartTransfer(DMAREQ_UART0_TX, DMA_XFERCFG_SRCINC_1, DMA_XFERCFG_DSTINC_0, DMA_XFERCFG_WIDTH_8, 0);\n  294  */    \n  295:   if (optional_rx_buffer != NULL)\n  296    {\n  297       /* Note that the ring_buffer should've been initialised first */\n  ...\n  379  OSStatus MicoUartRecv( mico_uart_t uart, void* data, uint32_t size, uint32_t timeout )\n  380  {  \n  381:   if (uart_interfaces[uart].rx_buffer != NULL)\n  382    {\n  383      while (size != 0)\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/EMW1062_Driver/SDIO/wlan_bus.c:\n  143  typedef struct\n  144  {\n  145:     /*@shared@*/ /*@null@*/ uint8_t* data;\n  146      uint16_t length;\n  147  } sdio_dma_segment_t;\n  ...\n  172  \n  173  void dma_irq ( void );\n  174: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response );\n  175  extern void wiced_platform_notify_irq( void );\n  176  \n  ...\n  394      {\n  395          /* Send CMD0 to set it to idle state */\n  396:         host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_0, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  397  \n  398          /* CMD5. */\n  399:         host_platform_sdio_transfer( BUS_READ, SDIO_CMD_5, SDIO_BYTE_MODE, SDIO_1B_BLOCK, 0, 0, 0, NO_RESPONSE, NULL );\n  400  \n  401          /* Send CMD3 to get RCA. */\n  ...\n  410  \n  411      /* Send CMD7 with the returned RCA to select the card */\n  412:     host_platform_sdio_transfer( BUS_WRITE, SDIO_CMD_7, SDIO_BYTE_MODE, SDIO_1B_BLOCK, data, 0, 0, RESPONSE_NEEDED, NULL );\n  413  \n  414      return kNoErr;\n  ...\n  462  }\n  463  \n  464: OSStatus host_platform_sdio_transfer( bus_transfer_direction_t direction, sdio_command_t command, sdio_transfer_mode_t mode, sdio_block_size_t block_size, uint32_t argument, /*@null@*/ uint32_t* data, uint16_t data_size, sdio_response_needed_t response_expected, /*@out@*/ /*@null@*/ uint32_t* response )\n  465  {\n  466      uint32_t loop_count = 0;\n  ...\n  468      uint16_t attempts = 0;\n  469  \n  470:     check_string(!((command == SDIO_CMD_53) && (data == NULL)), \"Bad args\" );\n  471  \n  472:     if ( response != NULL )\n  473      {\n  474          *response = 0;\n  ...\n  572      }\n  573  \n  574:     if ( response != NULL )\n  575      {\n  576          *response = SDIO->RESP1;\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/NXP_drivers/chip_540xx/dma_540xx.h:\n  692   *			If using this function to write the initial transfer descriptor in\n  693   *			a linked list or ping-pong buffer configuration, it should contain a\n  694:  *			non-NULL 'next' field pointer.\n  695   */\n  696  bool Chip_DMA_SetupTranChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch, DMA_CHDESC_T *desc);\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/NXP_drivers/chip_540xx/spi_540xx.c:\n  242  	}\n  243  \n  244: 	if (pXfSetup->pRx == NULL) {\n  245  		if ((Status & SPI_STAT_TXRDY) && (pXfSetup->TxCnt < pXfSetup->Length)) {\n  246  			SPI_Send_Data_RxIgnore(pSPI, pXfSetup);\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/NXP_drivers/chip_540xx/spim_540xx.c:\n  151  		if (xfer->txCount > 0) {\n  152  			/* Send 0 if ignoring transmit */\n  153: 			if (xfer->pTXData8 == NULL) {\n  154  				data = 0;\n  155  			}\n  ...\n  179  \n  180  		/* Only copy data when not ignoring receive */\n  181: 		if (xfer->pRXData8 != NULL) {\n  182  			/* Enough size in current buffers? */\n  183  			if (xfer->rxCount == 0) {\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/NXP_drivers/chip_540xx/spim_540xx.h:\n  175  typedef struct SPIM_XFER {\n  176  	const SPIM_CALLBACKS_T *pCB;	/** Pointer to SPI master data callback functions */\n  177: 	union {							/** Pointer to receive buffer, set to NULL to toss receeive data */\n  178  		uint8_t *pRXData8;			/** Receive buffer used with data transfer size <= 8-bits, modified by driver */\n  179  		uint16_t *pRXData16;		/** Receive buffer used with data transfer size > 8-bits, modified by driver */\n  180  	};\n  181  \n  182: 	union {							/** Pointer to transmit buffer, set to NULL to transmit 0x0 */\n  183  		uint8_t *pTXData8;			/** Send buffer used with data transfer size <= 8-bits, modified by driver */\n  184  		uint16_t *pTXData16;		/** Send buffer used with data transfer size > 8-bits, modified by driver */\n  ...\n  230   * mxfer.pTXData8 = SendBuffer;\n  231   * mxfer.txCount = 16; // Number of bytes to send before SPIMasterXferSend callback is called\n  232:  * mxfer.pRXData8 = RecvBuffer; // Will not receive data if pRXData8/pRXData16 is NULL or SPI_TXCTL_RXIGNORE option is set\n  233   * mxfer.rxCount = 16; // Number of bytes to receive before SPIMasterXferRecv callback is called\n  234   * Chip_SPIM_Xfer(LPC_SPI0, &mxfer); // Start transfer\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/NXP_drivers/chip_540xx/spis_540xx.c:\n  104  \n  105  		/* Send 0 on empty buffer or count */\n  106: 		if ((xfer->txCount == 0) || (xfer->pTXData8 == NULL)) {\n  107  			data = 0;\n  108  		}\n  ...\n  131  \n  132  		/* Only copy data when not ignoring receive */\n  133: 		if (xfer->pRXData8 != NULL) {\n  134  			/* Enough size in current buffers? */\n  135  			if (xfer->rxCount == 0) {\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/NXP_drivers/chip_540xx/spis_540xx.h:\n   82  typedef struct SPIS_XFER {\n   83  	const SPIS_CALLBACKS_T *pCB;	/** Pointer to SPI slave callback functions */\n   84: 	union {							/** Pointer to receive buffer, set to NULL to toss receeive data */\n   85  		uint8_t *pRXData8;			/** Receive buffer used with data transfer size <= 8-bits, modified by driver */\n   86  		uint16_t *pRXData16;		/** Receive buffer used with data transfer size > 8-bits, modified by driver */\n   87  	};\n   88  \n   89: 	union {							/** Pointer to transmit buffer, set to NULL to transmit 0x0 */\n   90  		uint8_t *pTXData8;			/** Send buffer used with data transfer size <= 8-bits, modified by driver */\n   91  		uint16_t *pTXData16;		/** Send buffer used with data transfer size > 8-bits, modified by driver */\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/NXP_drivers/chip_540xx/vfifo_540xx.c:\n  157  	uint32_t i;\n  158  \n  159: 	if ( pXfSetup->pRx == NULL ) {\n  160  		txctrl = SPI_TXCTL_FLEN(pXfSetup->DataSize-1)|SPI_TXCTL_ASSERT_SSEL|SPI_TXCTL_EOF|SPI_TXCTL_RXIGNORE;\n  161  	}\n  ...\n  176  				Chip_VFIFO_SendSPIDataCtrl(LPC_VFIFO, spi_num, txctrl | SPI_TXCTL_EOT | SPI_TXDAT_DATA(pXfSetup->pTx[pXfSetup->TxCnt++]));\n  177  				Chip_VFIFO_ClearSPIStatus(LPC_VFIFO, spi_num, VFIFO_ST_RXTIMEOUT|VFIFO_ST_BUSERROR);\n  178: 				if ( pXfSetup->pRx == NULL ) {\n  179  					/* This is the end of transfer on TX, if RX_IGNORE is set, transfer has completed. */\n  180  					pXfSetup->completion_flag = 1;\n  ...\n  189  	}\n  190  	/* Handle receive interrupt */\n  191: 	if ((Status & VFIFO_ST_RXTHRESHOLD) && (pXfSetup->pRx != NULL)) {\n  192  		for ( i = 0; i < (Chip_VFIFO_GetSPI_RXThreshold(LPC_VFIFO, spi_num) + 1); i++ ) {\n  193  			if ( pXfSetup->RxCnt < pXfSetup->Length ) {\n\n/Users/William/Develop/MiCO/Platform/vendor/nxp/LPC54xx/NXP_drivers/chip_common/lpc_types.h:\n  129  #define _BITMASK(field_width) ( _BIT(field_width) - 1)\n  130  \n  131: /* NULL pointer */\n  132: #ifndef NULL\n  133: #define NULL ((void *) 0)\n  134  #endif\n  135  \n\n/Users/William/Develop/MiCO/Platform/vendor/Sample/Sample01/MicoDriverUart.c:\n  140      current_uart = uart;\n  141      mico_rtos_init_semaphore( &uart_interfaces[uart].sem_wakeup, 1 );\n  142:     mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"UART_WAKEUP\", thread_wakeup, 0x100, &current_uart);\n  143    }\n  144  #endif \n  ...\n  167  #endif\n  168  #if RING_BUFF_ON \n  169:   if (optional_rx_buffer != NULL)\n  170    {\n  171       //  Note that the ring_buffer should've been initialised first\n  ...\n  331      uart = MICO_UART_1; //test\n  332  #if RING_BUFF_ON\n  333:   if (uart_interfaces[uart].rx_buffer != NULL)\n  334    {\n  335      while (size != 0)\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/updates.txt:\n   15  R0.09a, Aug 27, 2012\n   16    Fixed assertion failure due to OS/2 EA on FAT12/16.\n   17:   Changed API rejects null object pointer to avoid crash.\n   18    Changed option name _FS_SHARE to _FS_LOCK.\n   19  \n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/chdir.html:\n   26  <dl class=\"par\">\n   27  <dt>path</dt>\n   28: <dd>Pointer to the null-terminated string that specifies a <a href=\"filename.html\">directory</a> to go.</dd>\n   29  </dl>\n   30  </div>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/chmod.html:\n   28  <dl class=\"par\">\n   29  <dt>path</dt>\n   30: <dd>Pointer to the null-terminated string that specifies an <a href=\"filename.html\">object</a> to be changed</dd>\n   31  <dt>attr</dt>\n   32  <dd>Attribute flags to be set in one or more combination of the following flags. The specified flags are set and others are cleard.<br>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/dioctl.html:\n   32  <dd>Specifies the command code.</dd>\n   33  <dt>buff</dt>\n   34: <dd>Pointer to the parameter buffer depends on the command code. Set NULL if not used.</dd>\n   35  </dl>\n   36  </div>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/getfree.html:\n   28  <dl class=\"par\">\n   29  <dt>path</dt>\n   30: <dd>Pinter to the null-terminated string that specifies the <a href=\"filename.html\">logical drive</a>. A null-string means the default drive.</dd>\n   31  <dt>nclst</dt>\n   32  <dd>Pointer to the <tt>DWORD</tt> variable to store number of free clusters.</dd>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/getlabel.html:\n   28  <dl class=\"par\">\n   29  <dt>path</dt>\n   30: <dd>Pointer to the null-terminated string that specifies the <a href=\"filename.html\">logical drive</a>. Null-string specifies the default drive.</dd>\n   31  <dt>buff</dt>\n   32: <dd>Pointer to the buffer to store the volume label. The buffer size must be at least 12 items. If the volume has no label, a null-string will be returned. Set null pointer if this information is not needed.</dd>\n   33  <dt>sn</dt>\n   34: <dd>Pointer to the <tt>DWORD</tt> variable to store the volume serial number. Set null pointer if this information is not needed.</dd>\n   35  </dl>\n   36  </div>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/gets.html:\n   45  <div class=\"para desc\">\n   46  <h4>Description</h4>\n   47: <p>The <tt>f_gets()</tt> function is a wrapper function of <a href=\"read.html\"><tt>f_read()</tt></a> function. The read operation continues until a <tt>'\\n'</tt> is stored, reached end of the file or the buffer is filled with <tt>len - 1</tt> characters. The read string is terminated with a <tt>'\\0'</tt>. When no character to read or any error occured during read operation, it returns a null pointer. The status of EOF and error can be examined with <tt>f_eof()</tt> and <tt>f_error()</tt> macros.</p>\n   48  <p>When FatFs is configured to Unicode API (<tt>_LFN_UNICODE == 1</tt>), data types on the srting fuctions, <tt>f_putc()</tt>, <tt>f_puts()</tt>, <tt>f_printf()</tt> and <tt>f_gets()</tt>, is also switched to Unicode. The character encoding on the file to be read/written via those functions is selected by <tt>_STRF_ENCODE</tt> option.</p>\n   49  </div>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/lseek.html:\n   55  <li>Disk full. There is insufficient free space on the volume to expand the file.</li>\n   56  </ul>\n   57: <p>Fast seek feature is enabled when <tt>_USE_FASTSEEK</tt> is set to 1 and the member <tt>cltbl</tt> in the file object is not NULL. This feature enables fast backward/long seek operations without FAT access by using cluster link map table (CLMT). It is also applied to <tt>f_read()/f_write()</tt> function. In this mode, the file cannot be expanded by <tt>f_write()/f_lseek()</tt> function.</p>\n   58  <p>The CLMT must be created in the user defined <tt>DWORD</tt> array prior to use the fast seek feature. To create the CLMT, set address of the <tt>DWORD</tt> array to the member <tt>cltbl</tt> in the file object, set the array size in unit of items into the first item and call the <tt>f_lseek()</tt> function with <tt class=\"arg\">ofs</tt><tt> = CREATE_LINKMAP</tt>. After the function succeeded and CLMT is created, no FAT access is occured in subsequent <tt>f_read()/f_write()/f_lseek()</tt> function to the file. If the function failed with <tt>FR_NOT_ENOUGH_CORE</tt>, the given array size is insufficient for the file and number of items required is returned into the first item of the array. The required array size is (number of fragments + 1) * 2 items. For example, when the file is fragmented in 5, 12 items will be required for the CLMT.</p>\n   59  </div>\n   ..\n  108      DWORD clmt[SZ_TBL];                    <span class=\"c\">/* Cluster link map table buffer */</span>\n  109  \n  110:     res = f_lseek(fp, ofs1);               <span class=\"c\">/* This is normal seek (cltbl member is nulled on file open) */</span>\n  111  \n  112      fp-&gt;cltbl = clmt;                      <span class=\"c\">/* Enable fast seek feature */</span>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/mkdir.html:\n   26  <dl class=\"par\">\n   27  <dt>path</dt>\n   28: <dd>Pointer to the null-terminated string that specifies the <a href=\"filename.html\">directory name</a> to create. </dd>\n   29  </dl>\n   30  </div>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/mkfs.html:\n   28  <dl class=\"par\">\n   29  <dt>path</dt>\n   30: <dd>Pinter to the null-terminated string that specifies the <a href=\"filename.html\">logical drive</a> to be formatted. If there is no drive number, it means the default drive.</dd>\n   31  <dt>sfd</dt>\n   32  <dd>Specifies partitioning rule (FDISK(0) or SFD(1)). This argument will be ignored on some case.</dd>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/mount.html:\n   28  <dl class=\"par\">\n   29  <dt>fatfs</dt>\n   30: <dd>Pointer to the file system object to be registered. Null pointer unregisters the registered file system object.</dd>\n   31  <dt>path</dt>\n   32: <dd>Pointer to the null-terminated string that specifies the <a href=\"filename.html\">logical drive</a>. If there is no drive number, it means the default drive.</dd>\n   33  <dt>opt</dt>\n   34  <dd>Initialization option. 0: Do not mount now (to be mounted later), 1: Force mounted the volume to check if the volume is available.</dd>\n   ..\n   54  <li>Determines the logical drive which specified by <tt class=\"arg\">path</tt>.</li>\n   55  <li>Clears and unregisters the regsitered work area of the drive.</li>\n   56: <li>Clears and registers the work area to the drive if <tt class=\"arg\">fatfs</tt> is not NULL.</li>\n   57  <li>Performs volume mount process to the drive if forced mount is specified.</li>\n   58  </ol>\n   59: <p>The file system object is the work area needed for each logical drive. It must be given to the logical drive with this function prior to use any other file functions. To unregister a work area, specify a NULL to the <tt class=\"arg\">fatfs</tt>, and then the work area can be discarded. </p>\n   60  <p>If forced mount is not specified, this function always succeeds regardless of the physical drive status due to delayed mount feature. It only clears (de-initializes) the given work area and registers its address to the internal table. No activity of the physical drive in this function. It can also be used to force de-initialized the registered work area of a logical drive. The volume mount processes, initialize the corresponding physical drive, find the FAT volume in it and initialize the work area, is performed in the subsequent file access functions when either or both of following condition is true.</p>\n   61  <ul>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/open.html:\n   30  <dd>Pointer to the blank file object structure to be created.</dd>\n   31  <dt>path</dt>\n   32: <dd>Pointer to a null-terminated string that specifies the <a href=\"filename.html\">file name</a> to create or open.</dd>\n   33  <dt>mode</dt>\n   34  <dd>Specifies the type of access and open method for the file. It is specified by a combination of following flags.<br>\n   ..\n  155  \n  156      <span class=\"c\">/* Unregister work area prior to discard it */</span>\n  157:     f_mount(NULL, \"0:\", 0);\n  158:     f_mount(NULL, \"1:\", 0);\n  159  \n  160      return (int)fr;\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/opendir.html:\n   29  <dd>Pointer to the blank directory object to be created.</dd>\n   30  <dt>path</dt>\n   31: <dd>Pinter to the null-terminated string that specifies the <a href=\"filename.html\">directory name</a> to be opened.</dd>\n   32  </dl>\n   33  </div>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/printf.html:\n   30  <dd>Pointer to the open file object structure.</dd>\n   31  <dt>fmt</dt>\n   32: <dd>Pointer to the null terminated format string.</dd>\n   33  <dt>...</dt>\n   34  <dd>Optional arguments.</dd>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/puts.html:\n   27  <dl class=\"par\">\n   28  <dt>str</dt>\n   29: <dd>Pointer to the null terminated string to be written. The null character will not be written.</dd>\n   30  <dt>fp</dt>\n   31  <dd>Pointer to the open file object structure.</dd>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/rc.html:\n   50  <dd>Any file or directory that has the same name is already existing.</dd>\n   51  <dt id=\"io\">FR_INVALID_OBJECT</dt>\n   52: <dd>The file/directory object is invalid or a null pointer is given.</dd>\n   53  <dt id=\"wp\">FR_WRITE_PROTECTED</dt>\n   54  <dd>Any write mode action against the write-protected media.</dd>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/readdir.html:\n   50  <div class=\"para desc\">\n   51  <h4>Description</h4>\n   52: <p>The <tt>f_readdir()</tt> function reads directory items, file and directory, in sequence. All items in the directory can be read by calling <tt>f_readdir()</tt> function repeatedly. When relative path feature is enabled (<tt>_FS_RPATH &gt;= 1</tt>), dot entries (\".\" and \"..\") are not filtered out and they will appear in the read items. When all directory items have been read and no item to read, a null string is returned into the <tt>fname[]</tt> without any error. When a null pointer is given to the <tt class=\"arg\">fno</tt>, the read index of the directory object is rewinded.</p>\n   53: <p>When LFN feature is enabled, <tt>lfname</tt> and <tt>lfsize</tt> in the file information structure must be initialized with valid value prior to use it. The <tt>lfname</tt> is a pointer to the LFN read buffer. The <tt>lfsize</tt> is size of the LFN read buffer in unit of <tt>TCHAR</tt>. If the LFN is not needed, set a null pointer to the <tt>lfname</tt> and the LFN is not returned. A null string will be returned into the LFN read buffer in case of following conditions.</p>\n   54  <ul>\n   55  <li>The directory item has no LFN information.</li>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/rename.html:\n   27  <dl class=\"par\">\n   28  <dt>old_name</dt>\n   29: <dd>Pointer to a null-terminated string that specifies the old <a href=\"filename.html\">object name</a> to be renamed.</dd>\n   30  <dt>new_name</dt>\n   31: <dd>Pointer to a null-terminated string tha specifies the new object name without drive number.</dd>\n   32  </dl>\n   33  </div>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/setlabel.html:\n   26  <dl class=\"par\">\n   27  <dt>name</dt>\n   28: <dd>Pointer to the null-terminated string that specifies the volume label to be set.</dd>\n   29  </dl>\n   30  </div>\n   ..\n   50  <div class=\"para desc\">\n   51  <h4>Description</h4>\n   52: <p>When the string has a drive number, the volume label will be set to the volume specified by the drive number. If the volume label is a null-string, the volume label on the volume will be removed. The format of the volume label is similar to the SFN but there are some differences shown below:</p>\n   53  <ul>\n   54  <li>11 bytes or less in length as local character code.</li>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/sfile.html:\n   32  <span class=\"k\">#endif</span>\n   33  <span class=\"k\">#if</span> _USE_FASTSEEK\n   34:     DWORD*  cltbl;        <span class=\"c\">/* Pointer to the cluster link map table (Nulled on file open) */</span>\n   35  <span class=\"k\">#endif</span>\n   36  <span class=\"k\">#if</span> _FS_LOCK\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/sfileinfo.html:\n   59  <dd>Indicates the file/directory attribute in combination of <tt>AM_DIR</tt>, <tt>AM_RDO</tt>, <tt>AM_HID</tt>, <tt>AM_SYS</tt> and <tt>AM_ARC</tt>.</dd>\n   60  <dt>fname[]</dt>\n   61: <dd>Indicates the file/directory name in 8.3 format null-terminated string. It is always returnd with upper case in non-LFN configuration but it can be returned with lower case in LFN configuration.</dd>\n   62  <dt>lfname</dt>\n   63  <dd>Pointer to the LFN buffer to store the read LFN. This member must be initialized by application prior to use this structure. Not available in non-LFN configuration.</dd>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/stat.html:\n   27  <dl class=\"par\">\n   28  <dt>path</dt>\n   29: <dd>Pointer to the null-terminated string that specifies the <a href=\"filename.html\">object</a> to get its information.</dd>\n   30  <dt>fno</dt>\n   31: <dd>Pointer to the blank <tt>FILINFO</tt> structure to store the information of the object. Set null pointer if it is not needed.</dd>\n   32  </dl>\n   33  </div>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/unlink.html:\n   26  <dl class=\"par\">\n   27  <dt>path</dt>\n   28: <dd>Pointer to the null-terminated string that specifies an <a href=\"filename.html\">object</a> to be removed.</dd>\n   29  </dl>\n   30  </div>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/en/utime.html:\n   27  <dl class=\"par\">\n   28  <dt>path</dt>\n   29: <dd>Pointer to the null-terminated string that specifies an <a href=\"filename.html\">object</a> to be changed.</dd>\n   30  <dt>fno</dt>\n   31  <dd>Pointer to the file information structure that has a timestamp to be set in member fdate and ftime. Do not care any other members.</dd>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/ja/lseek.html:\n   55  <li>t@CgfBXNtB</li>\n   56  </ul>\n   57: <p><tt>_USE_FASTSEEK</tt>1At@CEIuWFNg<tt>cltbl</tt>oNULLO(<tt>f_open()</tt>NULL)AV[NE[hBt@CNX^zu(CLMT)AFATANZXV[NOEV[Ns@\\BV[NE[hA<tt>f_read()/f_wtite()</tt>KpBV[NE[h<tt>f_wtite()/f_lseek()</tt>t@CETCYgB</p>\n   58  <p>V[NsOACLMTKvBACLMTi[obt@(<tt>DWORD</tt>^z)A<tt>cltbl</tt>o|C^ZbgBAzvfzTCY(vf)A<tt>f_lseek()</tt><tt class=\"arg\">ofs</tt><tt>CREATE_LINKMAP</tt>woBCLMTA~<tt>f_read()/f_write()/f_lseek()</tt>FATANZXB<tt>FR_NOT_ENOUGH_CORE</tt>szTCYsAvfKvvfBKvvfA(t@C + 1) * 2 BAt@C5tOgfKvvfA12B</p>\n   59  </div>\n   ..\n  108      DWORD clmt[SZ_TBL];                    <span class=\"c\">/* NE}bvEe[ui[obt@ */</span>\n  109  \n  110:     res = f_lseek(fp, ofs1);               <span class=\"c\">/* V[N (I[vAcltblNULL) */</span>\n  111  \n  112      fp-&gt;cltbl = clmt;                      <span class=\"c\">/* V[N@\\L */</span>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/ja/open.html:\n  153  \n  154      <span class=\"c\">/* [NEGAJ */</span>\n  155:     f_mount(NULL, \"0:\", 0);\n  156:     f_mount(NULL, \"1:\", 0);\n  157  \n  158      return (int)fr;\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/ja/sfile.html:\n   32  <span class=\"k\">#endif</span>\n   33  <span class=\"k\">#if</span> _USE_FASTSEEK\n   34:     DWORD*  cltbl;        <span class=\"c\">/* t@CNX^EN|C^ (I[vNULLZbg) */</span>\n   35  <span class=\"k\">#endif</span>\n   36  <span class=\"k\">#if</span> _FS_LOCK\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/doc/ja/sfileinfo.html:\n   61  <dd>8.3`O<tt>'\\0'</tt>Ii[BLFN\\ABLFN\\ZOAASCIIpB</dd>\n   62  <dt>lfname</dt>\n   63: <dd>t@Ci[obt@|C^B\\gpOAvP[VBoNULLLFNBLFN\\oB</dd>\n   64  <dt>lfsize</dt>\n   65  <dd>t@Ci[obt@TCY(vf)B\\gpOAvP[VBLFN\\oB</dd>\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/src/00readme.txt:\n  132  \n  133    Aug 27,'12 R0.09a    Fixed assertion failure due to OS/2 EA on FAT12/16.\n  134:                        Changed f_open() and f_opendir() reject null object pointer to avoid crash.\n  135                         Changed option name _FS_SHARE to _FS_LOCK.\n  136  \n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/src/ff.c:\n   91  / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to complete the multiple partition feature.\n   92  /                   Added f_fdisk().\n   93: / Aug 27,'12 R0.09a Changed f_open() and f_opendir() reject null object pointer to avoid crash.\n   94  /                   Changed option name _FS_SHARE to _FS_LOCK.\n   95  /                   Fixed assertion failure due to OS/2 EA on FAT12/16 volume.\n   ..\n  154  #endif\n  155  typedef struct {\n  156: 	FATFS *fs;				/* Object ID 1, volume (NULL:blank entry) */\n  157  	DWORD clu;				/* Object ID 2, directory */\n  158  	WORD idx;				/* Object ID 3, directory index */\n  ...\n  471  /*------------------------------------------------------------*/\n  472  /* Note that uninitialized variables with static duration are\n  473: /  zeroed/nulled at start-up. If not, the compiler or start-up\n  474  /  routine is out of ANSI-C standard.\n  475  */\n  ...\n 2047  #endif\n 2048  \n 2049: 	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */\n 2050  		res = dir_sdi(dp, 0);\n 2051  		dp->dir = 0;\n ....\n 2317  \n 2318  FRESULT f_mount (\n 2319: 	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/\n 2320  	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */\n 2321  	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/src/ff.h:\n  136  #endif\n  137  #if _USE_FASTSEEK\n  138: 	DWORD*	cltbl;			/* Pointer to the cluster link map table (Nulled on file open) */\n  139  #endif\n  140  #if _FS_LOCK\n\n/Users/William/Develop/MiCO/libraries/filesystem/FatFs/src/option/syscall.c:\n   25    mico_rtos_init_semaphore( sobj, 1 );\n   26    mico_rtos_set_semaphore(sobj);\n   27:   ret = (*sobj != NULL);\n   28    \n   29    return ret;\n   ..\n   95  /* Allocate a memory block                                                */\n   96  /*------------------------------------------------------------------------*/\n   97: /* If a NULL is returned, the file function fails with FR_NOT_ENOUGH_CORE.\n   98  */\n   99  \n\n/Users/William/Develop/MiCO/libraries/protocols/fog_cloud/ChangeLog.txt:\n  181  [Changlog]:\n  182    1. pass topic length to message receive handler, for topic is not a \n  183:      null-terminated string.\n  184    2. max MQTT message payload size to 512 bytes.\n  185    3. add documents.\n\n/Users/William/Develop/MiCO/libraries/protocols/rpc/alink_export.h:\n  273  \n  274  /***\n  275:  * @desc:    Get uuid by device mac or sn. Set mac or sn to NULL if one wish to get the main device's uuid (also by main device's mac or sn).\n  276   * @para:    id: Mac address. (\"xx:xx:xx:xx:xx:xx\") or SN (max len refs STR_SN_LEN)\n  277:  * @retc:    NULL if mac or sn does NOT match any device. Blank string (\"\") if the uuid is not set yet.\n  278   */\n  279      const char *alink_get_uuid(const char *id);\n  ...\n  282   * @desc:    Wait until alink is connected to server and successfully logged in, or simple timeout.\n  283   *               The function can be interrupted in other thread by calling alink_wakeup_connect_waiting.\n  284:  * @para:    id: Device mac or sn of which the function is waiting. Set to NULL implies the main device.\n  285                    timeout: seconds before the function timeout, set to -1 if wait forever.\n  286   * @retc:    ALINK_OK if alink is connected to server and successfully logged in. ALINK_ERR if timeout or being wakeup.\n  ...\n  290  /***\n  291   * @desc:    Wake up the device waiting function.\n  292:  * @para:    id: Device mac or sn of which the function was waiting. Set to NULL implies the main device.\n  293   * @retc:    None. Return immediately.\n  294   */\n\n/Users/William/Develop/MiCO/libraries/protocols/rpc/json.h:\n   59          int settings;\n   60  \n   61:         /* Custom allocator support (leave null to use malloc/free)\n   62           */\n   63  \n   ..\n   81          json_string,\n   82          json_boolean,\n   83:         json_null\n   84      } json_type_e;\n   85  \n   ..\n  107              struct {\n  108                  unsigned int length;\n  109:                 json_char *ptr; /* null terminated */\n  110  \n  111              } string;\n\n/Users/William/Develop/MiCO/libraries/protocols/sntp/sntp.c:\n   50  \n   51  static volatile bool _wifiConnected = false;\n   52: static mico_semaphore_t  _wifiConnected_sem = NULL;\n   53  \n   54  \n   ..\n  109    \n  110    /* Regisist notifications */\n  111:   err = mico_system_notify_register( mico_notify_WIFI_STATUS_CHANGED, (void *)ntpNotify_WifiStatusHandler, NULL );\n  112    require_noerr( err, exit ); \n  113   \n  ...\n  161      FD_SET(Ntp_fd, &readfds);\n  162  \n  163:     select(1, &readfds, NULL, NULL, &t);\n  164      \n  165      if(FD_ISSET(Ntp_fd, &readfds))\n  ...\n  191      if(_wifiConnected_sem) mico_rtos_deinit_semaphore(&_wifiConnected_sem);\n  192      SocketClose(&Ntp_fd);\n  193:     mico_rtos_delete_thread(NULL);\n  194      return;\n  195  }\n  ...\n  198  {\n  199    mico_rtos_init_semaphore(&_wifiConnected_sem, 1);\n  200:   return mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"NTP Client\", NTPClient_thread, STACK_SIZE_NTP_CLIENT_THREAD, NULL );\n  201  }\n  202  \n\n/Users/William/Develop/MiCO/libraries/utilities/AESUtils.c:\n   52      OSStatus        err;\n   53      \n   54:     inContext->cryptor = NULL;\n   55:     err = CCCryptorCreate( kCCEncrypt, kCCAlgorithmAES128, kCCOptionECBMode, inKey, kAES_CTR_Size, NULL, \n   56          &inContext->cryptor );\n   57      check_noerr( err );\n   ..\n  223      OSStatus        err;\n  224      \n  225:     inContext->cryptor = NULL;\n  226      err = CCCryptorCreate( inEncrypt ? kCCEncrypt : kCCDecrypt, kCCAlgorithmAES128, 0, inKey, kAES_CTR_Size, \n  227:         NULL, &inContext->cryptor );\n  228      check_noerr( err );\n  229      if( err ) return( err );\n  ...\n  537      OSStatus        err;\n  538      \n  539:     inContext->cryptor = NULL;\n  540:     err = CCCryptorCreate( inMode, kCCAlgorithmAES128, kCCOptionECBMode, inKey, kAES_ECB_Size, NULL, &inContext->cryptor );\n  541      check_noerr( err );\n  542      if( err ) return( err );\n  ...\n  547      inContext->encrypt = inMode;\n  548  #elif( AES_UTILS_USE_MICO_AES )\n  549:     if( inMode == kAES_ECB_Mode_Encrypt )   AesSetKey( &inContext->ctx, inKey, kAES_ECB_Size, NULL, AES_ENCRYPTION );\n  550:     else                                    AesSetKey( &inContext->ctx, inKey, kAES_ECB_Size, NULL, AES_DECRYPTION );\n  551  #elif( AES_UTILS_USE_USSL )\n  552      if( inMode == kAES_ECB_Mode_Encrypt )   aes_setkey_enc( &inContext->ctx, (unsigned char *) inKey, kAES_ECB_Size * 8 );\n  ...\n  640      \n  641  #if( AES_UTILS_HAS_COMMON_CRYPTO_GCM )\n  642:     err = CCCryptorCreateWithMode( kCCEncrypt, kCCModeGCM, kCCAlgorithmAES128, ccNoPadding, NULL, \n  643:         inKey, kAES_CGM_Size, NULL, 0, 0, 0, &inContext->cryptor );\n  644      require_noerr( err, exit );\n  645  #elif( AES_UTILS_HAS_GLADMAN_GCM )\n\n/Users/William/Develop/MiCO/libraries/utilities/AESUtils.h:\n  316  \n  317  #define kAES_CGM_Size           16\n  318: #define kAES_CGM_Nonce_None     NULL // When passed to AES_GCM_Init it means the caller is using a per-message nonce.\n  319: #define kAES_CGM_Nonce_Auto     NULL // When passed to AES_GCM_Encrypt, it means use the internal, auto-incremented nonce.\n  320  \n  321  typedef struct\n\n/Users/William/Develop/MiCO/libraries/utilities/HTTPUtils.c:\n  191          require_action(inHeader->extraDataLen < inHeader->chunkedDataBufferLen, exit, err=kMalformedErr );\n  192  \n  193:         selectResult = select( inSock + 1, &readSet, NULL, NULL, NULL );\n  194          require_action( selectResult >= 1, exit, err = kNotReadableErr );\n  195  \n  ...\n  205        if(inHeader->contentLength == 0){ \n  206          while( findCRLF( inHeader->extraDataPtr, inHeader->extraDataLen - chunckheaderLen, &nextPackagePtr ) == false){ //find CRLF\n  207:           selectResult = select( inSock + 1, &readSet, NULL, NULL, NULL );\n  208            require_action( selectResult >= 1, exit, err = kNotReadableErr );\n  209  \n  ...\n  251                                                          inHeader->userContext);\n  252            pos+=inHeader->extraDataLen - chunckheaderLen-1;\n  253:           selectResult = select( inSock + 1, &readSet, NULL, NULL, NULL );\n  254            require_action( selectResult >= 1, exit, err = kNotReadableErr );\n  255  \n  ...\n  271  \n  272            while ( inHeader->extraDataLen < inHeader->contentLength + chunckheaderLen  ){\n  273:             selectResult = select( inSock + 1, &readSet, NULL, NULL, NULL );\n  274              require_action( selectResult >= 1, exit, err = kNotReadableErr );\n  275  \n  ...\n  293            } \n  294  \n  295:           selectResult = select( inSock + 1, &readSet, NULL, NULL, NULL );\n  296            require_action( selectResult >= 1, exit, err = kNotReadableErr );\n  297  \n  ...\n  318    //     inHeader->contentLength = inHeader->extraDataLen;\n  319    //   }else{\n  320:   //     selectResult = select( inSock + 1, &readSet, NULL, NULL, NULL );\n  321    //     require_action( selectResult >= 1, exit, err = kNotReadableErr );\n  322        \n  ...\n  334    while ( inHeader->extraDataLen < inHeader->contentLength )\n  335    {\n  336:     selectResult = select( inSock + 1, &readSet, NULL, NULL, &t );\n  337      require_action( selectResult >= 1, exit, err = kNotReadableErr );\n  338  \n  ...\n  446      ++ptr;\n  447      \n  448:     err = URLParseComponents( ioHeader->urlPtr, ioHeader->urlPtr + ioHeader->urlLen, &ioHeader->url, NULL );\n  449      require_noerr( err, exit );\n  450      \n  ...\n  483    \n  484    // Determine persistence. Note: HTTP 1.0 defaults to non-persistent if a Connection header field is not present.\n  485:   err = HTTPGetHeaderField( ioHeader->buf, ioHeader->len, \"Connection\", NULL, NULL, &value, &valueSize, NULL );\n  486    if( err )   ioHeader->persistent = (Boolean)( strnicmpx( ioHeader->protocolPtr, ioHeader->protocolLen, \"HTTP/1.0\" ) != 0 );\n  487    else        ioHeader->persistent = (Boolean)( strnicmpx( value, valueSize, \"close\" ) != 0 );\n  488  \n  489:   err = HTTPGetHeaderField( ioHeader->buf, ioHeader->len, \"Transfer-Encoding\", NULL, NULL, &value, &valueSize, NULL );\n  490    if( err )   ioHeader->chunkedData = false;\n  491    else        ioHeader->chunkedData = (Boolean)( strnicmpx( value, valueSize, kTransferrEncodingType_CHUNKED ) == 0 );\n  ...\n  604      if( ( src < end ) && ( *src == '\\n' ) ) ++src;\n  605      \n  606:     if( !inName ) // Null name means to find the next header for iteration.\n  607      {\n  608        const char *        nameEnd;\n  ...\n  651    va_list             args;\n  652    \n  653:   n = (int) HTTPGetHeaderField( inHeaderPtr, inHeaderLen, inName, NULL, NULL, &valuePtr, &valueLen, NULL );\n  654    require_noerr_quiet( n, exit );\n  655    \n  ...\n  724      inHeader->extraDataLen = 0;\n  725      free((uint32_t *)inHeader->chunkedDataBufferPtr);\n  726:     inHeader->chunkedDataBufferPtr = NULL;   \n  727:     inHeader->extraDataPtr = NULL;   \n  728      inHeader->chunkedData = false;\n  729    }else{\n  ...\n  740      if((uint32_t *)inHeader->extraDataPtr) {\n  741        free((uint32_t *)inHeader->extraDataPtr);\n  742:       inHeader->extraDataPtr = NULL;\n  743      } \n  744      inHeader->dataEndedbyClose = false;\n\n/Users/William/Develop/MiCO/libraries/utilities/SocketUtils.c:\n   51      do\n   52      {\n   53:         selectResult = select( fd + 1, NULL, &writeSet, NULL,  &t );\n   54          require( selectResult >= 1, exit );\n   55  \n\n/Users/William/Develop/MiCO/libraries/utilities/StringUtils.c:\n   59    char *dst;\n   60    \n   61:   if (src == NULL)\n   62:     return NULL;\n   63    \n   64    if (src[0] == 0)\n   65:     return NULL;\n   66    \n   67    len = strlen(src) + 1;\n   ..\n  105  \n  106  /***  \n  107: *strnlen - return the length of a null-terminated string  \n  108  *  \n  109  *Purpose:  \n  110  *   Finds the length in bytes of the given string, not including  \n  111: *   the final null character. Only the first maxsize characters  \n  112: *   are inspected: if the null character is not found, maxsize is  \n  113  *   returned.  \n  114  *  \n  ...\n  118  *  \n  119  *Exit:  \n  120: *   Length of the string \"str\", exclusive of the final null byte, or  \n  121: *   maxsize if the null character is not found. \n  122  *  \n  123  *Exceptions:  \n  ...\n  129    size_t n;  \n  130    \n  131:   /* Note that we do not check if s == NULL, because we do not  \n  132    * return errno_t...  \n  133    */  \n  ...\n  295  char* DataToHexString( const uint8_t *inBuf, size_t inBufLen )\n  296  {\n  297:     char* buf_str = NULL;\n  298      char* buf_ptr;\n  299      require_quiet(inBuf, error);\n  ...\n  310  error:\n  311      if ( buf_str ) free( buf_str );\n  312:     return NULL;\n  313  }\n  314  \n  315  char* DataToHexStringWithSpaces( const uint8_t *inBuf, size_t inBufLen )\n  316  {\n  317:     char* buf_str = NULL;\n  318:     char* buf_ptr = NULL;\n  319      require_quiet(inBuf, error);\n  320      require_quiet(inBufLen > 0, error);\n  ...\n  330  error:\n  331      if ( buf_str ) free( buf_str );\n  332:     return NULL;\n  333  }\n  334  \n  335  char* DataToHexStringWithColons( const uint8_t *inBuf, size_t inBufLen )\n  336  {\n  337:     char* buf_str = NULL;\n  338:     char* buf_ptr = NULL;\n  339      require_quiet(inBuf, error);\n  340      require_quiet(inBufLen > 0, error);\n  ...\n  356  error:\n  357      if ( buf_str ) free( buf_str );\n  358:     return NULL;\n  359  }\n  360  \n  361  char* DataToCString( const uint8_t *inBuf, size_t inBufLen )\n  362  {\n  363:     char* cString = NULL;\n  364      require_quiet(inBuf, error);\n  365      require_quiet(inBufLen > 0, error);\n  ...\n  373  error:\n  374      if ( cString ) free( cString );\n  375:     return NULL;\n  376  }\n  377  \n  ...\n  623                  continue;\n  624  \n  625:             case 's':   // %s: string of non-whitespace characters with a null terminator.\n  626  \n  627                  if( sizeModifier != 0 ) goto exit;\n  ...\n  632                  if( !alt && ( ( src >= end ) || ( *src == '\\0' ) ) ) goto exit;\n  633  \n  634:                 // Copy the string until a null terminator, whitespace, or the max fieldWidth is hit.\n  635  \n  636                  if( suppress )\n  ...\n  678                  setEnd = fmt++;\n  679  \n  680:                 // Parse until a mismatch, null terminator, or the max fieldWidth is hit.\n  681  \n  682                  old = src;\n  ...\n  911      if( suffixLen <= stringLen ){\n  912          ret = strstr( instr_tmp, inSuffix_tmp );\n  913:         if(ret != NULL)\n  914              ret = (char *)(inStr+(ret-instr_tmp));\n  915      }\n  916      else\n  917:         ret = NULL;\n  918  \n  919      free(instr_tmp);\n  ...\n  941      };\n  942  \n  943:     return(NULL);\n  944  }\n  945  \n\n/Users/William/Develop/MiCO/libraries/utilities/StringUtils.h:\n   29  //---------------------------------------------------------------------------------------------------------------------------\n   30  /*! @defined    sizeof_string\n   31:     @abstract   Determines the size of a constant C string, excluding the null terminator.\n   32  */\n   33  #define sizeof_string( X )      ( sizeof( ( X ) ) - 1 )\n   ..\n   35  //---------------------------------------------------------------------------------------------------------------------------\n   36  /*! @defined    kSizeCString\n   37:     @abstract   Constant for describing the size of a null terminated string\n   38  */\n   39  #define kSizeCString ( (size_t) -1 )\n\n/Users/William/Develop/MiCO/libraries/utilities/URLUtils.c:\n   64      */\n   65      \n   66:     if( inEnd == NULL ) inEnd = inSrc + strlen( inSrc );\n   67      \n   68      // Parse an optional scheme (the \"ftp\" in \"ftp://tom:secret@abc.com/test?x#y\").\n   69      \n   70:     schemePtr = NULL;\n   71:     schemeEnd = NULL;\n   72      \n   73      c = '\\0';\n   ..\n   83      // Parse an optional authority (the \"tom:secret@abc.com\" in \"ftp://tom:secret@abc.com/test?x#y\").\n   84      \n   85:     userPtr     = NULL;\n   86:     userEnd     = NULL;\n   87:     passwordPtr = NULL;\n   88:     passwordEnd = NULL;\n   89:     hostPtr     = NULL;\n   90:     hostEnd     = NULL;\n   91      \n   92      if( ( ( inEnd - inSrc ) >= 2 ) && ( inSrc[ 0 ] == '/' ) && ( inSrc[ 1 ] == '/' ) )\n   ..\n  145      // Parse an optional query (the \"x\" in \"ftp://tom:secret@abc.com/test?x#y\").\n  146      \n  147:     queryPtr = NULL;\n  148:     queryEnd = NULL;    \n  149      if( c == '?' )\n  150      {\n  ...\n  156      // Parse an optional fragment  (the \"y\" in \"ftp://tom:secret@abc.com/test?x#y\").\n  157      \n  158:     fragmentPtr = NULL;\n  159:     fragmentEnd = NULL;\n  160      if( c == '#' )\n  161      {\n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/arraylist.c:\n   30  \n   31    arr = (struct array_list*)calloc(1, sizeof(struct array_list));\n   32:   if(!arr) return NULL;\n   33    arr->size = ARRAY_LIST_DEFAULT_SIZE;\n   34    arr->length = 0;\n   ..\n   36    if(!(arr->array = (void**)calloc(sizeof(void*), arr->size))) {\n   37      free(arr);\n   38:     return NULL;\n   39    }\n   40    return arr;\n   ..\n   54  array_list_get_idx(struct array_list *arr, int i)\n   55  {\n   56:   if(i >= arr->length) return NULL;\n   57    return arr->array[i];\n   58  }\n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/bits.h:\n   24  #define error_ptr(error) ((void*)error)\n   25  #define error_description(error)  (json_tokener_errors[error])\n   26: #define is_error(ptr) (ptr == NULL)\n   27  \n   28  #endif\n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/json_object.c:\n   50  static void json_object_init(void) {\n   51    MC_DEBUG(\"json_object_init: creating object table\\n\");\n   52:   json_object_table = lh_kptr_table_new(128, \"json_object_table\", NULL);\n   53  }\n   54  \n   ..\n  153  \n  154    jso = (struct json_object*)calloc(sizeof(struct json_object), 1);\n  155:   if(!jso) return NULL;\n  156    jso->o_type = o_type;\n  157    jso->_ref_count = 1;\n  ...\n  181  const char* json_object_to_json_string(struct json_object *jso)\n  182  {\n  183:   if(!jso) return \"null\";\n  184    if(!jso->_pb) {\n  185:     if(!(jso->_pb = printbuf_new())) return NULL;\n  186    } else {\n  187      printbuf_reset(jso->_pb);\n  188    }\n  189:   if(jso->_to_json_string(jso, jso->_pb) < 0) return NULL;\n  190    return jso->_pb->buf;\n  191  }\n  ...\n  194  {\n  195    struct printbuf *_pb;\n  196:   if(!jso) return NULL;\n  197  \n  198:   if(!(_pb = printbuf_new())) return NULL;\n  199  \n  200:   if(jso->_to_json_string(jso, _pb) < 0) return NULL;\n  201    return _pb;\n  202  }\n  ...\n  219  			json_escape_str(pb, iter.key, strlen(iter.key));\n  220  			sprintbuf(pb, \"\\\": \");\n  221: 			if(iter.val == NULL) sprintbuf(pb, \"null\");\n  222  			else iter.val->_to_json_string(iter.val, pb);\n  223  			i++;\n  ...\n  242  {\n  243    struct json_object *jso = json_object_new(json_type_object);\n  244:   if(!jso) return NULL;\n  245    jso->_delete = &json_object_object_delete;\n  246    jso->_to_json_string = &json_object_object_to_json_string;\n  247    jso->o.c_object = lh_kchar_table_new(JSON_OBJECT_DEF_HASH_ENTRIES,\n  248: 					NULL, &json_object_lh_entry_free);\n  249    return jso;\n  250  }\n  ...\n  252  struct lh_table* json_object_get_object(struct json_object *jso)\n  253  {\n  254:   if(!jso) return NULL;\n  255    switch(jso->o_type) {\n  256    case json_type_object:\n  257      return jso->o.c_object;\n  258    default:\n  259:     return NULL;\n  260    }\n  261  }\n  ...\n  270  struct json_object* json_object_object_get(struct json_object* jso, const char *key)\n  271  {\n  272:   if(!jso) return NULL;\n  273    return (struct json_object*) lh_table_lookup(jso->o.c_object, key);\n  274  }\n  ...\n  292  {\n  293    struct json_object *jso = json_object_new(json_type_boolean);\n  294:   if(!jso) return NULL;\n  295    jso->_to_json_string = &json_object_boolean_to_json_string;\n  296    jso->o.c_boolean = b;\n  ...\n  327  {\n  328    struct json_object *jso = json_object_new(json_type_int);\n  329:   if(!jso) return NULL;\n  330    jso->_to_json_string = &json_object_int_to_json_string;\n  331    jso->o.c_int64 = i;\n  ...\n  372  {\n  373    struct json_object *jso = json_object_new(json_type_int);\n  374:   if(!jso) return NULL;\n  375    jso->_to_json_string = &json_object_int_to_json_string;\n  376    jso->o.c_int64 = i;\n  ...\n  409  {\n  410    struct json_object *jso = json_object_new(json_type_double);\n  411:   if(!jso) return NULL;\n  412    jso->_to_json_string = &json_object_double_to_json_string;\n  413    jso->o.c_double = d;\n  ...\n  455  {\n  456    struct json_object *jso = json_object_new(json_type_string);\n  457:   if(!jso) return NULL;\n  458    jso->_delete = &json_object_string_delete;\n  459    jso->_to_json_string = &json_object_string_to_json_string;\n  ...\n  466  {\n  467    struct json_object *jso = json_object_new(json_type_string);\n  468:   if(!jso) return NULL;\n  469    jso->_delete = &json_object_string_delete;\n  470    jso->_to_json_string = &json_object_string_to_json_string;\n  ...\n  477  const char* json_object_get_string(struct json_object *jso)\n  478  {\n  479:   if(!jso) return NULL;\n  480    switch(jso->o_type) {\n  481    case json_type_string:\n  ...\n  510  \n  511        val = json_object_array_get_idx(jso, i);\n  512: 	  if(val == NULL) { sprintbuf(pb, \"null\"); }\n  513  	  else { val->_to_json_string(val, pb); }\n  514    }\n  ...\n  530  {\n  531    struct json_object *jso = json_object_new(json_type_array);\n  532:   if(!jso) return NULL;\n  533    jso->_delete = &json_object_array_delete;\n  534    jso->_to_json_string = &json_object_array_to_json_string;\n  ...\n  539  struct array_list* json_object_get_array(struct json_object *jso)\n  540  {\n  541:   if(!jso) return NULL;\n  542    switch(jso->o_type) {\n  543    case json_type_array:\n  544      return jso->o.c_array;\n  545    default:\n  546:     return NULL;\n  547    }\n  548  }\n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/json_object.h:\n   58  typedef enum json_type {\n   59    /* If you change this, be sure to update json_type_to_name() too */\n   60:   json_type_null,\n   61    json_type_boolean,\n   62    json_type_double,\n   ..\n  137   * @param obj the json_object instance\n  138   * @param key the object field name (a private copy will be duplicated)\n  139:  * @param val a json_object or NULL member to associate with the given field\n  140   */\n  141  extern void json_object_object_add(struct json_object* obj, const char *key,\n  ...\n  237   * @param obj the json_object instance\n  238   * @param idx the index to get the element at\n  239:  * @returns the json_object at the specified index (or NULL)\n  240   */\n  241  extern struct json_object* json_object_array_get_idx(struct json_object *obj,\n  ...\n  256   * or TRUE otherwise. If the passed object is a string it will return\n  257   * TRUE if it has a non zero length. If any other object type is passed\n  258:  * TRUE will be returned if the object is not NULL.\n  259   *\n  260   * @param obj the json_object instance\n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/json_tokener.c:\n   42  \n   43  \n   44: static const char* json_null_str = \"null\";\n   45  static const char* json_true_str = \"true\";\n   46  static const char* json_false_str = \"false\";\n   ..\n   52    \"unexpected end of data\",\n   53    \"unexpected character\",\n   54:   \"null expected\",\n   55    \"boolean expected\",\n   56    \"number expected\",\n   ..\n   75  \n   76    tok = (struct json_tokener*)calloc(1, sizeof(struct json_tokener));\n   77:   if (!tok) return NULL;\n   78    tok->pb = printbuf_new();\n   79    json_tokener_reset(tok);\n   ..\n   93    tok->stack[depth].saved_state = json_tokener_state_start;\n   94    json_object_put(tok->stack[depth].current);\n   95:   tok->stack[depth].current = NULL;\n   96    free(tok->stack[depth].obj_field_name);\n   97:   tok->stack[depth].obj_field_name = NULL;\n   98  }\n   99  \n  ...\n  118    obj = json_tokener_parse_ex(tok, str, -1);\n  119    if(tok->err != json_tokener_success)\n  120:     obj = NULL;\n  121    json_tokener_free(tok);\n  122    return obj;\n  ...\n  132      *error = tok->err;\n  133      if(tok->err != json_tokener_success) {\n  134:         obj = NULL;\n  135      }\n  136  \n  ...\n  157    }\n  158  \n  159:   return NULL;\n  160  }\n  161  #endif\n  ...\n  210  					  const char *str, int len)\n  211  {\n  212:   struct json_object *obj = NULL;\n  213    char c = '\\1';\n  214  \n  ...\n  251        case 'N':\n  252        case 'n':\n  253: 	state = json_tokener_state_null;\n  254  	printbuf_reset(tok->pb);\n  255  	tok->st_pos = 0;\n  ...\n  301        goto redo_char;\n  302  \n  303:     case json_tokener_state_null:\n  304        printbuf_memappend_fast(tok->pb, &c, 1);\n  305:       if(strncasecmp(json_null_str, tok->pb->buf,\n  306: 		     json_min(tok->st_pos+1, strlen(json_null_str))) == 0) {\n  307: 	if(tok->st_pos == strlen(json_null_str)) {\n  308: 	  current = NULL;\n  309  	  saved_state = json_tokener_state_finish;\n  310  	  state = json_tokener_state_eatws;\n  ...\n  312  	}\n  313        } else {\n  314: 	tok->err = json_tokener_error_parse_null;\n  315  	goto out;\n  316        }\n  ...\n  675        json_object_object_add(current, obj_field_name, obj);\n  676        free(obj_field_name);\n  677:       obj_field_name = NULL;\n  678        saved_state = json_tokener_state_object_sep;\n  679        state = json_tokener_state_eatws;\n  ...\n  708    MC_DEBUG(\"json_tokener_parse_ex: error %s at offset %d\\n\",\n  709  	   json_tokener_errors[tok->err], tok->char_offset);\n  710:   return NULL;\n  711  }\n  712  \n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/json_tokener.h:\n   26    json_tokener_error_parse_eof,\n   27    json_tokener_error_parse_unexpected,\n   28:   json_tokener_error_parse_null,\n   29    json_tokener_error_parse_boolean,\n   30    json_tokener_error_parse_number,\n   ..\n   41    json_tokener_state_start,\n   42    json_tokener_state_finish,\n   43:   json_tokener_state_null,\n   44    json_tokener_state_comment_start,\n   45    json_tokener_state_comment,\n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/json_util.c:\n   98  \n   99  //   if(!obj) {\n  100: //     MC_ERROR(\"json_object_to_file: object is null\\n\");\n  101  //     return -1;\n  102  //   }\n  ...\n  212  static const char* json_type_name[] = {\n  213    /* If you change this, be sure to update the enum json_type definition too */\n  214:   \"null\",\n  215    \"boolean\",\n  216    \"double\",\n  ...\n  226  	{\n  227  		MC_ERROR(\"json_type_to_name: type %d is out of range [0,%d]\\n\", o_type, NELEM(json_type_name));\n  228: 		return NULL;\n  229  	}\n  230  	return json_type_name[o_type];\n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/linkhash.c:\n   92  	struct lh_entry *ent;\n   93  \n   94: 	new_t = lh_table_new(new_size, NULL, NULL, t->hash_fn, t->equal_fn);\n   95  	ent = t->head;\n   96  	while(ent) {\n   ..\n  109  {\n  110  	struct lh_entry *c;\n  111: 	for(c = t->head; c != NULL; c = c->next) {\n  112  		if(t->free_fn) {\n  113  			t->free_fn(c);\n  ...\n  138  	t->count++;\n  139  \n  140: 	if(t->head == NULL) {\n  141  		t->head = t->tail = &t->table[n];\n  142: 		t->table[n].next = t->table[n].prev = NULL;\n  143  	} else {\n  144  		t->tail->next = &t->table[n];\n  145  		t->table[n].prev = t->tail;\n  146: 		t->table[n].next = NULL;\n  147  		t->tail = &t->table[n];\n  148  	}\n  ...\n  159  \n  160  	while( count < t->size ) {\n  161: 		if(t->table[n].k == LH_EMPTY) return NULL;\n  162  		if(t->table[n].k != LH_FREED &&\n  163  		   t->equal_fn(t->table[n].k, k)) return &t->table[n];\n  ...\n  165  		count++;\n  166  	}\n  167: 	return NULL;\n  168  }\n  169  \n  ...\n  173  	struct lh_entry *e = lh_table_lookup_entry(t, k);\n  174  	if(e) return e->v;\n  175: 	return NULL;\n  176  }\n  177  \n  ...\n  187  	t->count--;\n  188  	if(t->free_fn) t->free_fn(e);\n  189: 	t->table[n].v = NULL;\n  190  	t->table[n].k = LH_FREED;\n  191  	if(t->tail == &t->table[n] && t->head == &t->table[n]) {\n  192: 		t->head = t->tail = NULL;\n  193  	} else if (t->head == &t->table[n]) {\n  194: 		t->head->next->prev = NULL;\n  195  		t->head = t->head->next;\n  196  	} else if (t->tail == &t->table[n]) {\n  197: 		t->tail->prev->next = NULL;\n  198  		t->tail = t->tail->prev;\n  199  	} else {\n  ...\n  201  		t->table[n].next->prev = t->table[n].prev;\n  202  	}\n  203: 	t->table[n].next = t->table[n].prev = NULL;\n  204  	return 0;\n  205  }\n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/linkhash.h:\n  135   * @param free_fn callback function used to free memory for entries\n  136   * when lh_table_free or lh_table_delete is called.\n  137:  * If NULL is provided, then memory for keys and values\n  138   * must be freed by the caller.\n  139   * @param hash_fn  function used to hash keys. 2 standard ones are defined:\n  ...\n  196   * @param t the table to lookup\n  197   * @param k a pointer to the key to lookup\n  198:  * @return a pointer to the record structure of the value or NULL if it does not exist.\n  199   */\n  200  extern struct lh_entry* lh_table_lookup_entry(struct lh_table *t, const void *k);\n  ...\n  204   * @param t the table to lookup\n  205   * @param k a pointer to the key to lookup\n  206:  * @return a pointer to the found value or NULL if it does not exist.\n  207   */\n  208  extern const void* lh_table_lookup(struct lh_table *t, const void *k);\n\n/Users/William/Develop/MiCO/libraries/utilities/json_c/printbuf.c:\n   35  \n   36    p = (struct printbuf*)calloc(1, sizeof(struct printbuf));\n   37:   if(!p) return NULL;\n   38    p->size = 4;\n   39    p->bpos = 0;\n   40    if(!(p->buf = (char*)malloc(p->size))) {\n   41      free(p);\n   42:     return NULL;\n   43    }\n   44    return p;\n\n/Users/William/Develop/MiCO/Board/MiCOKit-3162/platform.c:\n  198      .pin_tx                       = &platform_gpio_pins[MICO_GPIO_14],\n  199      .pin_rx                       = &platform_gpio_pins[MICO_GPIO_4],\n  200:     .pin_cts                      = NULL,\n  201:     .pin_rts                      = NULL,\n  202      .tx_dma_config =\n  203      {\n  ...\n  454    //  Initialise EasyLink buttons\n  455    MicoGpioInitialize( (mico_gpio_t)EasyLink_BUTTON, INPUT_PULL_UP );\n  456:   mico_init_timer(&_button_EL_timer, RestoreDefault_TimeOut, _button_EL_Timeout_handler, NULL);\n  457:   MicoGpioEnableIRQ( (mico_gpio_t)EasyLink_BUTTON, IRQ_TRIGGER_BOTH_EDGES, _button_EL_irq_handler, NULL );\n  458    \n  459    //  Initialise Standby/wakeup switcher\n  460    MicoGpioInitialize( Standby_SEL, INPUT_PULL_UP );\n  461:   MicoGpioEnableIRQ( Standby_SEL , IRQ_TRIGGER_FALLING_EDGE, _button_STANDBY_irq_handler, NULL);\n  462  }\n  463  \n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/http/http_client.c:\n   63  static mico_semaphore_t wait_sem;\n   64  void start_http_get( );\n   65: char *g_data=NULL;\n   66  /*\n   67  GET /WebServices/TrainTimeWebService.asmx/getStationAndTimeByTrainCode?TrainCode=string&UserID=string HTTP/1.1\n   ..\n  172  \n  173    /*HTTPHeaderCreateWithCallback set some callback functions */\n  174:   HTTPHeader_t *httpHeader = HTTPHeaderCreateWithCallback(onReceivedData, NULL, NULL);\n  175    require_action( httpHeader, EXIT, err = kNoMemoryErr );\n  176    \n  ...\n  207    while(1){\n  208       http_client_log(\"waiting...\");\n  209:      select(1, &readfds, NULL, NULL, NULL);\n  210       if(FD_ISSET(client_fd,&readfds))\n  211       {\n  ...\n  223                printf(\"*******\\r\\n\");\n  224                free(g_data);\n  225:               g_data=NULL;\n  226                goto EXIT;\n  227              case EWOULDBLOCK:\n  ...\n  242      free(httpHeader);\n  243    }\n  244:   mico_rtos_delete_thread(NULL);\n  245  }\n  246  \n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/http/http_client_ota.c:\n  159    while ( (mico_rtos_get_semaphore(&button_sem, MICO_WAIT_FOREVER)) == kNoErr )\n  160    {\n  161:     err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"http client\", http_client_thread, 0x800, NULL );\n  162      require_noerr_action( err, exit, http_client_log(\"ERROR: Unable to start the http client thread.\") );\n  163    }\n  ...\n  178    struct sockaddr_t addr;\n  179    struct timeval_t t;\n  180:   char *httpRequest = NULL;\n  181:   HTTPHeader_t *httpHeader = NULL;\n  182    configContext_t httpContext = {0, false};\n  183    \n  ...\n  186    httpHeader\n  187    */\n  188:   httpHeader = HTTPHeaderCreateWithCallback(onReceivedData, NULL, &httpContext);\n  189    require_action( httpHeader, exit, err = kNoMemoryErr );\n  190    HTTPHeaderClear( httpHeader );\n  ...\n  226       FD_ZERO(&readfds);\n  227       FD_SET(client_fd, &readfds);\n  228:      select(1, &readfds, NULL, NULL, &t);\n  229       if(FD_ISSET(client_fd,&readfds))\n  230       {\n  ...\n  259      free(httpHeader);\n  260    }\n  261:   mico_rtos_delete_thread(NULL);\n  262    return;\n  263  }\n  ...\n  278    }\n  279    \n  280:   err = HTTPGetHeaderField( inHeader->buf, inHeader->len, \"Content-Type\", NULL, NULL, &value, &valueSize, NULL );\n  281    \n  282    if(err == kNoErr && strnicmpx( value, valueSize, kMIMEType_Stream ) == 0){\n  ...\n  323    configContext_t *context = (configContext_t *)inUserContext;\n  324    \n  325:   err = HTTPGetHeaderField( inHeader->buf, inHeader->len, \"Content-Type\", NULL, NULL, &value, &valueSize, NULL );\n  326    \n  327    if(err == kNoErr && strnicmpx( value, valueSize, kMIMEType_Stream ) == 0){\n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/http/http_server.c:\n  158    http_server_log(\"local ip: %s\", para.ip);\n  159    \n  160:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"http server\", http_server_thread, 0x800, NULL );\n  161    require_noerr_action( err, exit, http_server_log(\"ERROR: Unable to start the http server thread.\") );\n  162    \n  ...\n  195      FD_ZERO(&readfds);\n  196      FD_SET(http_listener_fd, &readfds);  \n  197:     select(1, &readfds, NULL, NULL, NULL);\n  198  \n  199      /*Check http connection requests */\n  ...\n  204          inet_ntoa(ip_address, addr.s_ip );\n  205          http_server_log(\"Client %s:%d connected, fd: %d\", ip_address, addr.s_port, j);\n  206:         if(kNoErr != mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"Local Clients\", http_server_client_thread, 0x1500, &j) ) \n  207            SocketClose(&j);\n  208        }\n  ...\n  212  exit:\n  213      http_server_log(\"Exit: Local controller exit with err = %d\", err);\n  214:     mico_rtos_delete_thread(NULL);\n  215      return;\n  216  }\n  ...\n  223    fd_set readfds;\n  224    struct timeval_t t;\n  225:   HTTPHeader_t *httpHeader = NULL;\n  226    configContext_t httpContext = {0, false};\n  227    \n  ...\n  240  \n  241      if(httpHeader->len == 0){\n  242:       require(select(1, &readfds, NULL, NULL, &t) >= 0, exit);\n  243        clientFdIsSet = FD_ISSET(clientFd, &readfds);\n  244      }\n  ...\n  295      free(httpHeader);\n  296    }\n  297:   mico_rtos_delete_thread(NULL);\n  298    return;\n  299  }\n  ...\n  313  {\n  314    OSStatus err = kNoErr;\n  315:   char *data = NULL;\n  316    int len_data;\n  317    configContext_t *context = (configContext_t *)inUserContext;\n  ...\n  359  {\n  360    OSStatus err = kUnknownErr;\n  361:   uint8_t *httpResponse = NULL;\n  362    size_t httpResponseLen = 0;\n  363    char httpbody[1500];\n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/json/json_op.c:\n   45    \n   46    /*1:construct json object*/\n   47:   struct json_object *recv_json_object=NULL;\n   48    recv_json_object=json_object_new_object();\n   49  \n   50:   struct json_object *device_object=NULL;\n   51    device_object=json_object_new_object();\n   52    json_object_object_add(device_object, \"Hardware\", json_object_new_string(\"MiCOKit3288\"));   \n   ..\n   94      /*3:parse finished,free memory*/\n   95      json_object_put(recv_json_object);/*free memory*/   \n   96:     recv_json_object=NULL;\n   97      \n   98      /*4:operate rgb*/\n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/os/os_mutex.c:\n   48              os_thread_log(\"thread name=%s die now\",name);\n   49              mico_rtos_unlock_mutex(&mutex);\n   50:             mico_rtos_delete_thread(NULL);\n   51              break;\n   52         } \n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/os/os_queue.c:\n   71    OSStatus err = kNoErr;\n   72    err = mico_rtos_init_queue(&os_queue, \"queue\", sizeof(msg_t), 3);\n   73:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"receiver\", receiver_thread, 500, NULL);\n   74:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"sender\", sender_thread, 500, NULL);\n   75    return err;\n   76  }\n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/os/os_sem.c:\n   41      mico_rtos_set_semaphore(&os_sem);\n   42      os_sem_log(\"release semaphore\");\n   43:     mico_rtos_delete_thread(NULL);\n   44  }\n   45  \n   ..\n   49    os_sem_log(\"test binary semaphore\");\n   50    err = mico_rtos_init_semaphore(&os_sem, 1);//0/1 binary semaphore || 0/N semaphore\n   51:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY,\"release sem\",release_thread,500,NULL);\n   52    mico_rtos_get_semaphore(&os_sem, MICO_WAIT_FOREVER);//wait until get semaphore \n   53    os_sem_log(\"get semaphore\");\n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/os/os_thread.c:\n   62    mico_thread_t handle2;\n   63    /* Create new thread */\n   64:   err = mico_rtos_create_thread(&handle1, MICO_APPLICATION_PRIORITY, \"t1\", run1, 500, NULL);\n   65:   err = mico_rtos_create_thread(&handle2, MICO_APPLICATION_PRIORITY, \"t2\", run2, 500, NULL);\n   66    mico_rtos_thread_join(&handle1);\n   67    mico_rtos_thread_join(&handle2);\n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/os/os_timer.c:\n   59    os_timer_log(\"timer demo\");\n   60    int arg=100;\n   61:   //err = mico_init_timer(&timer_handle, 3000, alarm, (void *)NULL);\n   62    err = mico_init_timer(&timer_handle, 3000, alarm, &arg);\n   63    mico_start_timer(&timer_handle);\n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/power_measure/main.c:\n   96    power_log( \"Enter standby mode error!\" );\n   97    \n   98:   mico_rtos_delete_thread( NULL );\n   99    return 0;\n  100  }\n  ...\n  110    power_log( \"Power measure program: RTOS initialized and no application is running\" );\n  111    \n  112:   mico_rtos_delete_thread( NULL );\n  113    return 0;\n  114  }\n  ...\n  141    MicoFlashFinalize( MICO_FLASH_FOR_UPDATE );\n  142    \n  143:   mico_rtos_delete_thread( NULL );\n  144  \n  145    return 0;\n  ...\n  160  #endif\n  161      \n  162:   mico_rtos_delete_thread( NULL );\n  163    return 0;\n  164  }\n  ...\n  185    micoWlanStart(&wNetConfig);\n  186      \n  187:   mico_rtos_delete_thread( NULL );\n  188    return 0;\n  189  }\n  ...\n  202    micoWlanStartEasyLinkPlus( MICO_NEVER_TIMEOUT );\n  203      \n  204:   mico_rtos_delete_thread( NULL );\n  205    return 0;\n  206  }\n  ...\n  234    power_log(\"connect to %s.....\", wNetConfig.ap_info.ssid);\n  235      \n  236:   mico_rtos_delete_thread( NULL );\n  237    return 0;\n  238  }\n  ...\n  246    struct sockaddr_t addr;\n  247    socklen_t addrLen;\n  248:   uint8_t *buf = NULL;\n  249    \n  250  #if MCU_POWERSAVE_ENABLED\n  ...\n  285    }\n  286      \n  287:   mico_rtos_delete_thread( NULL );\n  288    return 0;\n  289  }\n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/tcp/tcp_client.c:\n  105        timeout.tv_sec = 2;\n  106        timeout.tv_usec = 0;\n  107:       nfound=select(maxfd, &rset, NULL, NULL, &timeout);\n  108        if(nfound==0)/*nothing happened,printf dot...*/\n  109        {\n  ...\n  128    }\n  129  EXIT_THREAD:\n  130:     mico_rtos_delete_thread(NULL);\n  131      free(buf);\n  132      close(tcp_fd);\n  ...\n  152    mico_rtos_get_semaphore(&wait_sem, MICO_WAIT_FOREVER);/*wait forever until connected wifi*/\n  153      \n  154:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"TCP_client\", tcp_client_thread, 0x800, NULL );\n  155    require_noerr_action( err, EXIT, tcp_client_log(\"ERROR: Unable to start the tcp client thread.\") );\n  156    \n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/tcp/tcp_server.c:\n   88    {\n   89      rset=set;\n   90:     select(fd+1, &rset, NULL, NULL, NULL);\n   91      if (FD_ISSET( fd, &rset )) /*one client has data*/\n   92      {\n   ..\n  105    }\n  106  EXIT_CLIENT_THRED:\n  107:   mico_rtos_delete_thread(NULL);\n  108    free(buf);\n  109  }\n  ...\n  133      inet_ntoa(ip_address, remote_addr.s_ip );\n  134      tcp_server_log(\"new client ip: %s port: %d connected\", ip_address, remote_addr.s_port);\n  135:     err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, NULL, tcp_client_thread, 0x800, (void*)tcp_new_fd );\n  136    }\n  137  EXIT_SERVER_THRED:\n  138:   mico_rtos_delete_thread(NULL);\n  139  }\n  140  int application_start( void )\n  ...\n  163    tcp_server_log(\"Server established at ip: %s port: %d\",para.ip, SERVER_PORT);\n  164    \n  165:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"TCP_server\", tcp_server_thread, 0x800, NULL );\n  166    require_noerr_action( err, EXIT, tcp_server_log(\"ERROR: Unable to start the tcp server thread.\") );\n  167  EXIT:\n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/udp/udp_broadcast.c:\n  107    \n  108  EXIT_THREAD:\n  109:   mico_rtos_delete_thread(NULL);\n  110  }\n  111  \n  ...\n  130    micoWlanGetIPStatus(&para, Station);\n  131    udp_broadcast_log(\"udp server ip: %s,port=%d\", para.ip, udp_port);\n  132:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"udp_broadcast\", udp_broadcast_thread, 0x800, NULL );\n  133    require_noerr_action( err, EXIT, udp_broadcast_log(\"ERROR: Unable to start the UDP echo thread.\") );\n  134    \n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/udp/udp_echo.c:\n  116      FD_SET(udp_fd, &readfds);\n  117  \n  118:     select(1, &readfds, NULL, NULL, &t);\n  119      \n  120      /*Read data from udp and send data back */ \n  ...\n  128    \n  129  exit:\n  130:   mico_rtos_delete_thread(NULL);\n  131  }\n  132  \n  ...\n  155    udp_echo_log(\"tcp server ip: %s\", para.ip);\n  156    \n  157:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"UDP_ECHO\", udp_echo_thread, 0x800, NULL );\n  158    require_noerr_action( err, exit, udp_echo_log(\"ERROR: Unable to start the UDP echo thread.\") );\n  159    \n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/udp/udp_unicast.c:\n   95    while(1)\n   96    {\n   97:     select(udp_fd + 1, &readfds, NULL, NULL, NULL);\n   98      /*Read data from udp and send data back */ \n   99      if (FD_ISSET( udp_fd, &readfds )) \n  ...\n  111    \n  112  EXIT_THREAD:\n  113:   mico_rtos_delete_thread(NULL);\n  114  }\n  115  \n  ...\n  134    micoWlanGetIPStatus(&para, Station);\n  135    udp_unicast_log(\"udp server ip: %s,port=%d\", para.ip, udp_port);\n  136:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"udp_unicast\", udp_unicast_thread, 0x800, NULL );\n  137    require_noerr_action( err, EXIT, udp_unicast_log(\"ERROR: Unable to start the UDP echo thread.\") );\n  138    \n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/wifi/wifi_airkiss.c:\n  131      wifi_airkiss_log(\"easylink failed,let app start airkiss mode\");\n  132    }\n  133:   mico_rtos_delete_thread(NULL);\n  134  }\n  135  \n  ...\n  156    mico_rtos_init_semaphore(&airkiss_sem, 1);/*wait easylink*/\n  157    mico_rtos_init_semaphore(&wifi_sem, 1);/*wait wifi to be connect*/\n  158:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"AIRKISS\", airkiss_thread, 0x800, NULL );\n  159    require_noerr_action( err, exit, wifi_airkiss_log(\"ERROR: Unable to start the Airkiss thread.\") );\n  160   \n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/wifi/wifi_easylink.c:\n  116        wifi_easylink_log(\"easylink failed,let app start easylink mode\");\n  117    }\n  118:    mico_rtos_delete_thread(NULL);\n  119  }\n  120  \n  ...\n  141    mico_rtos_init_semaphore(&wifi_sem,1);/*wait wifi to be connect*/\n  142    \n  143:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"EASYLINK\", easylink_thread, 0x800, NULL );\n  144    require_noerr_action( err, exit, wifi_easylink_log(\"ERROR: Unable to start the EasyLink thread.\") );\n  145    \n\n/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/wifi/wifi_wps.c:\n   87    micoWlanStopWPS();\n   88    mico_rtos_deinit_semaphore(&wps_sem);\n   89:   wps_sem = NULL;\n   90  }\n   91  \n   ..\n  120    msleep(20);\n  121    clean_wps_sesource();\n  122:   mico_rtos_delete_thread(NULL);\n  123  }\n  124  \n  ...\n  141    // Start the WPS thread\n  142    mico_rtos_init_semaphore(&wps_sem, 1);\n  143:   err = mico_rtos_create_thread(NULL, MICO_APPLICATION_PRIORITY, \"WPS\", wps_thread, 0x1000, NULL );\n  144    require_noerr_action( err, exit, wifi_wps_log(\"ERROR: Unable to start the WPS thread.\") );\n  145    \n\n2360 matches across 277 files\n",
			"settings":
			{
				"buffer_size": 382002,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "/Users/William/Develop/MiCO/mico/security/Curve25519/curve25519-donna-c64.c",
			"settings":
			{
				"buffer_size": 14257,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/William/Develop/MiCO/libraries/utilities/json_c/linkhash.c",
			"settings":
			{
				"buffer_size": 4998,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/Users/William/Library/Application Support/Sublime Text 2/Packages/SublimeClang/clang/include/stddef.h",
			"settings":
			{
				"buffer_size": 2104,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/William/Develop/MiCO/libraries/utilities/json_c/json_object.c",
			"settings":
			{
				"buffer_size": 13942,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/William/Develop/MiCO/libraries/utilities/json_c/json_tokener.c",
			"settings":
			{
				"buffer_size": 21057,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 287.0,
		"selected_items":
		[
			[
				"",
				"Package Control: Install Package"
			],
			[
				"git",
				"Package Control: Install Package"
			],
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"v",
				"View: Toggle Side Bar"
			],
			[
				"Cscope:Look up symbol",
				"Cscope: Look up symbol"
			],
			[
				":",
				"View: Toggle Tabs"
			],
			[
				":q",
				"Set Syntax: SQL"
			],
			[
				"Package Control: install		",
				"Package Control: Install Package"
			],
			[
				"Snippet: ",
				"Snippet: Lorem ipsum"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 125.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Users/william/Develop/Clang_lib/ARMCC/include/string.h",
		"/Users/William/Develop/MiCO/Projects/STM32F2xx/COM.MXCHIP.SPP/sublime/COM.MXCHIP.SPP.sublime-project",
		"/Users/William/Develop/MiCO/mico/core/mico_config.c",
		"/Users/William/Develop/MiCO/include/mico.h",
		"/Users/William/Develop/MiCO/include/mico_security.h",
		"/Users/William/Develop/MiCO/libraries/daemons/config_server/config_server.c",
		"/Users/william/Develop/MiCO/libraries/utilities/json_c/json_object.h",
		"/Users/William/Develop/MiCO/libraries/daemons/config_server/config_server.h",
		"/Users/William/Develop/MiCO/Demos/COM.Apple.HomeKit/HomekitProfiles.h",
		"/Users/William/Develop/MiCO/libraries/daemons/config_server/config_server_menu.c",
		"/Users/William/Develop/MiCO/mico/system/mico_system_init.c",
		"/Users/William/Develop/MiCO/mico/system/easylink/system_easylink.c",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/MICOConfigDelegate.c",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/MICOAppEntrance.c",
		"/Users/William/Develop/MiCO/libraries/utilities/command_line_interface/mico_cli.c",
		"/Users/William/Develop/MiCO/libraries/utilities/command_line_interface/mico_cli.h",
		"/Users/William/Develop/MiCO/include/mico_service.h",
		"/Users/William/Develop/MiCO/libraries/protocols/mdns/mdns.h",
		"/Users/William/Develop/MiCO/libraries/protocols/tftp_ota/tftp_ota.h",
		"/Users/William/Develop/MiCO/libraries/protocols/tftp_ota/tftp_ota.c",
		"/Users/William/Develop/MiCO/mico/system/system_misc.c",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/MICOBonjour.c",
		"/Users/William/Develop/MiCO/libraries/protocols/mdns/mdns.c",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/mico_config.h",
		"/Users/William/Develop/MiCO/libraries/protocols/sntp/sntp.c",
		"/Users/William/Develop/MiCO/libraries/protocols/sntp/sntp.h",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/legacy/RemoteTcpClient.c",
		"/Users/William/Develop/MiCO/MICO/service/mico_service_config_server_menu.c",
		"/Users/William/Develop/MiCO/include/mico_system.h",
		"/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/micokit_ext_mfg.c",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/RemoteTcpClient.c",
		"/Users/William/Develop/MiCO/MICO/service/mico_service_config_server.c",
		"/Users/William/Develop/MiCO/MICO/service/mico_service_mdns.c",
		"/Users/William/Develop/MiCO/MICO/service/mico_service_ntp_client.c",
		"/Users/William/Develop/MiCO/MICO/service/mico_service_ota_by_tftp.c",
		"/Users/William/Develop/MiCO/MICO/system/mico_system.c",
		"/Users/William/Develop/MiCO/MICO/system/mico_system_monitor.c",
		"/Users/William/Develop/MiCO/MICO/system/mico_system_notification.c",
		"/Users/William/Develop/MiCO/MICO/system/mico_system_para_storage.c",
		"/Users/William/Develop/MiCO/MICO/system/mico_system_power_daemon.c",
		"/Users/William/Develop/MiCO/MICO/system/system.h",
		"/Users/William/Develop/MiCO/MICO/system/system_misc.c",
		"/Users/William/Develop/MiCO/MICO/system/system_easylink/system_easylink.c",
		"/Users/William/Develop/MiCO/MICO/system/mico_system_config_server.c",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/mico_delegate.c",
		"/Users/William/Develop/MiCO/MICO/system/mico_system_config_server_menu.c",
		"/Users/william/Develop/MiCO/External/JSON-C/json_object.h",
		"/Users/william/Develop/MiCO/Support/HTTPUtils.h",
		"/Users/William/Develop/MiCO/include/mico_socket.h",
		"/Users/William/Develop/MiCO/Platform/BoardConfig/FRDM_K64/device/MK64F12/MK64F12_ewm.h",
		"/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/services/network/lin/lin.c",
		"/Users/William/Develop/MiCO/Platform/MCU/ATSAMG55/peripherals/Libraries/asf-3.22.0/sam/services/network/lin/lin.h",
		"/Users/William/Develop/MiCO/MICO/service/mico_service_cli.c",
		"/Users/william/Develop/MiCO/include/Common.h",
		"/Users/William/Develop/MiCO/include/MICO.h",
		"/Users/William/Develop/MiCO/MICO/system/system_easylink/system_easylink_wac.c",
		"/Users/William/Develop/MiCO/MICO/system/Find Results",
		"/Users/William/Develop/MiCO/include/Debug.h",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/mico_system_config.h",
		"/Users/William/Develop/MiCO/MICO/Airkiss/Airkiss.c",
		"/Users/william/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_mcu_peripheral.h",
		"/Users/william/Develop/MiCO/include/mico_rtos.h",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/MiCOAPPDefine.h",
		"/Users/william/Develop/MiCO/Demos/COM.MXCHIP.SPP/mico_system_config.h",
		"/Users/William/Develop/MiCO/MICO/service/mico_service_factory_test.c",
		"/Users/william/Develop/MiCO/include/mico_system_context.h",
		"/Users/William/Develop/MiCO/include/mico_system_context.h",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/SppProtocol.c",
		"/Users/william/Develop/MiCO/include/mico_system.h",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/LocalTcpServer.c",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/SppProtocol.h",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/mico_app_context.h",
		"/Users/William/Develop/MiCO/include/MicoDrivers/MicoDriverUart.h",
		"/Users/william/Develop/MiCO/Platform/include/platform_peripheral.h",
		"/Users/william/Develop/MiCO/MICO/system/system.h",
		"/Users/William/Develop/MiCO/MICO/service/MDNSUtils.h",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.SPP/MICOAppDefine.h",
		"/Users/William/Develop/MiCO/include/mico_cli.h",
		"/Users/William/Develop/MiCO/MICO/service/mico_servce_cli.c",
		"/Users/William/Develop/MiCO/MICO/MICONotificationCenter.h",
		"/Users/William/Develop/MiCO/MICO/MICOConfigMenu.h",
		"/Users/William/Develop/MiCO/include/MicoWlan.h",
		"/Users/William/Develop/MiCO/MICO/system/system_init.c",
		"/Users/William/Develop/MiCO/MICO/MICOSystemMonitor.h",
		"/Users/William/Develop/MiCO/MICO/MICOCli.c",
		"/Users/William/Develop/MiCO/MICO/system/mico_system_init.c",
		"/Users/William/Develop/MiCO/MICO/MICONTPClient.c",
		"/Users/William/Develop/MiCO/MICO/system/system_power_daemon.c",
		"/Users/William/Develop/MiCO/MICO/MICODefineddddd.h",
		"/Users/William/Develop/MiCO/MICO/system/mico_system_common.c",
		"/Users/William/Develop/MiCO/MICO/system/system_para_storage.c",
		"/Users/William/Develop/MiCO/MICO/MICOEntrance.c",
		"/Users/William/Develop/MiCO/MICO/MICOParaStorage.c",
		"/Users/william/Develop/MiCO/MICO/MICODefine.h",
		"/Users/William/Develop/MiCO/MICO/mico_system/mico_system_init.c",
		"/Users/william/Develop/MiCO/MICO/MICOCli.h",
		"/Users/William/Develop/MiCO/MICO/mico_system/mico_system_common.c",
		"/Users/william/Develop/MiCO/Demos/COM.MXCHIP.SPP/MICOAppDefine.h",
		"/Users/William/Develop/MiCO/MICO/mico_system/mico_system_internal.h",
		"/Users/William/Develop/MiCO/MICO/mico_system/mico_system_easylink.c",
		"/Users/William/Develop/MiCO/MICO/mico_system/mico_system_easylink_wac.c",
		"/Users/William/Develop/MiCO/MICO/system/system_easylink.c",
		"/Users/William/Develop/MiCO/MICO/mico_system/mico_system_power_daemon.c",
		"/Users/William/Develop/MiCO/MICO/MICODefine.h",
		"/Users/William/Develop/MiCO/MICO/MICOForceOTA.c",
		"/Users/William/Develop/MiCO/MICO/MICOSystemMonitor.c",
		"/Users/William/Develop/MiCO/Support/MDNSUtils.c",
		"/Users/William/Develop/MiCO/MICO/MICOConfigServer.c",
		"/Users/William/Develop/MiCO/MICO/mico_system/mico_system_platform.c",
		"/Users/william/Develop/MiCO/include/MicoWlan.h",
		"/Users/William/Develop/MiCO/Support/HTTPUtils.c",
		"/Users/william/Develop/MiCO/MICO/MICONotificationCenter.h",
		"/Users/William/Develop/MiCO/include/MICORTOS.h",
		"/Users/William/Develop/MiCO/Board/MiCOKit-F205/platform.c",
		"/Users/William/Develop/MiCO/Support/MDNSUtils.h",
		"/Users/William/Develop/MiCO/Board/MiCOKit-3165/platform.h",
		"/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_flash.c",
		"/Users/William/Develop/MiCO/Board/MiCOKit-3162/platform_config.h",
		"/Users/William/Develop/MiCO/Board/MiCOKit-F205/platform_config.h",
		"/Users/William/Develop/MiCO/Demos/COM.MXCHIP.BASIC/os/os_timer.c",
		"/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_mcu_powersave.c",
		"/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/micokit_ext.c",
		"/Users/William/Develop/MiCO/Platform/Drivers/MiCOKit_EXT/key/keys.c",
		"/Users/William/Develop/MiCO/Board/MiCOKit-3162/platform.h",
		"/Users/William/Develop/MiCO/Board/MiCOKit-3162/platform.c",
		"/Users/William/Develop/MiCO/Board/MiCOKit-F205/platform.h",
		"/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/peripherals/platform_spi.c",
		"/Users/William/Develop/MiCO/Platform/MCU/STM32F2xx/EMW1062_Driver/wlan_bus_sdio.c"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
			"<open folders>",
			"",
			"<open folders>",
			"/Users/william/Develop/E-DICE",
			"",
			"<open folders>",
			"/Volumes/C/develop/MDV-STM32-407/EMB_STM32_407_wifi_lib_V2.0.0/",
			"/Volumes/C/develop/MDV-STM32-407/EMB_STM32_407_wifi_lib_V2.0.0/Project/ Data_Send&Recv",
			"/Volumes/C/develop/MDV-STM32-407/EMB_STM32_407_wifi_lib_V2.0.0/Project/STM32F4xx_StdPeriph_Examples"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"NULL",
			"endif",
			"__typeof__",
			"ptrdiff_t",
			"__PTRDIFF_TYPE__",
			"ptrdiff_t",
			"include \"Common.h\"",
			"ptrdiff_t",
			"MICOAddMenuCellToSector",
			"MICOAddSwitchCellToSector",
			"MICOAddFloatCellToSector",
			"MICOAddNumberCellToSector",
			"MICOAddStringCellToSector",
			"MICOAddSector",
			"MICOAddTopMenu",
			"cli_init",
			"cli_init\ncli_init",
			"cli_init",
			"config_server_start",
			"MICOAddTopMenu",
			"MICOStopConfigServer",
			"MICOStartConfigServer",
			"mico_force_ota",
			"mico_cli_init",
			"enable",
			"MICOAddTopMenu",
			"bonjour_init_t",
			"mico_service_mdns_update_txt_record",
			"mico_service_mdns_resume_record",
			"mico_service_mdns_suspend_record",
			"mico_service_mdns_add_record",
			"m_system_",
			"MICOAddSector",
			"mico_system_config_server_delegate_create_device_info",
			"mico_system_delegate_easylink_softap_will_start",
			"soft",
			"mico_system_delegate_easylink_softap_will_start",
			"flashContentInRam_mutex",
			"mico_system_config_server_delegate_create_device_info",
			"MICOAddTopMenu",
			"json_object_to_json_string",
			"MICOAddStringCellToSector",
			"mico_service_config_server_stop",
			"mico_service_config_server_start",
			"Md5Update",
			"mico_system_current_time_get",
			"m_service_",
			"m_system_",
			"micoNotify_ConnectFailedHandler",
			"micoNotify_ConnectFailedHandler\n",
			"mico_notify_WIFI_CONNECT_FAILED",
			"easylink_bonjour_update",
			"easylink_bonjour_start",
			"mico_",
			"MICOStopConfigServer",
			"MICOStartConfigServer",
			"m_service_mdns_update_txt_record",
			"m_service_mdns_resume_record",
			"m_service_mdns_suspend_record",
			"m_service_mdns_add_record",
			"mico_cli_init",
			"MICOStartNTPClient",
			"mico_service_",
			"m_system_delegate_config_recv_auth_data",
			"m_system_delegate_config_success",
			"m_system_delegate_config_recv_ssid",
			"m_system_delegate_config_will_stop",
			"m_system_delegate_config_will_start",
			"mico_system_",
			"msyste",
			"mico_system",
			"MICOAddNumberCellToSector",
			"MICOAddTopMenu",
			"MICOStartConfigServer",
			"inContext",
			"Context",
			"_LocalConfigRespondInComingMessage",
			"MICOStartConfigServer",
			"mico_system_delegate_recv_auth_data",
			"ConfigELRecvAuthData",
			"mico_system_delegate_config_by",
			"ConfigRecvSSID",
			"ConfigIsSuccessBy",
			"ConfigWillStop",
			"ConfigWillStart",
			"mico_system_notify_remove_all",
			"MICORemoveAllNotification",
			"MICORemoveNotification",
			"MICOAddNotification",
			"MICORemoveAllNotification",
			"FOTA_WifiStatusHandler",
			"mico_notify_WifiScanCompleteHandler",
			"MICOAddNotification",
			"MICOInitNotificationCenter",
			"MICOAddNotification",
			"mico_system_monitor_daemen_start",
			"mico_system_context_restore",
			"mico_system_context_get_user_data",
			"mico_system_context_update",
			"mico_system_power_perform",
			"mico_system_power_daemon_start",
			"mico_system_context_update",
			"mico_system_init",
			"mico_system_context_get",
			"mico_system_context_restore",
			"mico_system_config",
			"MICOInitNotificationCenter",
			"debug_print_assert",
			"MICO_SYSTEM_MONITOR_ENABLE",
			"mico_system_monitor_daemen_start",
			"mico_system_state_t",
			"MICOInitNotificationCenter",
			"mico_system_update_config",
			"mico_system_restore_config",
			"mico_system_get_user_config_data",
			"mico_system_get_context",
			"system_network_daemen_start",
			"system_notification_init",
			"mico_system_notification_init",
			"MICOInitNotificationCenter",
			"mico_system_register_monitor",
			"mico_system_update_monitor",
			"mico_system_power_perform",
			"OSStatus",
			"system_monitor_daemen_start",
			"MICOStartSystemMonitor",
			"system_monitor_daemen_start",
			"MicoRtcGetTime"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"config_server_create_sub_menu_cell",
			"config_server_create_bool_cell",
			"config_server_create_float_cell",
			"config_server_create_number_cell",
			"config_server_create_string_cell",
			"config_server_create_sector",
			"config_server_stop",
			"config_server_start",
			"tftp_ota",
			"cli_init",
			"mdns_init_t",
			"mdns_update_txt_record",
			"mdns_resume_record",
			"mdns_suspend_record",
			"mdns_add_record",
			"mico_system_",
			"mico_system_config_server_stop",
			"mico_system_config_server_start",
			"mico_system_time_get",
			"mico_service_",
			"mico_system_",
			"m_service_config_server_stop",
			"m_service_config_server_start",
			"m_service_mdns_update_txt",
			"m_service_mdns_resume",
			"m_service_mdns_suspend",
			"m_service_mdns_add",
			"m_service_cli_start",
			"m_service_ntp_client_start",
			"m_service_",
			"m_system_delegate_config_recv_auth_data",
			"m_system_delegate_easylink_success",
			"m_system_delegate_easylink_recv_ssid",
			"m_system_delegate_easylink_will_stop",
			"m_system_delegate_easylink_will_start",
			"m_system_",
			"m_system",
			"msystem",
			"mico_system_delegate_config_recv_auth_data",
			"mico_system_delegate_recv_auth_data",
			"mico_system_delegate_config_success",
			"mico_system_delegate_config_recv_ssid",
			"mico_system_delegate_config_by",
			"mico_system_delegate_config_will_stop",
			"mico_system_delegate_config_will_start",
			"mico_system_notify_remove_all",
			"mico_system_notify_remove",
			"mico_system_notify_register",
			"mico_config",
			"mico_system_context_update",
			"mico_system_context_restore",
			"mico_system_context_get_user_data",
			"mico_system_context_get",
			"mico_system_monitor_register",
			"mico_system_monitor_update",
			"OSStatus",
			"MICO",
			"MICO_DISABLE_STDIO"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/Users/William/Develop/MiCO/include/Common.h",
					"settings":
					{
						"buffer_size": 29050,
						"regions":
						{
						},
						"selection":
						[
							[
								28657,
								28657
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 10231.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"settings":
					{
						"buffer_size": 382002,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										401,
										405
									],
									[
										427,
										431
									],
									[
										874,
										878
									],
									[
										900,
										904
									],
									[
										1365,
										1369
									],
									[
										1944,
										1948
									],
									[
										2538,
										2542
									],
									[
										2544,
										2548
									],
									[
										3129,
										3133
									],
									[
										3720,
										3724
									],
									[
										4311,
										4315
									],
									[
										4317,
										4321
									],
									[
										4899,
										4903
									],
									[
										5406,
										5410
									],
									[
										5528,
										5532
									],
									[
										5784,
										5788
									],
									[
										5996,
										6000
									],
									[
										6240,
										6244
									],
									[
										6716,
										6720
									],
									[
										7169,
										7173
									],
									[
										7599,
										7603
									],
									[
										8023,
										8027
									],
									[
										8107,
										8111
									],
									[
										8353,
										8357
									],
									[
										8663,
										8667
									],
									[
										8984,
										8988
									],
									[
										9213,
										9217
									],
									[
										9432,
										9436
									],
									[
										9680,
										9684
									],
									[
										9891,
										9895
									],
									[
										10074,
										10078
									],
									[
										10337,
										10341
									],
									[
										10649,
										10653
									],
									[
										10800,
										10804
									],
									[
										11140,
										11144
									],
									[
										11498,
										11502
									],
									[
										11504,
										11508
									],
									[
										11708,
										11712
									],
									[
										11714,
										11718
									],
									[
										11921,
										11925
									],
									[
										11927,
										11931
									],
									[
										12156,
										12160
									],
									[
										12461,
										12465
									],
									[
										12648,
										12652
									],
									[
										12868,
										12872
									],
									[
										13075,
										13079
									],
									[
										13313,
										13317
									],
									[
										13500,
										13504
									],
									[
										13637,
										13641
									],
									[
										13685,
										13689
									],
									[
										13710,
										13714
									],
									[
										13761,
										13765
									],
									[
										13835,
										13839
									],
									[
										13914,
										13918
									],
									[
										14050,
										14054
									],
									[
										14237,
										14241
									],
									[
										14444,
										14448
									],
									[
										14682,
										14686
									],
									[
										14869,
										14873
									],
									[
										15006,
										15010
									],
									[
										15066,
										15070
									],
									[
										15216,
										15220
									],
									[
										15285,
										15289
									],
									[
										15413,
										15417
									],
									[
										15655,
										15659
									],
									[
										15914,
										15918
									],
									[
										16130,
										16134
									],
									[
										16324,
										16328
									],
									[
										16468,
										16472
									],
									[
										16759,
										16763
									],
									[
										16912,
										16916
									],
									[
										17150,
										17154
									],
									[
										17357,
										17361
									],
									[
										17612,
										17616
									],
									[
										17632,
										17636
									],
									[
										17936,
										17940
									],
									[
										18113,
										18117
									],
									[
										18199,
										18203
									],
									[
										18399,
										18403
									],
									[
										18569,
										18573
									],
									[
										18615,
										18619
									],
									[
										18829,
										18833
									],
									[
										18915,
										18919
									],
									[
										19115,
										19119
									],
									[
										19342,
										19346
									],
									[
										19476,
										19480
									],
									[
										19522,
										19526
									],
									[
										19740,
										19744
									],
									[
										19826,
										19830
									],
									[
										20026,
										20030
									],
									[
										20197,
										20201
									],
									[
										20336,
										20340
									],
									[
										20382,
										20386
									],
									[
										20627,
										20631
									],
									[
										20816,
										20820
									],
									[
										20993,
										20997
									],
									[
										21170,
										21174
									],
									[
										21371,
										21375
									],
									[
										21510,
										21514
									],
									[
										21549,
										21553
									],
									[
										21601,
										21605
									],
									[
										21705,
										21709
									],
									[
										21903,
										21907
									],
									[
										21999,
										22003
									],
									[
										22180,
										22184
									],
									[
										22437,
										22441
									],
									[
										22788,
										22792
									],
									[
										23006,
										23010
									],
									[
										23182,
										23186
									],
									[
										23378,
										23382
									],
									[
										23523,
										23527
									],
									[
										23726,
										23730
									],
									[
										23867,
										23871
									],
									[
										24063,
										24067
									],
									[
										24202,
										24206
									],
									[
										24411,
										24415
									],
									[
										24547,
										24551
									],
									[
										24735,
										24739
									],
									[
										24879,
										24883
									],
									[
										25074,
										25078
									],
									[
										25219,
										25223
									],
									[
										25426,
										25430
									],
									[
										25570,
										25574
									],
									[
										25763,
										25767
									],
									[
										25910,
										25914
									],
									[
										26114,
										26118
									],
									[
										26258,
										26262
									],
									[
										26445,
										26449
									],
									[
										26590,
										26594
									],
									[
										26783,
										26787
									],
									[
										26925,
										26929
									],
									[
										27110,
										27114
									],
									[
										27256,
										27260
									],
									[
										27455,
										27459
									],
									[
										27589,
										27593
									],
									[
										27635,
										27639
									],
									[
										27714,
										27718
									],
									[
										27869,
										27873
									],
									[
										28037,
										28041
									],
									[
										28149,
										28153
									],
									[
										28383,
										28387
									],
									[
										28426,
										28430
									],
									[
										28531,
										28535
									],
									[
										28594,
										28598
									],
									[
										28798,
										28802
									],
									[
										28940,
										28944
									],
									[
										29082,
										29086
									],
									[
										29209,
										29213
									],
									[
										29349,
										29353
									],
									[
										29572,
										29576
									],
									[
										29807,
										29811
									],
									[
										30087,
										30091
									],
									[
										30357,
										30361
									],
									[
										30363,
										30367
									],
									[
										30557,
										30561
									],
									[
										30856,
										30860
									],
									[
										31068,
										31072
									],
									[
										31160,
										31164
									],
									[
										31277,
										31281
									],
									[
										31425,
										31429
									],
									[
										31538,
										31542
									],
									[
										31778,
										31782
									],
									[
										31918,
										31922
									],
									[
										32106,
										32110
									],
									[
										32247,
										32251
									],
									[
										32384,
										32388
									],
									[
										32531,
										32535
									],
									[
										32688,
										32692
									],
									[
										32727,
										32731
									],
									[
										32826,
										32830
									],
									[
										32940,
										32944
									],
									[
										33200,
										33204
									],
									[
										33242,
										33246
									],
									[
										33280,
										33284
									],
									[
										33492,
										33496
									],
									[
										33634,
										33638
									],
									[
										33763,
										33767
									],
									[
										33812,
										33816
									],
									[
										34032,
										34036
									],
									[
										34205,
										34209
									],
									[
										34435,
										34439
									],
									[
										34728,
										34732
									],
									[
										34784,
										34788
									],
									[
										34988,
										34992
									],
									[
										35081,
										35085
									],
									[
										35127,
										35131
									],
									[
										35453,
										35457
									],
									[
										35611,
										35615
									],
									[
										35823,
										35827
									],
									[
										35829,
										35833
									],
									[
										35835,
										35839
									],
									[
										36093,
										36097
									],
									[
										36322,
										36326
									],
									[
										36484,
										36488
									],
									[
										36662,
										36666
									],
									[
										36793,
										36797
									],
									[
										37049,
										37053
									],
									[
										37190,
										37194
									],
									[
										37319,
										37323
									],
									[
										37325,
										37329
									],
									[
										37517,
										37521
									],
									[
										37711,
										37715
									],
									[
										37816,
										37820
									],
									[
										38038,
										38042
									],
									[
										38044,
										38048
									],
									[
										38070,
										38074
									],
									[
										38308,
										38312
									],
									[
										38382,
										38386
									],
									[
										38398,
										38402
									],
									[
										38541,
										38545
									],
									[
										38775,
										38779
									],
									[
										39008,
										39012
									],
									[
										39223,
										39227
									],
									[
										39483,
										39487
									],
									[
										39673,
										39677
									],
									[
										39863,
										39867
									],
									[
										40056,
										40060
									],
									[
										40326,
										40330
									],
									[
										40403,
										40407
									],
									[
										40611,
										40615
									],
									[
										40659,
										40663
									],
									[
										40816,
										40820
									],
									[
										40993,
										40997
									],
									[
										41211,
										41215
									],
									[
										41533,
										41537
									],
									[
										41801,
										41805
									],
									[
										42031,
										42035
									],
									[
										42305,
										42309
									],
									[
										42361,
										42365
									],
									[
										42583,
										42587
									],
									[
										42853,
										42857
									],
									[
										42966,
										42970
									],
									[
										43077,
										43081
									],
									[
										43184,
										43188
									],
									[
										43294,
										43298
									],
									[
										43501,
										43505
									],
									[
										43633,
										43637
									],
									[
										43673,
										43677
									],
									[
										43823,
										43827
									],
									[
										43936,
										43940
									],
									[
										44070,
										44074
									],
									[
										44182,
										44186
									],
									[
										44327,
										44331
									],
									[
										44481,
										44485
									],
									[
										44662,
										44666
									],
									[
										44816,
										44820
									],
									[
										44961,
										44965
									],
									[
										45115,
										45119
									],
									[
										45222,
										45226
									],
									[
										45376,
										45380
									],
									[
										45501,
										45505
									],
									[
										45603,
										45607
									],
									[
										45704,
										45708
									],
									[
										45801,
										45805
									],
									[
										45944,
										45948
									],
									[
										45999,
										46003
									],
									[
										46061,
										46065
									],
									[
										46192,
										46196
									],
									[
										46289,
										46293
									],
									[
										46531,
										46535
									],
									[
										46697,
										46701
									],
									[
										46880,
										46884
									],
									[
										47062,
										47066
									],
									[
										47068,
										47072
									],
									[
										47252,
										47256
									],
									[
										47416,
										47420
									],
									[
										47686,
										47690
									],
									[
										47999,
										48003
									],
									[
										48172,
										48176
									],
									[
										48285,
										48289
									],
									[
										48474,
										48478
									],
									[
										48675,
										48679
									],
									[
										48932,
										48936
									],
									[
										49104,
										49108
									],
									[
										49442,
										49446
									],
									[
										49555,
										49559
									],
									[
										49804,
										49808
									],
									[
										50284,
										50288
									],
									[
										50741,
										50745
									],
									[
										51038,
										51042
									],
									[
										51220,
										51224
									],
									[
										51618,
										51622
									],
									[
										51915,
										51919
									],
									[
										52108,
										52112
									],
									[
										52441,
										52445
									],
									[
										52591,
										52595
									],
									[
										52721,
										52725
									],
									[
										52881,
										52885
									],
									[
										53264,
										53268
									],
									[
										53639,
										53643
									],
									[
										53993,
										53997
									],
									[
										54044,
										54048
									],
									[
										54533,
										54537
									],
									[
										54760,
										54764
									],
									[
										54967,
										54971
									],
									[
										55251,
										55255
									],
									[
										55502,
										55506
									],
									[
										55688,
										55692
									],
									[
										55963,
										55967
									],
									[
										56266,
										56270
									],
									[
										56447,
										56451
									],
									[
										56486,
										56490
									],
									[
										56776,
										56780
									],
									[
										57017,
										57021
									],
									[
										57195,
										57199
									],
									[
										57485,
										57489
									],
									[
										57798,
										57802
									],
									[
										58025,
										58029
									],
									[
										58232,
										58236
									],
									[
										58518,
										58522
									],
									[
										58780,
										58784
									],
									[
										58951,
										58955
									],
									[
										59171,
										59175
									],
									[
										59505,
										59509
									],
									[
										59593,
										59597
									],
									[
										59894,
										59898
									],
									[
										59982,
										59986
									],
									[
										60216,
										60220
									],
									[
										60305,
										60309
									],
									[
										60609,
										60613
									],
									[
										60708,
										60712
									],
									[
										60945,
										60949
									],
									[
										61201,
										61205
									],
									[
										61476,
										61480
									],
									[
										61565,
										61569
									],
									[
										61797,
										61801
									],
									[
										61886,
										61890
									],
									[
										62062,
										62066
									],
									[
										62329,
										62333
									],
									[
										62417,
										62421
									],
									[
										62589,
										62593
									],
									[
										62816,
										62820
									],
									[
										63061,
										63065
									],
									[
										63299,
										63303
									],
									[
										63539,
										63543
									],
									[
										63802,
										63806
									],
									[
										63822,
										63826
									],
									[
										63925,
										63929
									],
									[
										64111,
										64115
									],
									[
										64152,
										64156
									],
									[
										64311,
										64315
									],
									[
										64413,
										64417
									],
									[
										64563,
										64567
									],
									[
										64757,
										64761
									],
									[
										64945,
										64949
									],
									[
										65097,
										65101
									],
									[
										65138,
										65142
									],
									[
										65298,
										65302
									],
									[
										65417,
										65421
									],
									[
										65566,
										65570
									],
									[
										65738,
										65742
									],
									[
										65859,
										65863
									],
									[
										66017,
										66021
									],
									[
										66198,
										66202
									],
									[
										66323,
										66327
									],
									[
										66449,
										66453
									],
									[
										66551,
										66555
									],
									[
										66694,
										66698
									],
									[
										66854,
										66858
									],
									[
										66956,
										66960
									],
									[
										67078,
										67082
									],
									[
										67272,
										67276
									],
									[
										67399,
										67403
									],
									[
										67420,
										67424
									],
									[
										67520,
										67524
									],
									[
										67642,
										67646
									],
									[
										67813,
										67817
									],
									[
										67938,
										67942
									],
									[
										68196,
										68200
									],
									[
										68416,
										68420
									],
									[
										68559,
										68563
									],
									[
										68727,
										68731
									],
									[
										68910,
										68914
									],
									[
										69108,
										69112
									],
									[
										69464,
										69468
									],
									[
										69619,
										69623
									],
									[
										69945,
										69949
									],
									[
										70127,
										70131
									],
									[
										70285,
										70289
									],
									[
										70534,
										70538
									],
									[
										70658,
										70662
									],
									[
										70919,
										70923
									],
									[
										70967,
										70971
									],
									[
										71144,
										71148
									],
									[
										71368,
										71372
									],
									[
										71528,
										71532
									],
									[
										71697,
										71701
									],
									[
										71862,
										71866
									],
									[
										72041,
										72045
									],
									[
										72221,
										72225
									],
									[
										72257,
										72261
									],
									[
										72492,
										72496
									],
									[
										72607,
										72611
									],
									[
										72772,
										72776
									],
									[
										73023,
										73027
									],
									[
										73127,
										73131
									],
									[
										73265,
										73269
									],
									[
										73539,
										73543
									],
									[
										73728,
										73732
									],
									[
										73828,
										73832
									],
									[
										73958,
										73962
									],
									[
										74115,
										74119
									],
									[
										74220,
										74224
									],
									[
										74394,
										74398
									],
									[
										74669,
										74673
									],
									[
										74801,
										74805
									],
									[
										74837,
										74841
									],
									[
										75311,
										75315
									],
									[
										75503,
										75507
									],
									[
										75526,
										75530
									],
									[
										75789,
										75793
									],
									[
										76087,
										76091
									],
									[
										76523,
										76527
									],
									[
										76995,
										76999
									],
									[
										77354,
										77358
									],
									[
										77671,
										77675
									],
									[
										77848,
										77852
									],
									[
										78150,
										78154
									],
									[
										78479,
										78483
									],
									[
										78609,
										78613
									],
									[
										78816,
										78820
									],
									[
										78857,
										78861
									],
									[
										79091,
										79095
									],
									[
										79332,
										79336
									],
									[
										79504,
										79508
									],
									[
										79730,
										79734
									],
									[
										79987,
										79991
									],
									[
										80031,
										80035
									],
									[
										80076,
										80080
									],
									[
										80344,
										80348
									],
									[
										80385,
										80389
									],
									[
										80402,
										80406
									],
									[
										80533,
										80537
									],
									[
										80664,
										80668
									],
									[
										80839,
										80843
									],
									[
										81092,
										81096
									],
									[
										81424,
										81428
									],
									[
										81700,
										81704
									],
									[
										81706,
										81710
									],
									[
										81869,
										81873
									],
									[
										81875,
										81879
									],
									[
										82077,
										82081
									],
									[
										82262,
										82266
									],
									[
										82551,
										82555
									],
									[
										82830,
										82834
									],
									[
										83111,
										83115
									],
									[
										83390,
										83394
									],
									[
										83675,
										83679
									],
									[
										83785,
										83789
									],
									[
										83999,
										84003
									],
									[
										84109,
										84113
									],
									[
										84318,
										84322
									],
									[
										84484,
										84488
									],
									[
										84745,
										84749
									],
									[
										84987,
										84991
									],
									[
										85305,
										85309
									],
									[
										85388,
										85392
									],
									[
										85593,
										85597
									],
									[
										85676,
										85680
									],
									[
										85879,
										85883
									],
									[
										85962,
										85966
									],
									[
										86161,
										86165
									],
									[
										86244,
										86248
									],
									[
										86449,
										86453
									],
									[
										86532,
										86536
									],
									[
										86725,
										86729
									],
									[
										86808,
										86812
									],
									[
										87013,
										87017
									],
									[
										87096,
										87100
									],
									[
										87303,
										87307
									],
									[
										87386,
										87390
									],
									[
										87591,
										87595
									],
									[
										87674,
										87678
									],
									[
										87884,
										87888
									],
									[
										87967,
										87971
									],
									[
										88177,
										88181
									],
									[
										88260,
										88264
									],
									[
										88469,
										88473
									],
									[
										88552,
										88556
									],
									[
										88765,
										88769
									],
									[
										88848,
										88852
									],
									[
										89061,
										89065
									],
									[
										89144,
										89148
									],
									[
										89367,
										89371
									],
									[
										89450,
										89454
									],
									[
										89659,
										89663
									],
									[
										89742,
										89746
									],
									[
										89948,
										89952
									],
									[
										90031,
										90035
									],
									[
										90254,
										90258
									],
									[
										90337,
										90341
									],
									[
										90548,
										90552
									],
									[
										90631,
										90635
									],
									[
										90850,
										90854
									],
									[
										90933,
										90937
									],
									[
										91130,
										91134
									],
									[
										91213,
										91217
									],
									[
										91418,
										91422
									],
									[
										91500,
										91504
									],
									[
										91713,
										91717
									],
									[
										91796,
										91800
									],
									[
										91983,
										91987
									],
									[
										92066,
										92070
									],
									[
										92273,
										92277
									],
									[
										92356,
										92360
									],
									[
										92575,
										92579
									],
									[
										92658,
										92662
									],
									[
										92868,
										92872
									],
									[
										92951,
										92955
									],
									[
										93149,
										93153
									],
									[
										93232,
										93236
									],
									[
										93452,
										93456
									],
									[
										93486,
										93490
									],
									[
										93693,
										93697
									],
									[
										93727,
										93731
									],
									[
										93936,
										93940
									],
									[
										93970,
										93974
									],
									[
										94172,
										94176
									],
									[
										94206,
										94210
									],
									[
										94423,
										94427
									],
									[
										94506,
										94510
									],
									[
										94709,
										94713
									],
									[
										94743,
										94747
									],
									[
										94939,
										94943
									],
									[
										95022,
										95026
									],
									[
										95207,
										95211
									],
									[
										95290,
										95294
									],
									[
										95509,
										95513
									],
									[
										95592,
										95596
									],
									[
										95791,
										95795
									],
									[
										95874,
										95878
									],
									[
										96082,
										96086
									],
									[
										96165,
										96169
									],
									[
										96363,
										96367
									],
									[
										96446,
										96450
									],
									[
										96652,
										96656
									],
									[
										96735,
										96739
									],
									[
										96942,
										96946
									],
									[
										97025,
										97029
									],
									[
										97232,
										97236
									],
									[
										97315,
										97319
									],
									[
										97506,
										97510
									],
									[
										97589,
										97593
									],
									[
										97780,
										97784
									],
									[
										97863,
										97867
									],
									[
										98054,
										98058
									],
									[
										98137,
										98141
									],
									[
										98336,
										98340
									],
									[
										98419,
										98423
									],
									[
										98613,
										98617
									],
									[
										98696,
										98700
									],
									[
										98887,
										98891
									],
									[
										98970,
										98974
									],
									[
										99177,
										99181
									],
									[
										99260,
										99264
									],
									[
										99451,
										99455
									],
									[
										99534,
										99538
									],
									[
										99726,
										99730
									],
									[
										99809,
										99813
									],
									[
										100000,
										100004
									],
									[
										100083,
										100087
									],
									[
										100274,
										100278
									],
									[
										100357,
										100361
									],
									[
										100548,
										100552
									],
									[
										100631,
										100635
									],
									[
										100822,
										100826
									],
									[
										100905,
										100909
									],
									[
										101096,
										101100
									],
									[
										101179,
										101183
									],
									[
										101370,
										101374
									],
									[
										101453,
										101457
									],
									[
										101644,
										101648
									],
									[
										101727,
										101731
									],
									[
										101918,
										101922
									],
									[
										102001,
										102005
									],
									[
										102192,
										102196
									],
									[
										102275,
										102279
									],
									[
										102483,
										102487
									],
									[
										102566,
										102570
									],
									[
										102778,
										102782
									],
									[
										102861,
										102865
									],
									[
										103069,
										103073
									],
									[
										103152,
										103156
									],
									[
										103364,
										103368
									],
									[
										103447,
										103451
									],
									[
										103650,
										103654
									],
									[
										103733,
										103737
									],
									[
										103947,
										103951
									],
									[
										104030,
										104034
									],
									[
										104233,
										104237
									],
									[
										104316,
										104320
									],
									[
										104530,
										104534
									],
									[
										104564,
										104568
									],
									[
										104773,
										104777
									],
									[
										104808,
										104812
									],
									[
										105002,
										105006
									],
									[
										105037,
										105041
									],
									[
										105231,
										105235
									],
									[
										105266,
										105270
									],
									[
										105461,
										105465
									],
									[
										105496,
										105500
									],
									[
										105690,
										105694
									],
									[
										105725,
										105729
									],
									[
										105916,
										105920
									],
									[
										105999,
										106003
									],
									[
										106209,
										106213
									],
									[
										106292,
										106296
									],
									[
										106503,
										106507
									],
									[
										106587,
										106591
									],
									[
										106801,
										106805
									],
									[
										106884,
										106888
									],
									[
										107081,
										107085
									],
									[
										107165,
										107169
									],
									[
										107360,
										107364
									],
									[
										107443,
										107447
									],
									[
										107634,
										107638
									],
									[
										107717,
										107721
									],
									[
										107908,
										107912
									],
									[
										107991,
										107995
									],
									[
										108182,
										108186
									],
									[
										108265,
										108269
									],
									[
										108456,
										108460
									],
									[
										108539,
										108543
									],
									[
										108732,
										108736
									],
									[
										108815,
										108819
									],
									[
										109009,
										109013
									],
									[
										109092,
										109096
									],
									[
										109287,
										109291
									],
									[
										109370,
										109374
									],
									[
										109567,
										109571
									],
									[
										109650,
										109654
									],
									[
										109845,
										109849
									],
									[
										109928,
										109932
									],
									[
										110123,
										110127
									],
									[
										110206,
										110210
									],
									[
										110404,
										110408
									],
									[
										110487,
										110491
									],
									[
										110686,
										110690
									],
									[
										110769,
										110773
									],
									[
										110965,
										110969
									],
									[
										111048,
										111052
									],
									[
										111258,
										111262
									],
									[
										111341,
										111345
									],
									[
										111532,
										111536
									],
									[
										111615,
										111619
									],
									[
										111807,
										111811
									],
									[
										111890,
										111894
									],
									[
										112101,
										112105
									],
									[
										112184,
										112188
									],
									[
										112394,
										112398
									],
									[
										112477,
										112481
									],
									[
										112678,
										112682
									],
									[
										112761,
										112765
									],
									[
										112963,
										112967
									],
									[
										113046,
										113050
									],
									[
										113251,
										113255
									],
									[
										113334,
										113338
									],
									[
										113541,
										113545
									],
									[
										113624,
										113628
									],
									[
										113815,
										113819
									],
									[
										113898,
										113902
									],
									[
										114089,
										114093
									],
									[
										114172,
										114176
									],
									[
										114382,
										114386
									],
									[
										114465,
										114469
									],
									[
										114675,
										114679
									],
									[
										114758,
										114762
									],
									[
										114968,
										114972
									],
									[
										115051,
										115055
									],
									[
										115262,
										115266
									],
									[
										115345,
										115349
									],
									[
										115543,
										115547
									],
									[
										115626,
										115630
									],
									[
										115825,
										115829
									],
									[
										115908,
										115912
									],
									[
										116115,
										116119
									],
									[
										116198,
										116202
									],
									[
										116411,
										116415
									],
									[
										116494,
										116498
									],
									[
										116691,
										116695
									],
									[
										116774,
										116778
									],
									[
										116987,
										116991
									],
									[
										117070,
										117074
									],
									[
										117264,
										117268
									],
									[
										117347,
										117351
									],
									[
										117559,
										117563
									],
									[
										117593,
										117597
									],
									[
										117790,
										117794
									],
									[
										117873,
										117877
									],
									[
										118071,
										118075
									],
									[
										118154,
										118158
									],
									[
										118364,
										118368
									],
									[
										118447,
										118451
									],
									[
										118655,
										118659
									],
									[
										118738,
										118742
									],
									[
										118937,
										118941
									],
									[
										119020,
										119024
									],
									[
										119213,
										119217
									],
									[
										119296,
										119300
									],
									[
										119490,
										119494
									],
									[
										119573,
										119577
									],
									[
										119764,
										119768
									],
									[
										119847,
										119851
									],
									[
										120038,
										120042
									],
									[
										120121,
										120125
									],
									[
										120312,
										120316
									],
									[
										120395,
										120399
									],
									[
										120586,
										120590
									],
									[
										120669,
										120673
									],
									[
										120878,
										120882
									],
									[
										120961,
										120965
									],
									[
										121171,
										121175
									],
									[
										121254,
										121258
									],
									[
										121464,
										121468
									],
									[
										121547,
										121551
									],
									[
										121738,
										121742
									],
									[
										121821,
										121825
									],
									[
										122012,
										122016
									],
									[
										122095,
										122099
									],
									[
										122286,
										122290
									],
									[
										122369,
										122373
									],
									[
										122570,
										122574
									],
									[
										122653,
										122657
									],
									[
										122881,
										122885
									],
									[
										122964,
										122968
									],
									[
										123183,
										123187
									],
									[
										123266,
										123270
									],
									[
										123494,
										123498
									],
									[
										123577,
										123581
									],
									[
										123793,
										123797
									],
									[
										123876,
										123880
									],
									[
										124078,
										124082
									],
									[
										124161,
										124165
									],
									[
										124353,
										124357
									],
									[
										124436,
										124440
									],
									[
										124646,
										124650
									],
									[
										124729,
										124733
									],
									[
										125042,
										125046
									],
									[
										125090,
										125094
									],
									[
										125432,
										125436
									],
									[
										125438,
										125442
									],
									[
										125664,
										125668
									],
									[
										125670,
										125674
									],
									[
										125986,
										125990
									],
									[
										126024,
										126028
									],
									[
										126058,
										126062
									],
									[
										126268,
										126272
									],
									[
										126306,
										126310
									],
									[
										126340,
										126344
									],
									[
										126550,
										126554
									],
									[
										126588,
										126592
									],
									[
										126622,
										126626
									],
									[
										126866,
										126870
									],
									[
										126904,
										126908
									],
									[
										126938,
										126942
									],
									[
										127182,
										127186
									],
									[
										127220,
										127224
									],
									[
										127254,
										127258
									],
									[
										127507,
										127511
									],
									[
										127545,
										127549
									],
									[
										127579,
										127583
									],
									[
										127822,
										127826
									],
									[
										127860,
										127864
									],
									[
										127894,
										127898
									],
									[
										128150,
										128154
									],
									[
										128188,
										128192
									],
									[
										128222,
										128226
									],
									[
										128500,
										128504
									],
									[
										128538,
										128542
									],
									[
										128572,
										128576
									],
									[
										128806,
										128810
									],
									[
										128844,
										128848
									],
									[
										128878,
										128882
									],
									[
										129127,
										129131
									],
									[
										129165,
										129169
									],
									[
										129199,
										129203
									],
									[
										129423,
										129427
									],
									[
										129461,
										129465
									],
									[
										129495,
										129499
									],
									[
										129720,
										129724
									],
									[
										129758,
										129762
									],
									[
										129792,
										129796
									],
									[
										130017,
										130021
									],
									[
										130055,
										130059
									],
									[
										130089,
										130093
									],
									[
										130308,
										130312
									],
									[
										130346,
										130350
									],
									[
										130380,
										130384
									],
									[
										130617,
										130621
									],
									[
										130655,
										130659
									],
									[
										130689,
										130693
									],
									[
										130898,
										130902
									],
									[
										130936,
										130940
									],
									[
										130970,
										130974
									],
									[
										131200,
										131204
									],
									[
										131238,
										131242
									],
									[
										131272,
										131276
									],
									[
										131486,
										131490
									],
									[
										131524,
										131528
									],
									[
										131558,
										131562
									],
									[
										131774,
										131778
									],
									[
										131812,
										131816
									],
									[
										131846,
										131850
									],
									[
										132064,
										132068
									],
									[
										132102,
										132106
									],
									[
										132136,
										132140
									],
									[
										132377,
										132381
									],
									[
										132415,
										132419
									],
									[
										132449,
										132453
									],
									[
										132663,
										132667
									],
									[
										132701,
										132705
									],
									[
										132735,
										132739
									],
									[
										132931,
										132935
									],
									[
										132969,
										132973
									],
									[
										133003,
										133007
									],
									[
										133218,
										133222
									],
									[
										133256,
										133260
									],
									[
										133290,
										133294
									],
									[
										133520,
										133524
									],
									[
										133558,
										133562
									],
									[
										133592,
										133596
									],
									[
										133822,
										133826
									],
									[
										133860,
										133864
									],
									[
										133894,
										133898
									],
									[
										134114,
										134118
									],
									[
										134152,
										134156
									],
									[
										134186,
										134190
									],
									[
										134428,
										134432
									],
									[
										134466,
										134470
									],
									[
										134500,
										134504
									],
									[
										134715,
										134719
									],
									[
										134753,
										134757
									],
									[
										134787,
										134791
									],
									[
										135004,
										135008
									],
									[
										135042,
										135046
									],
									[
										135076,
										135080
									],
									[
										135291,
										135295
									],
									[
										135329,
										135333
									],
									[
										135363,
										135367
									],
									[
										135578,
										135582
									],
									[
										135616,
										135620
									],
									[
										135650,
										135654
									],
									[
										135865,
										135869
									],
									[
										135903,
										135907
									],
									[
										135937,
										135941
									],
									[
										136152,
										136156
									],
									[
										136190,
										136194
									],
									[
										136224,
										136228
									],
									[
										136445,
										136449
									],
									[
										136483,
										136487
									],
									[
										136517,
										136521
									],
									[
										136739,
										136743
									],
									[
										136777,
										136781
									],
									[
										136811,
										136815
									],
									[
										137035,
										137039
									],
									[
										137073,
										137077
									],
									[
										137107,
										137111
									],
									[
										137333,
										137337
									],
									[
										137371,
										137375
									],
									[
										137405,
										137409
									],
									[
										137619,
										137623
									],
									[
										137657,
										137661
									],
									[
										137691,
										137695
									],
									[
										137908,
										137912
									],
									[
										137946,
										137950
									],
									[
										137980,
										137984
									],
									[
										138194,
										138198
									],
									[
										138232,
										138236
									],
									[
										138266,
										138270
									],
									[
										138480,
										138484
									],
									[
										138518,
										138522
									],
									[
										138552,
										138556
									],
									[
										138766,
										138770
									],
									[
										138804,
										138808
									],
									[
										138838,
										138842
									],
									[
										139052,
										139056
									],
									[
										139090,
										139094
									],
									[
										139124,
										139128
									],
									[
										139377,
										139381
									],
									[
										139415,
										139419
									],
									[
										139449,
										139453
									],
									[
										139668,
										139672
									],
									[
										139706,
										139710
									],
									[
										139740,
										139744
									],
									[
										139954,
										139958
									],
									[
										139992,
										139996
									],
									[
										140026,
										140030
									],
									[
										140249,
										140253
									],
									[
										140287,
										140291
									],
									[
										140321,
										140325
									],
									[
										140546,
										140550
									],
									[
										140584,
										140588
									],
									[
										140618,
										140622
									],
									[
										140843,
										140847
									],
									[
										140881,
										140885
									],
									[
										140915,
										140919
									],
									[
										141141,
										141145
									],
									[
										141179,
										141183
									],
									[
										141213,
										141217
									],
									[
										141428,
										141432
									],
									[
										141466,
										141470
									],
									[
										141500,
										141504
									],
									[
										141714,
										141718
									],
									[
										141752,
										141756
									],
									[
										141786,
										141790
									],
									[
										142001,
										142005
									],
									[
										142039,
										142043
									],
									[
										142073,
										142077
									],
									[
										142288,
										142292
									],
									[
										142326,
										142330
									],
									[
										142360,
										142364
									],
									[
										142585,
										142589
									],
									[
										142623,
										142627
									],
									[
										142657,
										142661
									],
									[
										142882,
										142886
									],
									[
										142920,
										142924
									],
									[
										142954,
										142958
									],
									[
										143172,
										143176
									],
									[
										143210,
										143214
									],
									[
										143244,
										143248
									],
									[
										143463,
										143467
									],
									[
										143501,
										143505
									],
									[
										143535,
										143539
									],
									[
										143763,
										143767
									],
									[
										143801,
										143805
									],
									[
										143835,
										143839
									],
									[
										144063,
										144067
									],
									[
										144101,
										144105
									],
									[
										144135,
										144139
									],
									[
										144352,
										144356
									],
									[
										144390,
										144394
									],
									[
										144424,
										144428
									],
									[
										144641,
										144645
									],
									[
										144679,
										144683
									],
									[
										144713,
										144717
									],
									[
										144940,
										144944
									],
									[
										144978,
										144982
									],
									[
										145012,
										145016
									],
									[
										145239,
										145243
									],
									[
										145277,
										145281
									],
									[
										145311,
										145315
									],
									[
										145532,
										145536
									],
									[
										145570,
										145574
									],
									[
										145604,
										145608
									],
									[
										145822,
										145826
									],
									[
										145860,
										145864
									],
									[
										145894,
										145898
									],
									[
										146114,
										146118
									],
									[
										146152,
										146156
									],
									[
										146186,
										146190
									],
									[
										146408,
										146412
									],
									[
										146446,
										146450
									],
									[
										146480,
										146484
									],
									[
										146700,
										146704
									],
									[
										146738,
										146742
									],
									[
										146772,
										146776
									],
									[
										146993,
										146997
									],
									[
										147031,
										147035
									],
									[
										147065,
										147069
									],
									[
										147282,
										147286
									],
									[
										147320,
										147324
									],
									[
										147354,
										147358
									],
									[
										147571,
										147575
									],
									[
										147609,
										147613
									],
									[
										147643,
										147647
									],
									[
										147860,
										147864
									],
									[
										147898,
										147902
									],
									[
										147932,
										147936
									],
									[
										148149,
										148153
									],
									[
										148187,
										148191
									],
									[
										148221,
										148225
									],
									[
										148438,
										148442
									],
									[
										148476,
										148480
									],
									[
										148510,
										148514
									],
									[
										148727,
										148731
									],
									[
										148765,
										148769
									],
									[
										148799,
										148803
									],
									[
										149016,
										149020
									],
									[
										149054,
										149058
									],
									[
										149088,
										149092
									],
									[
										149305,
										149309
									],
									[
										149343,
										149347
									],
									[
										149377,
										149381
									],
									[
										149602,
										149606
									],
									[
										149640,
										149644
									],
									[
										149674,
										149678
									],
									[
										149900,
										149904
									],
									[
										149938,
										149942
									],
									[
										149972,
										149976
									],
									[
										150196,
										150200
									],
									[
										150234,
										150238
									],
									[
										150268,
										150272
									],
									[
										150493,
										150497
									],
									[
										150531,
										150535
									],
									[
										150565,
										150569
									],
									[
										150782,
										150786
									],
									[
										150820,
										150824
									],
									[
										150854,
										150858
									],
									[
										151071,
										151075
									],
									[
										151109,
										151113
									],
									[
										151143,
										151147
									],
									[
										151360,
										151364
									],
									[
										151398,
										151402
									],
									[
										151432,
										151436
									],
									[
										151649,
										151653
									],
									[
										151687,
										151691
									],
									[
										151721,
										151725
									],
									[
										151974,
										151978
									],
									[
										152012,
										152016
									],
									[
										152046,
										152050
									],
									[
										152273,
										152277
									],
									[
										152311,
										152315
									],
									[
										152345,
										152349
									],
									[
										152561,
										152565
									],
									[
										152599,
										152603
									],
									[
										152633,
										152637
									],
									[
										152847,
										152851
									],
									[
										152885,
										152889
									],
									[
										152919,
										152923
									],
									[
										153134,
										153138
									],
									[
										153172,
										153176
									],
									[
										153206,
										153210
									],
									[
										153458,
										153462
									],
									[
										153496,
										153500
									],
									[
										153530,
										153534
									],
									[
										153782,
										153786
									],
									[
										153820,
										153824
									],
									[
										153854,
										153858
									],
									[
										154106,
										154110
									],
									[
										154144,
										154148
									],
									[
										154178,
										154182
									],
									[
										154430,
										154434
									],
									[
										154468,
										154472
									],
									[
										154502,
										154506
									],
									[
										154718,
										154722
									],
									[
										154756,
										154760
									],
									[
										154790,
										154794
									],
									[
										155006,
										155010
									],
									[
										155044,
										155048
									],
									[
										155078,
										155082
									],
									[
										155311,
										155315
									],
									[
										155349,
										155353
									],
									[
										155383,
										155387
									],
									[
										155635,
										155639
									],
									[
										155673,
										155677
									],
									[
										155707,
										155711
									],
									[
										155918,
										155922
									],
									[
										155956,
										155960
									],
									[
										155990,
										155994
									],
									[
										156232,
										156236
									],
									[
										156270,
										156274
									],
									[
										156304,
										156308
									],
									[
										156556,
										156560
									],
									[
										156594,
										156598
									],
									[
										156628,
										156632
									],
									[
										156857,
										156861
									],
									[
										156895,
										156899
									],
									[
										156929,
										156933
									],
									[
										157129,
										157133
									],
									[
										157167,
										157171
									],
									[
										157201,
										157205
									],
									[
										157414,
										157418
									],
									[
										157452,
										157456
									],
									[
										157486,
										157490
									],
									[
										157700,
										157704
									],
									[
										157738,
										157742
									],
									[
										157772,
										157776
									],
									[
										157986,
										157990
									],
									[
										158024,
										158028
									],
									[
										158058,
										158062
									],
									[
										158275,
										158279
									],
									[
										158313,
										158317
									],
									[
										158347,
										158351
									],
									[
										158583,
										158587
									],
									[
										158621,
										158625
									],
									[
										158655,
										158659
									],
									[
										158877,
										158881
									],
									[
										158915,
										158919
									],
									[
										158949,
										158953
									],
									[
										159165,
										159169
									],
									[
										159203,
										159207
									],
									[
										159237,
										159241
									],
									[
										159449,
										159453
									],
									[
										159487,
										159491
									],
									[
										159521,
										159525
									],
									[
										159765,
										159769
									],
									[
										159803,
										159807
									],
									[
										159837,
										159841
									],
									[
										160056,
										160060
									],
									[
										160094,
										160098
									],
									[
										160128,
										160132
									],
									[
										160278,
										160282
									],
									[
										160425,
										160429
									],
									[
										160671,
										160675
									],
									[
										160709,
										160713
									],
									[
										160743,
										160747
									],
									[
										160957,
										160961
									],
									[
										160994,
										160998
									],
									[
										161027,
										161031
									],
									[
										161247,
										161251
									],
									[
										161285,
										161289
									],
									[
										161319,
										161323
									],
									[
										161537,
										161541
									],
									[
										161575,
										161579
									],
									[
										161609,
										161613
									],
									[
										161863,
										161867
									],
									[
										161936,
										161940
									],
									[
										162167,
										162171
									],
									[
										162534,
										162538
									],
									[
										162540,
										162544
									],
									[
										162782,
										162786
									],
									[
										162788,
										162792
									],
									[
										163140,
										163144
									],
									[
										163178,
										163182
									],
									[
										163211,
										163215
									],
									[
										163431,
										163435
									],
									[
										163469,
										163473
									],
									[
										163503,
										163507
									],
									[
										163652,
										163656
									],
									[
										163690,
										163694
									],
									[
										163724,
										163728
									],
									[
										163875,
										163879
									],
									[
										163913,
										163917
									],
									[
										163947,
										163951
									],
									[
										164127,
										164131
									],
									[
										164165,
										164169
									],
									[
										164199,
										164203
									],
									[
										164396,
										164400
									],
									[
										164434,
										164438
									],
									[
										164468,
										164472
									],
									[
										164648,
										164652
									],
									[
										164686,
										164690
									],
									[
										164720,
										164724
									],
									[
										164900,
										164904
									],
									[
										164938,
										164942
									],
									[
										164972,
										164976
									],
									[
										165245,
										165249
									],
									[
										165283,
										165287
									],
									[
										165317,
										165321
									],
									[
										165590,
										165594
									],
									[
										165628,
										165632
									],
									[
										165662,
										165666
									],
									[
										165912,
										165916
									],
									[
										165950,
										165954
									],
									[
										165984,
										165988
									],
									[
										166221,
										166225
									],
									[
										166259,
										166263
									],
									[
										166293,
										166297
									],
									[
										166500,
										166504
									],
									[
										166538,
										166542
									],
									[
										166572,
										166576
									],
									[
										166776,
										166780
									],
									[
										166814,
										166818
									],
									[
										166848,
										166852
									],
									[
										167059,
										167063
									],
									[
										167097,
										167101
									],
									[
										167131,
										167135
									],
									[
										167351,
										167355
									],
									[
										167389,
										167393
									],
									[
										167423,
										167427
									],
									[
										167663,
										167667
									],
									[
										167701,
										167705
									],
									[
										167735,
										167739
									],
									[
										167956,
										167960
									],
									[
										167994,
										167998
									],
									[
										168028,
										168032
									],
									[
										168245,
										168249
									],
									[
										168283,
										168287
									],
									[
										168317,
										168321
									],
									[
										168533,
										168537
									],
									[
										168571,
										168575
									],
									[
										168605,
										168609
									],
									[
										168821,
										168825
									],
									[
										168859,
										168863
									],
									[
										168893,
										168897
									],
									[
										169105,
										169109
									],
									[
										169143,
										169147
									],
									[
										169177,
										169181
									],
									[
										169390,
										169394
									],
									[
										169428,
										169432
									],
									[
										169462,
										169466
									],
									[
										169673,
										169677
									],
									[
										169711,
										169715
									],
									[
										169745,
										169749
									],
									[
										169957,
										169961
									],
									[
										169995,
										169999
									],
									[
										170029,
										170033
									],
									[
										170247,
										170251
									],
									[
										170285,
										170289
									],
									[
										170319,
										170323
									],
									[
										170537,
										170541
									],
									[
										170575,
										170579
									],
									[
										170609,
										170613
									],
									[
										170809,
										170813
									],
									[
										170847,
										170851
									],
									[
										170881,
										170885
									],
									[
										171120,
										171124
									],
									[
										171158,
										171162
									],
									[
										171192,
										171196
									],
									[
										171449,
										171453
									],
									[
										171605,
										171609
									],
									[
										171923,
										171927
									],
									[
										171929,
										171933
									],
									[
										172171,
										172175
									],
									[
										172177,
										172181
									],
									[
										172560,
										172564
									],
									[
										172598,
										172602
									],
									[
										172631,
										172635
									],
									[
										172887,
										172891
									],
									[
										172925,
										172929
									],
									[
										172958,
										172962
									],
									[
										173195,
										173199
									],
									[
										173233,
										173237
									],
									[
										173266,
										173270
									],
									[
										173497,
										173501
									],
									[
										173535,
										173539
									],
									[
										173568,
										173572
									],
									[
										173817,
										173821
									],
									[
										173855,
										173859
									],
									[
										173888,
										173892
									],
									[
										174150,
										174154
									],
									[
										174188,
										174192
									],
									[
										174221,
										174225
									],
									[
										174462,
										174466
									],
									[
										174500,
										174504
									],
									[
										174533,
										174537
									],
									[
										174781,
										174785
									],
									[
										174819,
										174823
									],
									[
										174852,
										174856
									],
									[
										175087,
										175091
									],
									[
										175125,
										175129
									],
									[
										175158,
										175162
									],
									[
										175406,
										175410
									],
									[
										175444,
										175448
									],
									[
										175477,
										175481
									],
									[
										175712,
										175716
									],
									[
										175750,
										175754
									],
									[
										175783,
										175787
									],
									[
										176026,
										176030
									],
									[
										176064,
										176068
									],
									[
										176097,
										176101
									],
									[
										176329,
										176333
									],
									[
										176367,
										176371
									],
									[
										176400,
										176404
									],
									[
										176634,
										176638
									],
									[
										176672,
										176676
									],
									[
										176705,
										176709
									],
									[
										176953,
										176957
									],
									[
										176991,
										176995
									],
									[
										177024,
										177028
									],
									[
										177266,
										177270
									],
									[
										177304,
										177308
									],
									[
										177337,
										177341
									],
									[
										177583,
										177587
									],
									[
										177621,
										177625
									],
									[
										177654,
										177658
									],
									[
										177886,
										177890
									],
									[
										177924,
										177928
									],
									[
										177957,
										177961
									],
									[
										178203,
										178207
									],
									[
										178241,
										178245
									],
									[
										178274,
										178278
									],
									[
										178506,
										178510
									],
									[
										178544,
										178548
									],
									[
										178577,
										178581
									],
									[
										178822,
										178826
									],
									[
										178860,
										178864
									],
									[
										178893,
										178897
									],
									[
										179102,
										179106
									],
									[
										179134,
										179138
									],
									[
										179392,
										179396
									],
									[
										179430,
										179434
									],
									[
										179463,
										179467
									],
									[
										179710,
										179714
									],
									[
										179748,
										179752
									],
									[
										179781,
										179785
									],
									[
										180034,
										180038
									],
									[
										180072,
										180076
									],
									[
										180105,
										180109
									],
									[
										180395,
										180399
									],
									[
										180647,
										180651
									],
									[
										181003,
										181007
									],
									[
										181009,
										181013
									],
									[
										181225,
										181229
									],
									[
										181231,
										181235
									],
									[
										181497,
										181501
									],
									[
										181738,
										181742
									],
									[
										181747,
										181751
									],
									[
										181933,
										181937
									],
									[
										181942,
										181946
									],
									[
										181948,
										181952
									],
									[
										182159,
										182163
									],
									[
										182168,
										182172
									],
									[
										182174,
										182178
									],
									[
										182366,
										182370
									],
									[
										182375,
										182379
									],
									[
										182381,
										182385
									],
									[
										182556,
										182560
									],
									[
										182562,
										182566
									],
									[
										182857,
										182861
									],
									[
										182866,
										182870
									],
									[
										183100,
										183104
									],
									[
										183300,
										183304
									],
									[
										183516,
										183520
									],
									[
										183525,
										183529
									],
									[
										183531,
										183535
									],
									[
										183741,
										183745
									],
									[
										183772,
										183776
									],
									[
										184077,
										184081
									],
									[
										184312,
										184316
									],
									[
										184424,
										184428
									],
									[
										184647,
										184651
									],
									[
										184718,
										184722
									],
									[
										185334,
										185338
									],
									[
										185419,
										185423
									],
									[
										185474,
										185478
									],
									[
										185690,
										185694
									],
									[
										185736,
										185740
									],
									[
										185911,
										185915
									],
									[
										185975,
										185979
									],
									[
										186299,
										186303
									],
									[
										186484,
										186488
									],
									[
										186672,
										186676
									],
									[
										186839,
										186843
									],
									[
										187007,
										187011
									],
									[
										187194,
										187198
									],
									[
										187316,
										187320
									],
									[
										187480,
										187484
									],
									[
										187702,
										187706
									],
									[
										187830,
										187834
									],
									[
										188027,
										188031
									],
									[
										188047,
										188051
									],
									[
										188265,
										188269
									],
									[
										188403,
										188407
									],
									[
										188527,
										188531
									],
									[
										188701,
										188705
									],
									[
										188809,
										188813
									],
									[
										189024,
										189028
									],
									[
										189081,
										189085
									],
									[
										189250,
										189254
									],
									[
										189409,
										189413
									],
									[
										189575,
										189579
									],
									[
										189784,
										189788
									],
									[
										189980,
										189984
									],
									[
										190165,
										190169
									],
									[
										190269,
										190273
									],
									[
										190450,
										190454
									],
									[
										190606,
										190610
									],
									[
										190772,
										190776
									],
									[
										191025,
										191029
									],
									[
										191332,
										191336
									],
									[
										191534,
										191538
									],
									[
										191738,
										191742
									],
									[
										191937,
										191941
									],
									[
										192273,
										192277
									],
									[
										192615,
										192619
									],
									[
										192787,
										192791
									],
									[
										192961,
										192965
									],
									[
										193191,
										193195
									],
									[
										193382,
										193386
									],
									[
										193702,
										193706
									],
									[
										194029,
										194033
									],
									[
										194363,
										194367
									],
									[
										194683,
										194687
									],
									[
										195002,
										195006
									],
									[
										195008,
										195012
									],
									[
										195213,
										195217
									],
									[
										195219,
										195223
									],
									[
										195534,
										195538
									],
									[
										195540,
										195544
									],
									[
										195802,
										195806
									],
									[
										195966,
										195970
									],
									[
										196156,
										196160
									],
									[
										196325,
										196329
									],
									[
										196495,
										196499
									],
									[
										196665,
										196669
									],
									[
										196839,
										196843
									],
									[
										197043,
										197047
									],
									[
										197226,
										197230
									],
									[
										197464,
										197468
									],
									[
										197714,
										197718
									],
									[
										197986,
										197990
									],
									[
										198196,
										198200
									],
									[
										198217,
										198221
									],
									[
										198240,
										198244
									],
									[
										198505,
										198509
									],
									[
										198541,
										198545
									],
									[
										198742,
										198746
									],
									[
										198900,
										198904
									],
									[
										199149,
										199153
									],
									[
										199389,
										199393
									],
									[
										199415,
										199419
									],
									[
										199437,
										199441
									],
									[
										199665,
										199669
									],
									[
										199721,
										199725
									],
									[
										199848,
										199852
									],
									[
										199868,
										199872
									],
									[
										200050,
										200054
									],
									[
										200233,
										200237
									],
									[
										200445,
										200449
									],
									[
										200504,
										200508
									],
									[
										200579,
										200583
									],
									[
										200599,
										200603
									],
									[
										200783,
										200787
									],
									[
										200987,
										200991
									],
									[
										201119,
										201123
									],
									[
										201139,
										201143
									],
									[
										201320,
										201324
									],
									[
										201502,
										201506
									],
									[
										201714,
										201718
									],
									[
										201773,
										201777
									],
									[
										201978,
										201982
									],
									[
										202004,
										202008
									],
									[
										202026,
										202030
									],
									[
										202122,
										202126
									],
									[
										202353,
										202357
									],
									[
										202563,
										202567
									],
									[
										202867,
										202871
									],
									[
										203098,
										203102
									],
									[
										203334,
										203338
									],
									[
										203480,
										203484
									],
									[
										203620,
										203624
									],
									[
										203771,
										203775
									],
									[
										203795,
										203799
									],
									[
										204135,
										204139
									],
									[
										204294,
										204298
									],
									[
										204317,
										204321
									],
									[
										204437,
										204441
									],
									[
										204669,
										204673
									],
									[
										205129,
										205133
									],
									[
										205319,
										205323
									],
									[
										205731,
										205735
									],
									[
										206051,
										206055
									],
									[
										206217,
										206221
									],
									[
										206384,
										206388
									],
									[
										206676,
										206680
									],
									[
										206850,
										206854
									],
									[
										207016,
										207020
									],
									[
										207308,
										207312
									],
									[
										207336,
										207340
									],
									[
										207439,
										207443
									],
									[
										207466,
										207470
									],
									[
										207715,
										207719
									],
									[
										207855,
										207859
									],
									[
										208056,
										208060
									],
									[
										208215,
										208219
									],
									[
										208379,
										208383
									],
									[
										208497,
										208501
									],
									[
										208521,
										208525
									],
									[
										208778,
										208782
									],
									[
										208951,
										208955
									],
									[
										209127,
										209131
									],
									[
										209340,
										209344
									],
									[
										209359,
										209363
									],
									[
										209388,
										209392
									],
									[
										209620,
										209624
									],
									[
										209802,
										209806
									],
									[
										209977,
										209981
									],
									[
										210173,
										210177
									],
									[
										210348,
										210352
									],
									[
										210545,
										210549
									],
									[
										210721,
										210725
									],
									[
										210858,
										210862
									],
									[
										210896,
										210900
									],
									[
										210977,
										210981
									],
									[
										211016,
										211020
									],
									[
										211099,
										211103
									],
									[
										211137,
										211141
									],
									[
										211216,
										211220
									],
									[
										211253,
										211257
									],
									[
										211343,
										211347
									],
									[
										211392,
										211396
									],
									[
										211507,
										211511
									],
									[
										211548,
										211552
									],
									[
										211903,
										211907
									],
									[
										211932,
										211936
									],
									[
										212237,
										212241
									],
									[
										212444,
										212448
									],
									[
										212473,
										212477
									],
									[
										212805,
										212809
									],
									[
										212991,
										212995
									],
									[
										213207,
										213211
									],
									[
										213242,
										213246
									],
									[
										213376,
										213380
									],
									[
										213627,
										213631
									],
									[
										213744,
										213748
									],
									[
										213901,
										213905
									],
									[
										214213,
										214217
									],
									[
										214496,
										214500
									],
									[
										214656,
										214660
									],
									[
										214964,
										214968
									],
									[
										215154,
										215158
									],
									[
										215354,
										215358
									],
									[
										215584,
										215588
									],
									[
										215832,
										215836
									],
									[
										216048,
										216052
									],
									[
										216333,
										216337
									],
									[
										216447,
										216451
									],
									[
										216587,
										216591
									],
									[
										216711,
										216715
									],
									[
										216814,
										216818
									],
									[
										217195,
										217199
									],
									[
										217423,
										217427
									],
									[
										217520,
										217524
									],
									[
										217687,
										217691
									],
									[
										217984,
										217988
									],
									[
										218030,
										218034
									],
									[
										218348,
										218352
									],
									[
										218784,
										218788
									],
									[
										218944,
										218948
									],
									[
										219058,
										219062
									],
									[
										219180,
										219184
									],
									[
										219561,
										219565
									],
									[
										219789,
										219793
									],
									[
										219886,
										219890
									],
									[
										220053,
										220057
									],
									[
										220350,
										220354
									],
									[
										220396,
										220400
									],
									[
										220742,
										220746
									],
									[
										221040,
										221044
									],
									[
										221256,
										221260
									],
									[
										221566,
										221570
									],
									[
										221863,
										221867
									],
									[
										222009,
										222013
									],
									[
										222259,
										222263
									],
									[
										222375,
										222379
									],
									[
										222654,
										222658
									],
									[
										222802,
										222806
									],
									[
										223066,
										223070
									],
									[
										223301,
										223305
									],
									[
										223678,
										223682
									],
									[
										223832,
										223836
									],
									[
										224091,
										224095
									],
									[
										224245,
										224249
									],
									[
										224536,
										224540
									],
									[
										224666,
										224670
									],
									[
										224927,
										224931
									],
									[
										225303,
										225307
									],
									[
										225477,
										225481
									],
									[
										225742,
										225746
									],
									[
										225883,
										225887
									],
									[
										226124,
										226128
									],
									[
										226234,
										226238
									],
									[
										226376,
										226380
									],
									[
										226486,
										226490
									],
									[
										226809,
										226813
									],
									[
										227033,
										227037
									],
									[
										227272,
										227276
									],
									[
										227578,
										227582
									],
									[
										227823,
										227827
									],
									[
										228127,
										228131
									],
									[
										228268,
										228272
									],
									[
										228650,
										228654
									],
									[
										228814,
										228818
									],
									[
										229171,
										229175
									],
									[
										229216,
										229220
									],
									[
										229448,
										229452
									],
									[
										229620,
										229624
									],
									[
										229928,
										229932
									],
									[
										230076,
										230080
									],
									[
										230121,
										230125
									],
									[
										230352,
										230356
									],
									[
										230553,
										230557
									],
									[
										230861,
										230865
									],
									[
										231011,
										231015
									],
									[
										231056,
										231060
									],
									[
										231287,
										231291
									],
									[
										231517,
										231521
									],
									[
										231850,
										231854
									],
									[
										231944,
										231948
									],
									[
										231982,
										231986
									],
									[
										232155,
										232159
									],
									[
										232340,
										232344
									],
									[
										232465,
										232469
									],
									[
										232649,
										232653
									],
									[
										232891,
										232895
									],
									[
										233153,
										233157
									],
									[
										233413,
										233417
									],
									[
										233544,
										233548
									],
									[
										233702,
										233706
									],
									[
										234035,
										234039
									],
									[
										234282,
										234286
									],
									[
										234544,
										234548
									],
									[
										234740,
										234744
									],
									[
										234956,
										234960
									],
									[
										235077,
										235081
									],
									[
										235270,
										235274
									],
									[
										235341,
										235345
									],
									[
										235563,
										235567
									],
									[
										235600,
										235604
									],
									[
										235738,
										235742
									],
									[
										235933,
										235937
									],
									[
										236181,
										236185
									],
									[
										236379,
										236383
									],
									[
										236618,
										236622
									],
									[
										236839,
										236843
									],
									[
										237032,
										237036
									],
									[
										237273,
										237277
									],
									[
										237543,
										237547
									],
									[
										237777,
										237781
									],
									[
										238036,
										238040
									],
									[
										238272,
										238276
									],
									[
										238306,
										238310
									],
									[
										238553,
										238557
									],
									[
										238825,
										238829
									],
									[
										238998,
										239002
									],
									[
										239173,
										239177
									],
									[
										239475,
										239479
									],
									[
										239647,
										239651
									],
									[
										239887,
										239891
									],
									[
										240094,
										240098
									],
									[
										240321,
										240325
									],
									[
										240562,
										240566
									],
									[
										240706,
										240710
									],
									[
										240744,
										240748
									],
									[
										240901,
										240905
									],
									[
										241173,
										241177
									],
									[
										241423,
										241427
									],
									[
										241540,
										241544
									],
									[
										241580,
										241584
									],
									[
										241752,
										241756
									],
									[
										242000,
										242004
									],
									[
										242150,
										242154
									],
									[
										242195,
										242199
									],
									[
										242425,
										242429
									],
									[
										242655,
										242659
									],
									[
										242992,
										242996
									],
									[
										243078,
										243082
									],
									[
										243116,
										243120
									],
									[
										243289,
										243293
									],
									[
										243474,
										243478
									],
									[
										243599,
										243603
									],
									[
										243790,
										243794
									],
									[
										244032,
										244036
									],
									[
										244294,
										244298
									],
									[
										244554,
										244558
									],
									[
										244685,
										244689
									],
									[
										244843,
										244847
									],
									[
										245100,
										245104
									],
									[
										245332,
										245336
									],
									[
										245513,
										245517
									],
									[
										245558,
										245562
									],
									[
										245790,
										245794
									],
									[
										245986,
										245990
									],
									[
										246346,
										246350
									],
									[
										246467,
										246471
									],
									[
										246505,
										246509
									],
									[
										246678,
										246682
									],
									[
										246863,
										246867
									],
									[
										246988,
										246992
									],
									[
										247172,
										247176
									],
									[
										247414,
										247418
									],
									[
										247670,
										247674
									],
									[
										247848,
										247852
									],
									[
										248060,
										248064
									],
									[
										248191,
										248195
									],
									[
										248419,
										248423
									],
									[
										248630,
										248634
									],
									[
										248798,
										248802
									],
									[
										248850,
										248854
									],
									[
										249053,
										249057
									],
									[
										249132,
										249136
									],
									[
										249191,
										249195
									],
									[
										249537,
										249541
									],
									[
										249671,
										249675
									],
									[
										249799,
										249803
									],
									[
										249805,
										249809
									],
									[
										249969,
										249973
									],
									[
										249975,
										249979
									],
									[
										250151,
										250155
									],
									[
										250157,
										250161
									],
									[
										250300,
										250304
									],
									[
										250306,
										250310
									],
									[
										250429,
										250433
									],
									[
										250435,
										250439
									],
									[
										250617,
										250621
									],
									[
										250790,
										250794
									],
									[
										250967,
										250971
									],
									[
										251185,
										251189
									],
									[
										251287,
										251291
									],
									[
										251520,
										251524
									],
									[
										251614,
										251618
									],
									[
										251982,
										251986
									],
									[
										252303,
										252307
									],
									[
										252568,
										252572
									],
									[
										252768,
										252772
									],
									[
										253193,
										253197
									],
									[
										253414,
										253418
									],
									[
										253473,
										253477
									],
									[
										253653,
										253657
									],
									[
										253679,
										253683
									],
									[
										253941,
										253945
									],
									[
										254049,
										254053
									],
									[
										254249,
										254253
									],
									[
										254557,
										254561
									],
									[
										254656,
										254660
									],
									[
										254942,
										254946
									],
									[
										255104,
										255108
									],
									[
										255368,
										255372
									],
									[
										255617,
										255621
									],
									[
										255716,
										255720
									],
									[
										255901,
										255905
									],
									[
										255959,
										255963
									],
									[
										256064,
										256068
									],
									[
										256329,
										256333
									],
									[
										256385,
										256389
									],
									[
										256597,
										256601
									],
									[
										256698,
										256702
									],
									[
										256934,
										256938
									],
									[
										256992,
										256996
									],
									[
										257209,
										257213
									],
									[
										257569,
										257573
									],
									[
										257800,
										257804
									],
									[
										257859,
										257863
									],
									[
										258136,
										258140
									],
									[
										258463,
										258467
									],
									[
										258844,
										258848
									],
									[
										258913,
										258917
									],
									[
										259194,
										259198
									],
									[
										259258,
										259262
									],
									[
										259588,
										259592
									],
									[
										259864,
										259868
									],
									[
										260102,
										260106
									],
									[
										260391,
										260395
									],
									[
										260696,
										260700
									],
									[
										261025,
										261029
									],
									[
										261242,
										261246
									],
									[
										261527,
										261531
									],
									[
										261745,
										261749
									],
									[
										261962,
										261966
									],
									[
										262167,
										262171
									],
									[
										262344,
										262348
									],
									[
										262530,
										262534
									],
									[
										262705,
										262709
									],
									[
										262961,
										262965
									],
									[
										263182,
										263186
									],
									[
										263398,
										263402
									],
									[
										263449,
										263453
									],
									[
										263604,
										263608
									],
									[
										263869,
										263873
									],
									[
										264107,
										264111
									],
									[
										264133,
										264137
									],
									[
										264155,
										264159
									],
									[
										264343,
										264347
									],
									[
										264541,
										264545
									],
									[
										264779,
										264783
									],
									[
										264917,
										264921
									],
									[
										265073,
										265077
									],
									[
										265267,
										265271
									],
									[
										265601,
										265605
									],
									[
										265900,
										265904
									],
									[
										266027,
										266031
									],
									[
										266452,
										266456
									],
									[
										266612,
										266616
									],
									[
										266739,
										266743
									],
									[
										267150,
										267154
									],
									[
										267439,
										267443
									],
									[
										267645,
										267649
									],
									[
										267666,
										267670
									],
									[
										267846,
										267850
									],
									[
										268224,
										268228
									],
									[
										268323,
										268327
									],
									[
										268606,
										268610
									],
									[
										268766,
										268770
									],
									[
										269027,
										269031
									],
									[
										269276,
										269280
									],
									[
										269375,
										269379
									],
									[
										269544,
										269548
									],
									[
										269601,
										269605
									],
									[
										269704,
										269708
									],
									[
										269944,
										269948
									],
									[
										270140,
										270144
									],
									[
										270379,
										270383
									],
									[
										270570,
										270574
									],
									[
										270890,
										270894
									],
									[
										271217,
										271221
									],
									[
										271551,
										271555
									],
									[
										271871,
										271875
									],
									[
										272271,
										272275
									],
									[
										272475,
										272479
									],
									[
										272652,
										272656
									],
									[
										272842,
										272846
									],
									[
										273019,
										273023
									],
									[
										273212,
										273216
									],
									[
										273431,
										273435
									],
									[
										273593,
										273597
									],
									[
										273783,
										273787
									],
									[
										274013,
										274017
									],
									[
										274315,
										274319
									],
									[
										274483,
										274487
									],
									[
										274684,
										274688
									],
									[
										274829,
										274833
									],
									[
										274999,
										275003
									],
									[
										275024,
										275028
									],
									[
										275247,
										275251
									],
									[
										275272,
										275276
									],
									[
										275495,
										275499
									],
									[
										275520,
										275524
									],
									[
										275574,
										275578
									],
									[
										275804,
										275808
									],
									[
										275988,
										275992
									],
									[
										276262,
										276266
									],
									[
										276438,
										276442
									],
									[
										276611,
										276615
									],
									[
										276877,
										276881
									],
									[
										277119,
										277123
									],
									[
										277145,
										277149
									],
									[
										277167,
										277171
									],
									[
										277342,
										277346
									],
									[
										277364,
										277368
									],
									[
										277388,
										277392
									],
									[
										277594,
										277598
									],
									[
										277782,
										277786
									],
									[
										277954,
										277958
									],
									[
										278142,
										278146
									],
									[
										278298,
										278302
									],
									[
										278518,
										278522
									],
									[
										278790,
										278794
									],
									[
										279055,
										279059
									],
									[
										279081,
										279085
									],
									[
										279103,
										279107
									],
									[
										279191,
										279195
									],
									[
										279234,
										279238
									],
									[
										279622,
										279626
									],
									[
										279983,
										279987
									],
									[
										280438,
										280442
									],
									[
										280627,
										280631
									],
									[
										280821,
										280825
									],
									[
										281014,
										281018
									],
									[
										281038,
										281042
									],
									[
										281290,
										281294
									],
									[
										281313,
										281317
									],
									[
										281419,
										281423
									],
									[
										281562,
										281566
									],
									[
										281889,
										281893
									],
									[
										282154,
										282158
									],
									[
										282393,
										282397
									],
									[
										282725,
										282729
									],
									[
										282747,
										282751
									],
									[
										282987,
										282991
									],
									[
										283115,
										283119
									],
									[
										283304,
										283308
									],
									[
										283612,
										283616
									],
									[
										283711,
										283715
									],
									[
										283997,
										284001
									],
									[
										284159,
										284163
									],
									[
										284423,
										284427
									],
									[
										284672,
										284676
									],
									[
										284771,
										284775
									],
									[
										284956,
										284960
									],
									[
										285014,
										285018
									],
									[
										285119,
										285123
									],
									[
										285352,
										285356
									],
									[
										285548,
										285552
									],
									[
										285787,
										285791
									],
									[
										285978,
										285982
									],
									[
										286298,
										286302
									],
									[
										286625,
										286629
									],
									[
										286959,
										286963
									],
									[
										287279,
										287283
									],
									[
										287679,
										287683
									],
									[
										287883,
										287887
									],
									[
										288060,
										288064
									],
									[
										288250,
										288254
									],
									[
										288427,
										288431
									],
									[
										288620,
										288624
									],
									[
										288839,
										288843
									],
									[
										289001,
										289005
									],
									[
										289191,
										289195
									],
									[
										289421,
										289425
									],
									[
										289723,
										289727
									],
									[
										289891,
										289895
									],
									[
										290092,
										290096
									],
									[
										290237,
										290241
									],
									[
										290407,
										290411
									],
									[
										290432,
										290436
									],
									[
										290655,
										290659
									],
									[
										290680,
										290684
									],
									[
										290903,
										290907
									],
									[
										290928,
										290932
									],
									[
										290982,
										290986
									],
									[
										291212,
										291216
									],
									[
										291396,
										291400
									],
									[
										291670,
										291674
									],
									[
										291846,
										291850
									],
									[
										292019,
										292023
									],
									[
										292285,
										292289
									],
									[
										292527,
										292531
									],
									[
										292553,
										292557
									],
									[
										292575,
										292579
									],
									[
										292750,
										292754
									],
									[
										292772,
										292776
									],
									[
										292796,
										292800
									],
									[
										293002,
										293006
									],
									[
										293190,
										293194
									],
									[
										293362,
										293366
									],
									[
										293550,
										293554
									],
									[
										293706,
										293710
									],
									[
										293926,
										293930
									],
									[
										294198,
										294202
									],
									[
										294463,
										294467
									],
									[
										294489,
										294493
									],
									[
										294511,
										294515
									],
									[
										294599,
										294603
									],
									[
										294642,
										294646
									],
									[
										295026,
										295030
									],
									[
										295387,
										295391
									],
									[
										295842,
										295846
									],
									[
										296031,
										296035
									],
									[
										296225,
										296229
									],
									[
										296418,
										296422
									],
									[
										296442,
										296446
									],
									[
										296694,
										296698
									],
									[
										296717,
										296721
									],
									[
										296823,
										296827
									],
									[
										296966,
										296970
									],
									[
										297293,
										297297
									],
									[
										297558,
										297562
									],
									[
										297797,
										297801
									],
									[
										298041,
										298045
									],
									[
										298349,
										298353
									],
									[
										298448,
										298452
									],
									[
										298734,
										298738
									],
									[
										298896,
										298900
									],
									[
										299160,
										299164
									],
									[
										299409,
										299413
									],
									[
										299508,
										299512
									],
									[
										299693,
										299697
									],
									[
										299751,
										299755
									],
									[
										299856,
										299860
									],
									[
										300040,
										300044
									],
									[
										300148,
										300152
									],
									[
										300193,
										300197
									],
									[
										300340,
										300344
									],
									[
										300513,
										300517
									],
									[
										300628,
										300632
									],
									[
										300743,
										300747
									],
									[
										300858,
										300862
									],
									[
										301002,
										301006
									],
									[
										301119,
										301123
									],
									[
										301236,
										301240
									],
									[
										301353,
										301357
									],
									[
										301426,
										301430
									],
									[
										301539,
										301543
									],
									[
										301618,
										301622
									],
									[
										301642,
										301646
									],
									[
										301702,
										301706
									],
									[
										302033,
										302037
									],
									[
										302353,
										302357
									],
									[
										302611,
										302615
									],
									[
										302803,
										302807
									],
									[
										302982,
										302986
									],
									[
										303299,
										303303
									],
									[
										303367,
										303371
									],
									[
										303438,
										303442
									],
									[
										303967,
										303971
									],
									[
										304073,
										304077
									],
									[
										304405,
										304409
									],
									[
										304713,
										304717
									],
									[
										304812,
										304816
									],
									[
										305098,
										305102
									],
									[
										305260,
										305264
									],
									[
										305524,
										305528
									],
									[
										305773,
										305777
									],
									[
										305872,
										305876
									],
									[
										306057,
										306061
									],
									[
										306115,
										306119
									],
									[
										306220,
										306224
									],
									[
										306522,
										306526
									],
									[
										306563,
										306567
									],
									[
										306580,
										306584
									],
									[
										306711,
										306715
									],
									[
										306842,
										306846
									],
									[
										307012,
										307016
									],
									[
										307284,
										307288
									],
									[
										307531,
										307535
									],
									[
										308054,
										308058
									],
									[
										308509,
										308513
									],
									[
										308641,
										308645
									],
									[
										308838,
										308842
									],
									[
										309407,
										309411
									],
									[
										309862,
										309866
									],
									[
										309994,
										309998
									],
									[
										310191,
										310195
									],
									[
										310532,
										310536
									],
									[
										310801,
										310805
									],
									[
										311290,
										311294
									],
									[
										311689,
										311693
									],
									[
										311942,
										311946
									],
									[
										312135,
										312139
									],
									[
										312443,
										312447
									],
									[
										312542,
										312546
									],
									[
										312828,
										312832
									],
									[
										312990,
										312994
									],
									[
										313254,
										313258
									],
									[
										313503,
										313507
									],
									[
										313602,
										313606
									],
									[
										313787,
										313791
									],
									[
										313845,
										313849
									],
									[
										313950,
										313954
									],
									[
										314279,
										314283
									],
									[
										314548,
										314552
									],
									[
										314892,
										314896
									],
									[
										315034,
										315038
									],
									[
										315404,
										315408
									],
									[
										315736,
										315740
									],
									[
										316211,
										316215
									],
									[
										316623,
										316627
									],
									[
										316764,
										316768
									],
									[
										317128,
										317132
									],
									[
										317460,
										317464
									],
									[
										317853,
										317857
									],
									[
										318252,
										318256
									],
									[
										318522,
										318526
									],
									[
										318850,
										318854
									],
									[
										318881,
										318885
									],
									[
										318901,
										318905
									],
									[
										319164,
										319168
									],
									[
										319356,
										319360
									],
									[
										319564,
										319568
									],
									[
										319801,
										319805
									],
									[
										320043,
										320047
									],
									[
										320306,
										320310
									],
									[
										320782,
										320786
									],
									[
										320979,
										320983
									],
									[
										321066,
										321070
									],
									[
										321368,
										321372
									],
									[
										321453,
										321457
									],
									[
										321653,
										321657
									],
									[
										321687,
										321691
									],
									[
										321848,
										321852
									],
									[
										322458,
										322462
									],
									[
										323252,
										323256
									],
									[
										324625,
										324629
									],
									[
										324917,
										324921
									],
									[
										325190,
										325194
									],
									[
										325667,
										325671
									],
									[
										325779,
										325783
									],
									[
										326364,
										326368
									],
									[
										326691,
										326695
									],
									[
										327606,
										327610
									],
									[
										327972,
										327976
									],
									[
										328007,
										328011
									],
									[
										328250,
										328254
									],
									[
										328562,
										328566
									],
									[
										328798,
										328802
									],
									[
										328840,
										328844
									],
									[
										329208,
										329212
									],
									[
										329899,
										329903
									],
									[
										329975,
										329979
									],
									[
										330416,
										330420
									],
									[
										330483,
										330487
									],
									[
										330794,
										330798
									],
									[
										330949,
										330953
									],
									[
										331209,
										331213
									],
									[
										331517,
										331521
									],
									[
										332010,
										332014
									],
									[
										332444,
										332448
									],
									[
										332945,
										332949
									],
									[
										333174,
										333178
									],
									[
										333387,
										333391
									],
									[
										333656,
										333660
									],
									[
										334153,
										334157
									],
									[
										334181,
										334185
									],
									[
										335502,
										335506
									],
									[
										335811,
										335815
									],
									[
										335846,
										335850
									],
									[
										336165,
										336169
									],
									[
										336730,
										336734
									],
									[
										337259,
										337263
									],
									[
										337661,
										337665
									],
									[
										337943,
										337947
									],
									[
										338235,
										338239
									],
									[
										338410,
										338414
									],
									[
										338610,
										338614
									],
									[
										338952,
										338956
									],
									[
										339199,
										339203
									],
									[
										339426,
										339430
									],
									[
										339694,
										339698
									],
									[
										339957,
										339961
									],
									[
										340150,
										340154
									],
									[
										340615,
										340619
									],
									[
										341028,
										341032
									],
									[
										341263,
										341267
									],
									[
										341398,
										341402
									],
									[
										341557,
										341561
									],
									[
										341788,
										341792
									],
									[
										341978,
										341982
									],
									[
										342115,
										342119
									],
									[
										342121,
										342125
									],
									[
										342343,
										342347
									],
									[
										342492,
										342496
									],
									[
										342587,
										342591
									],
									[
										342749,
										342753
									],
									[
										342861,
										342865
									],
									[
										343019,
										343023
									],
									[
										343157,
										343161
									],
									[
										343335,
										343339
									],
									[
										343443,
										343447
									],
									[
										343725,
										343729
									],
									[
										343850,
										343854
									],
									[
										344202,
										344206
									],
									[
										344246,
										344250
									],
									[
										344515,
										344519
									],
									[
										344640,
										344644
									],
									[
										345005,
										345009
									],
									[
										345011,
										345015
									],
									[
										345017,
										345021
									],
									[
										345369,
										345373
									],
									[
										345375,
										345379
									],
									[
										345381,
										345385
									],
									[
										345701,
										345705
									],
									[
										345707,
										345711
									],
									[
										345713,
										345717
									],
									[
										345986,
										345990
									],
									[
										345992,
										345996
									],
									[
										345998,
										346002
									],
									[
										346195,
										346199
									],
									[
										346201,
										346205
									],
									[
										346207,
										346211
									],
									[
										346460,
										346464
									],
									[
										346466,
										346470
									],
									[
										346472,
										346476
									],
									[
										346717,
										346721
									],
									[
										346723,
										346727
									],
									[
										346964,
										346968
									],
									[
										347240,
										347244
									],
									[
										347246,
										347250
									],
									[
										347272,
										347276
									],
									[
										347609,
										347613
									],
									[
										347615,
										347619
									],
									[
										347641,
										347645
									],
									[
										347931,
										347935
									],
									[
										348165,
										348169
									],
									[
										348171,
										348175
									],
									[
										348199,
										348203
									],
									[
										348408,
										348412
									],
									[
										348453,
										348457
									],
									[
										348671,
										348675
									],
									[
										348875,
										348879
									],
									[
										348892,
										348896
									],
									[
										349078,
										349082
									],
									[
										349102,
										349106
									],
									[
										349162,
										349166
									],
									[
										349279,
										349283
									],
									[
										349429,
										349433
									],
									[
										349514,
										349518
									],
									[
										349685,
										349689
									],
									[
										349727,
										349731
									],
									[
										349873,
										349877
									],
									[
										350056,
										350060
									],
									[
										350209,
										350213
									],
									[
										350348,
										350352
									],
									[
										350381,
										350385
									],
									[
										350555,
										350559
									],
									[
										350694,
										350698
									],
									[
										350727,
										350731
									],
									[
										350901,
										350905
									],
									[
										351028,
										351032
									],
									[
										351202,
										351206
									],
									[
										351353,
										351357
									],
									[
										351587,
										351591
									],
									[
										351795,
										351799
									],
									[
										352012,
										352016
									],
									[
										352126,
										352130
									],
									[
										352214,
										352218
									],
									[
										352553,
										352557
									],
									[
										352879,
										352883
									],
									[
										353067,
										353071
									],
									[
										353245,
										353249
									],
									[
										353274,
										353278
									],
									[
										353465,
										353469
									],
									[
										353496,
										353500
									],
									[
										353527,
										353531
									],
									[
										353558,
										353562
									],
									[
										353589,
										353593
									],
									[
										353620,
										353624
									],
									[
										353860,
										353864
									],
									[
										353888,
										353892
									],
									[
										354072,
										354076
									],
									[
										354103,
										354107
									],
									[
										354323,
										354327
									],
									[
										354519,
										354523
									],
									[
										354666,
										354670
									],
									[
										354930,
										354934
									],
									[
										355210,
										355214
									],
									[
										355348,
										355352
									],
									[
										355527,
										355531
									],
									[
										355610,
										355614
									],
									[
										355742,
										355746
									],
									[
										355859,
										355863
									],
									[
										355917,
										355921
									],
									[
										355986,
										355990
									],
									[
										356145,
										356149
									],
									[
										356166,
										356170
									],
									[
										356355,
										356359
									],
									[
										356569,
										356573
									],
									[
										356746,
										356750
									],
									[
										356886,
										356890
									],
									[
										357044,
										357048
									],
									[
										357247,
										357251
									],
									[
										357460,
										357464
									],
									[
										357667,
										357671
									],
									[
										357877,
										357881
									],
									[
										358091,
										358095
									],
									[
										358327,
										358331
									],
									[
										358560,
										358564
									],
									[
										358717,
										358721
									],
									[
										358740,
										358744
									],
									[
										358920,
										358924
									],
									[
										359157,
										359161
									],
									[
										359295,
										359299
									],
									[
										359520,
										359524
									],
									[
										359750,
										359754
									],
									[
										360058,
										360062
									],
									[
										360375,
										360379
									],
									[
										360556,
										360560
									],
									[
										360568,
										360572
									],
									[
										360761,
										360765
									],
									[
										360951,
										360955
									],
									[
										361189,
										361193
									],
									[
										361288,
										361292
									],
									[
										361432,
										361436
									],
									[
										361599,
										361603
									],
									[
										361667,
										361671
									],
									[
										361786,
										361790
									],
									[
										361911,
										361915
									],
									[
										362053,
										362057
									],
									[
										362146,
										362150
									],
									[
										362220,
										362224
									],
									[
										362278,
										362282
									],
									[
										362311,
										362315
									],
									[
										362494,
										362498
									],
									[
										362671,
										362675
									],
									[
										362933,
										362937
									],
									[
										363147,
										363151
									],
									[
										363343,
										363347
									],
									[
										363584,
										363588
									],
									[
										363783,
										363787
									],
									[
										363966,
										363970
									],
									[
										364166,
										364170
									],
									[
										364172,
										364176
									],
									[
										364321,
										364325
									],
									[
										364449,
										364453
									],
									[
										364547,
										364551
									],
									[
										364674,
										364678
									],
									[
										364818,
										364822
									],
									[
										364978,
										364982
									],
									[
										365107,
										365111
									],
									[
										365218,
										365222
									],
									[
										365352,
										365356
									],
									[
										365435,
										365439
									],
									[
										365552,
										365556
									],
									[
										365723,
										365727
									],
									[
										365971,
										365975
									],
									[
										366306,
										366310
									],
									[
										366578,
										366582
									],
									[
										366860,
										366864
									],
									[
										366998,
										367002
									],
									[
										367292,
										367296
									],
									[
										367341,
										367345
									],
									[
										367607,
										367611
									],
									[
										367720,
										367724
									],
									[
										367942,
										367946
									],
									[
										368130,
										368134
									],
									[
										368430,
										368434
									],
									[
										368436,
										368440
									],
									[
										368618,
										368622
									],
									[
										368624,
										368628
									],
									[
										368630,
										368634
									],
									[
										368809,
										368813
									],
									[
										368963,
										368967
									],
									[
										369202,
										369206
									],
									[
										369277,
										369281
									],
									[
										369506,
										369510
									],
									[
										369548,
										369552
									],
									[
										369730,
										369734
									],
									[
										369966,
										369970
									],
									[
										369972,
										369976
									],
									[
										370121,
										370125
									],
									[
										370262,
										370266
									],
									[
										370268,
										370272
									],
									[
										370294,
										370298
									],
									[
										370563,
										370567
									],
									[
										370569,
										370573
									],
									[
										370595,
										370599
									],
									[
										370869,
										370873
									],
									[
										370944,
										370948
									],
									[
										371189,
										371193
									],
									[
										371195,
										371199
									],
									[
										371201,
										371205
									],
									[
										371465,
										371469
									],
									[
										371738,
										371742
									],
									[
										371869,
										371873
									],
									[
										372028,
										372032
									],
									[
										372034,
										372038
									],
									[
										372208,
										372212
									],
									[
										372310,
										372314
									],
									[
										372494,
										372498
									],
									[
										372728,
										372732
									],
									[
										372837,
										372841
									],
									[
										373136,
										373140
									],
									[
										373409,
										373413
									],
									[
										373672,
										373676
									],
									[
										373739,
										373743
									],
									[
										373785,
										373789
									],
									[
										373848,
										373852
									],
									[
										374074,
										374078
									],
									[
										374281,
										374285
									],
									[
										374346,
										374350
									],
									[
										374706,
										374710
									],
									[
										374806,
										374810
									],
									[
										375092,
										375096
									],
									[
										375376,
										375380
									],
									[
										375557,
										375561
									],
									[
										375696,
										375700
									],
									[
										375797,
										375801
									],
									[
										375922,
										375926
									],
									[
										376068,
										376072
									],
									[
										376223,
										376227
									],
									[
										376350,
										376354
									],
									[
										376462,
										376466
									],
									[
										376676,
										376680
									],
									[
										376682,
										376686
									],
									[
										376847,
										376851
									],
									[
										377060,
										377064
									],
									[
										377133,
										377137
									],
									[
										377393,
										377397
									],
									[
										377399,
										377403
									],
									[
										377405,
										377409
									],
									[
										377563,
										377567
									],
									[
										377798,
										377802
									],
									[
										377831,
										377835
									],
									[
										377954,
										377958
									],
									[
										378149,
										378153
									],
									[
										378222,
										378226
									],
									[
										378488,
										378492
									],
									[
										378679,
										378683
									],
									[
										378758,
										378762
									],
									[
										379030,
										379034
									],
									[
										379036,
										379040
									],
									[
										379176,
										379180
									],
									[
										379308,
										379312
									],
									[
										379377,
										379381
									],
									[
										379640,
										379644
									],
									[
										379646,
										379650
									],
									[
										379652,
										379656
									],
									[
										379829,
										379833
									],
									[
										380018,
										380022
									],
									[
										380093,
										380097
									],
									[
										380411,
										380415
									],
									[
										380625,
										380629
									],
									[
										380692,
										380696
									],
									[
										381015,
										381019
									],
									[
										381169,
										381173
									],
									[
										381238,
										381242
									],
									[
										381529,
										381533
									],
									[
										381643,
										381647
									],
									[
										381793,
										381797
									],
									[
										381853,
										381857
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								11143,
								11143
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"output_tag": 1,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 2601.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/Users/William/Develop/MiCO/mico/security/Curve25519/curve25519-donna-c64.c",
					"settings":
					{
						"buffer_size": 14257,
						"regions":
						{
						},
						"selection":
						[
							[
								14009,
								14013
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6936.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/Users/William/Develop/MiCO/libraries/utilities/json_c/linkhash.c",
					"settings":
					{
						"buffer_size": 4998,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/Users/William/Library/Application Support/Sublime Text 2/Packages/SublimeClang/clang/include/stddef.h",
					"settings":
					{
						"buffer_size": 2104,
						"regions":
						{
						},
						"selection":
						[
							[
								1415,
								1320
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 333.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/Users/William/Develop/MiCO/libraries/utilities/json_c/json_object.c",
					"settings":
					{
						"buffer_size": 13942,
						"regions":
						{
						},
						"selection":
						[
							[
								373,
								373
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/Users/William/Develop/MiCO/libraries/utilities/json_c/json_tokener.c",
					"settings":
					{
						"buffer_size": 21057,
						"regions":
						{
						},
						"selection":
						[
							[
								300,
								300
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 34.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.clang":
	{
		"height": 27.0
	},
	"output.exec":
	{
		"height": 100.0
	},
	"output.git":
	{
		"height": 100.0
	},
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"micode",
				"MICO/MICODefine.h"
			],
			[
				"",
				"STM32F2xx_StdPeriph_Driver/src/stm32f2xx_i2c.c"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 285.0,
	"status_bar_visible": true
}
